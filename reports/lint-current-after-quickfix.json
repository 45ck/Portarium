[{"filePath":"D:\\Visual Studio Projects\\VAOP\\.dependency-cruiser.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\alt-a-command\\wireframe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\alt-b-stream\\wireframe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\alt-c-board\\wireframe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\cockpit\\api-client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\cockpit\\demo-bindings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\cockpit\\keyboard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\cockpit\\mock-api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\cockpit\\wireframe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\docs\\ui\\lofi\\wireframe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\infra\\activepieces\\pieces\\portarium-projects-work-mgmt-piece\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\assets\\check-cockpit-assets.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\assets\\chroma-key-icons.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\assets\\generate-cockpit-app-icons.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\assets\\generate-cockpit-assets.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\assets\\optimize-cockpit-assets.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\assets\\validate-cockpit-assets.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\bd.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\check-bead-prerequisites.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\evaluate-stop-loss-thresholds.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\generate-bead-acceptance-scorecard.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\generate-bead-metadata-audit.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\generate-execution-dag.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\beads\\generate-weekly-pe-audit.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\audit-high.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\check-gate-baseline.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\gate-baseline.shared.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\openapi-breaking-check.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\openapi-compatibility-check.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\openapi-operation-ids.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\scan-secrets.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\update-gate-baseline.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\ci\\vertical-pack-publish-gate.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\codegen\\generate-ts-client.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-erpnext-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-keycloak-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-killbill-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-mautic-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-mosquitto-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-nav2-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-node-opcua-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-odoo.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-openfga-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-paperless-ngx-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-ros2-common-interfaces-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-rosbridge-suite-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-spire-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-stripe-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-vault-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-zammad-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\extract-zenoh-cif.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\gen-research-index.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\generate-operation-contract-stubs.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\validate-artifacts.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\vendor-upstreams.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\verify-operation-contract-stubs.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\domain-atlas\\verify-port-family-readiness.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\scripts\\qa\\capture-cockpit-fullshots.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\agent-heartbeat.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\agent-heartbeat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\assign-workforce-member.helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\assign-workforce-member.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\assign-workforce-member.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\bus.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\bus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\complete-human-task.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\complete-human-task.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\heartbeat.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\heartbeat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\machine-agent-registration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\machine-agent-registration.ts","messages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (356). Maximum allowed is 350.","line":386,"column":1,"nodeType":null,"messageId":"exceed","endLine":392,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  parseAgentConfigV1,\n  parseMachineRegistrationV1,\n} from '../../domain/machines/machine-registration-v1.js';\nimport type {\n  AgentConfigV1,\n  MachineRegistrationV1,\n} from '../../domain/machines/machine-registration-v1.js';\nimport {\n  evaluateCapabilityDriftQuarantinePolicyV1,\n  summarizeCapabilityDriftV1,\n} from '../../domain/machines/capability-drift-quarantine-policy-v1.js';\nimport { establishCapabilityHandshakeV1 } from '../../domain/machines/capability-handshake-v1.js';\nimport { AgentId, EvidenceId, WorkspaceId } from '../../domain/primitives/index.js';\nimport {\n  APP_ACTIONS,\n  err,\n  ok,\n  type AppContext,\n  type Conflict,\n  type DependencyFailure,\n  type Forbidden,\n  type NotFound,\n  type Result,\n  type ValidationFailed,\n} from '../common/index.js';\nimport type {\n  AuthorizationPort,\n  Clock,\n  EvidenceEntryAppendInput,\n  EvidenceLogPort,\n  IdGenerator,\n  IdempotencyStore,\n  MachineRegistryStore,\n  UnitOfWork,\n} from '../ports/index.js';\nimport type { IdempotencyKey } from '../ports/idempotency.js';\n\nconst REGISTER_MACHINE_COMMAND = 'RegisterMachine';\nconst CREATE_AGENT_COMMAND = 'CreateAgent';\nconst UPDATE_AGENT_CAPABILITIES_COMMAND = 'UpdateAgentCapabilities';\n\nexport type RegisterMachineInput = Readonly<{ idempotencyKey: string; machine: unknown }>;\nexport type RegisterMachineOutput = Readonly<{ machineId: MachineRegistrationV1['machineId'] }>;\nexport type CreateAgentInput = Readonly<{ idempotencyKey: string; agent: unknown }>;\nexport type CreateAgentOutput = Readonly<{ agentId: AgentConfigV1['agentId'] }>;\n\nexport type UpdateAgentCapabilitiesInput = Readonly<{\n  idempotencyKey: string;\n  workspaceId: string;\n  agentId: string;\n  allowedTools: readonly string[];\n}>;\n\nexport type UpdateAgentCapabilitiesOutput = Readonly<{\n  agentId: AgentConfigV1['agentId'];\n  allowedTools: readonly string[];\n}>;\n\nexport type MachineAgentRegistrationError =\n  | Forbidden\n  | ValidationFailed\n  | NotFound\n  | Conflict\n  | DependencyFailure;\n\nexport interface MachineAgentRegistrationDeps {\n  authorization: AuthorizationPort;\n  clock: Clock;\n  idGenerator: IdGenerator;\n  idempotency: IdempotencyStore;\n  unitOfWork: UnitOfWork;\n  machineRegistryStore: MachineRegistryStore;\n  evidenceLog: EvidenceLogPort;\n}\n\nfunction validateIdempotencyKey(key: string): Result<string, ValidationFailed> {\n  if (typeof key !== 'string' || key.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: 'idempotencyKey must be a non-empty string.' });\n  }\n  return ok(key);\n}\n\nfunction toDependencyFailure(error: unknown, fallback: string): DependencyFailure {\n  return { kind: 'DependencyFailure', message: error instanceof Error ? error.message : fallback };\n}\n\nfunction newCommandKey(ctx: AppContext, commandName: string, requestKey: string): IdempotencyKey {\n  return { tenantId: ctx.tenantId, commandName, requestKey };\n}\n\nfunction buildEvidenceEntry(\n  deps: Pick<MachineAgentRegistrationDeps, 'clock' | 'idGenerator'>,\n  ctx: AppContext,\n  summary: string,\n): Result<EvidenceEntryAppendInput, DependencyFailure> {\n  const tsValue = deps.clock.nowIso();\n  if (tsValue.trim() === '')\n    return err({ kind: 'DependencyFailure', message: 'Clock returned an invalid timestamp.' });\n  const idValue = deps.idGenerator.generateId();\n  if (idValue.trim() === '')\n    return err({ kind: 'DependencyFailure', message: 'Unable to generate evidence identifier.' });\n  return ok({\n    schemaVersion: 1,\n    evidenceId: EvidenceId(idValue),\n    workspaceId: ctx.tenantId,\n    correlationId: ctx.correlationId,\n    occurredAtIso: tsValue,\n    category: 'Action',\n    summary,\n    actor: { kind: 'User', userId: ctx.principalId },\n  });\n}\n\nfunction ensureTenantMatch(\n  ctx: AppContext,\n  workspaceId: string,\n): Result<true, Forbidden | ValidationFailed> {\n  if (typeof workspaceId !== 'string' || workspaceId.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: 'workspaceId must be a non-empty string.' });\n  }\n  if (WorkspaceId(workspaceId) !== ctx.tenantId) {\n    return err({\n      kind: 'Forbidden',\n      action: APP_ACTIONS.machineAgentRegister,\n      message: 'Tenant mismatch.',\n    });\n  }\n  return ok(true);\n}\n\nfunction ensureAllowedToolsShape(allowedTools: readonly string[]): Result<true, ValidationFailed> {\n  if (!Array.isArray(allowedTools)) {\n    return err({ kind: 'ValidationFailed', message: 'allowedTools must be an array.' });\n  }\n  if (!allowedTools.every((tool) => typeof tool === 'string' && tool.trim() !== '')) {\n    return err({\n      kind: 'ValidationFailed',\n      message: 'allowedTools entries must be non-empty strings.',\n    });\n  }\n  return ok(true);\n}\n\nasync function ensureRegisterAllowed(\n  authorization: AuthorizationPort,\n  ctx: AppContext,\n): Promise<Result<true, Forbidden>> {\n  const allowed = await authorization.isAllowed(ctx, APP_ACTIONS.machineAgentRegister);\n  if (allowed) return ok(true);\n  return err({\n    kind: 'Forbidden',\n    action: APP_ACTIONS.machineAgentRegister,\n    message: 'Caller is not permitted to register machine/agent resources.',\n  });\n}\n\nexport async function registerMachine(\n  deps: MachineAgentRegistrationDeps,\n  ctx: AppContext,\n  input: RegisterMachineInput,\n): Promise<Result<RegisterMachineOutput, MachineAgentRegistrationError>> {\n  const idem = validateIdempotencyKey(input.idempotencyKey);\n  if (!idem.ok) return idem;\n  const allowed = await ensureRegisterAllowed(deps.authorization, ctx);\n  if (!allowed.ok) return allowed;\n\n  let machine: MachineRegistrationV1;\n  try {\n    machine = parseMachineRegistrationV1(input.machine);\n  } catch (error) {\n    return err({\n      kind: 'ValidationFailed',\n      message: error instanceof Error ? error.message : 'Invalid machine registration payload.',\n    });\n  }\n  const tenantMatch = ensureTenantMatch(ctx, machine.workspaceId);\n  if (!tenantMatch.ok) return tenantMatch;\n\n  const commandKey = newCommandKey(ctx, REGISTER_MACHINE_COMMAND, idem.value);\n  const cached = await deps.idempotency.get<RegisterMachineOutput>(commandKey);\n  if (cached) return ok(cached);\n\n  const existing = await deps.machineRegistryStore.getMachineRegistrationById(\n    ctx.tenantId,\n    machine.machineId,\n  );\n  if (existing !== null)\n    return err({ kind: 'Conflict', message: `Machine ${machine.machineId} already exists.` });\n\n  const evidence = buildEvidenceEntry(deps, ctx, `Registered machine ${machine.machineId}.`);\n  if (!evidence.ok) return evidence;\n\n  try {\n    return await deps.unitOfWork.execute(async () => {\n      await deps.machineRegistryStore.saveMachineRegistration(ctx.tenantId, machine);\n      await deps.evidenceLog.appendEntry(ctx.tenantId, evidence.value);\n      const output: RegisterMachineOutput = { machineId: machine.machineId };\n      await deps.idempotency.set(commandKey, output);\n      return ok(output);\n    });\n  } catch (error) {\n    return err(toDependencyFailure(error, 'Failed to register machine.'));\n  }\n}\n\nfunction checkCapabilityRoutability(\n  agent: AgentConfigV1,\n  machine: MachineRegistrationV1,\n): Result<true, ValidationFailed> {\n  const handshake = establishCapabilityHandshakeV1({\n    machineCapabilities: machine.capabilities,\n    agentCapabilities: agent.capabilities,\n  });\n  if (handshake.nonRoutableAgentCapabilities.length > 0) {\n    const nonRoutable = handshake.nonRoutableAgentCapabilities\n      .map((d) => String(d.capability))\n      .join(', ');\n    return err({\n      kind: 'ValidationFailed',\n      message: `Agent capabilities are not routable on machine ${agent.machineId}: ${nonRoutable}.`,\n    });\n  }\n  return ok(true);\n}\n\nfunction checkAgentConflict(\n  agent: AgentConfigV1,\n  existing: AgentConfigV1 | null,\n): Result<true, Conflict | ValidationFailed> {\n  if (existing === null) return ok(true);\n  const drift = evaluateCapabilityDriftQuarantinePolicyV1({\n    baselineCapabilities: existing.capabilities,\n    observedCapabilities: agent.capabilities,\n    source: 'ReRegistration',\n    reviewed: false,\n  });\n  if (drift.decision === 'Quarantine') {\n    return err({\n      kind: 'Conflict',\n      message: `Agent ${agent.agentId} quarantined due to capability drift (${summarizeCapabilityDriftV1(drift.drift)}).`,\n    });\n  }\n  return err({ kind: 'Conflict', message: `Agent ${agent.agentId} already exists.` });\n}\n\nasync function resolveAgentForCreate(\n  deps: MachineAgentRegistrationDeps,\n  ctx: AppContext,\n  input: CreateAgentInput,\n): Promise<Result<AgentConfigV1, MachineAgentRegistrationError>> {\n  let agent: AgentConfigV1;\n  try {\n    agent = parseAgentConfigV1(input.agent);\n  } catch (error) {\n    return err({\n      kind: 'ValidationFailed',\n      message: error instanceof Error ? error.message : 'Invalid agent payload.',\n    });\n  }\n  const tenantMatch = ensureTenantMatch(ctx, agent.workspaceId);\n  if (!tenantMatch.ok) return tenantMatch;\n  const machine = await deps.machineRegistryStore.getMachineRegistrationById(\n    ctx.tenantId,\n    agent.machineId,\n  );\n  if (machine === null)\n    return err({\n      kind: 'NotFound',\n      resource: 'MachineRegistration',\n      message: `Machine ${agent.machineId} not found.`,\n    });\n  const routable = checkCapabilityRoutability(agent, machine);\n  if (!routable.ok) return routable;\n  const existingAgent = await deps.machineRegistryStore.getAgentConfigById(\n    ctx.tenantId,\n    agent.agentId,\n  );\n  const conflict = checkAgentConflict(agent, existingAgent);\n  if (!conflict.ok) return conflict;\n  return ok(agent);\n}\n\nexport async function createAgent(\n  deps: MachineAgentRegistrationDeps,\n  ctx: AppContext,\n  input: CreateAgentInput,\n): Promise<Result<CreateAgentOutput, MachineAgentRegistrationError>> {\n  const idem = validateIdempotencyKey(input.idempotencyKey);\n  if (!idem.ok) return idem;\n  const allowed = await ensureRegisterAllowed(deps.authorization, ctx);\n  if (!allowed.ok) return allowed;\n\n  const commandKey = newCommandKey(ctx, CREATE_AGENT_COMMAND, idem.value);\n  const cached = await deps.idempotency.get<CreateAgentOutput>(commandKey);\n  if (cached) return ok(cached);\n\n  const agentResult = await resolveAgentForCreate(deps, ctx, input);\n  if (!agentResult.ok) return agentResult;\n  const agent = agentResult.value;\n\n  const evidence = buildEvidenceEntry(deps, ctx, `Created agent ${agent.agentId}.`);\n  if (!evidence.ok) return evidence;\n\n  try {\n    return await deps.unitOfWork.execute(async () => {\n      await deps.machineRegistryStore.saveAgentConfig(ctx.tenantId, agent);\n      await deps.evidenceLog.appendEntry(ctx.tenantId, evidence.value);\n      const output: CreateAgentOutput = { agentId: agent.agentId };\n      await deps.idempotency.set(commandKey, output);\n      return ok(output);\n    });\n  } catch (error) {\n    return err(toDependencyFailure(error, 'Failed to create agent.'));\n  }\n}\n\nfunction validateUpdateInput(\n  ctx: AppContext,\n  input: UpdateAgentCapabilitiesInput,\n): Result<string, MachineAgentRegistrationError> {\n  const idem = validateIdempotencyKey(input.idempotencyKey);\n  if (!idem.ok) return idem;\n  const tenantMatch = ensureTenantMatch(ctx, input.workspaceId);\n  if (!tenantMatch.ok) return tenantMatch;\n  const toolsShape = ensureAllowedToolsShape(input.allowedTools);\n  if (!toolsShape.ok) return toolsShape;\n  if (typeof input.agentId !== 'string' || input.agentId.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: 'agentId must be a non-empty string.' });\n  }\n  return idem;\n}\n\nexport async function updateAgentCapabilities(\n  deps: MachineAgentRegistrationDeps,\n  ctx: AppContext,\n  input: UpdateAgentCapabilitiesInput,\n): Promise<Result<UpdateAgentCapabilitiesOutput, MachineAgentRegistrationError>> {\n  const validationResult = validateUpdateInput(ctx, input);\n  if (!validationResult.ok) return validationResult;\n  const validatedKey = validationResult.value;\n\n  const allowed = await ensureRegisterAllowed(deps.authorization, ctx);\n  if (!allowed.ok) return allowed;\n\n  const commandKey = newCommandKey(ctx, UPDATE_AGENT_CAPABILITIES_COMMAND, validatedKey);\n  const cached = await deps.idempotency.get<UpdateAgentCapabilitiesOutput>(commandKey);\n  if (cached) return ok(cached);\n\n  const agentId = AgentId(input.agentId);\n  const existingAgent = await deps.machineRegistryStore.getAgentConfigById(ctx.tenantId, agentId);\n  if (existingAgent === null) {\n    return err({\n      kind: 'NotFound',\n      resource: 'AgentConfig',\n      message: `Agent ${input.agentId} not found.`,\n    });\n  }\n\n  let updatedAgent: AgentConfigV1;\n  try {\n    updatedAgent = parseAgentConfigV1({ ...existingAgent, allowedTools: [...input.allowedTools] });\n  } catch (error) {\n    return err({\n      kind: 'ValidationFailed',\n      message: error instanceof Error ? error.message : 'Invalid agent capabilities payload.',\n    });\n  }\n\n  const evidence = buildEvidenceEntry(\n    deps,\n    ctx,\n    `Updated allowed tools for agent ${updatedAgent.agentId}.`,\n  );\n  if (!evidence.ok) return evidence;\n\n  try {\n    return await deps.unitOfWork.execute(async () => {\n      await deps.machineRegistryStore.saveAgentConfig(ctx.tenantId, updatedAgent);\n      await deps.evidenceLog.appendEntry(ctx.tenantId, evidence.value);\n      const output: UpdateAgentCapabilitiesOutput = {\n        agentId: updatedAgent.agentId,\n        allowedTools: updatedAgent.allowedTools,\n      };\n      await deps.idempotency.set(commandKey, output);\n      return ok(output);\n    });\n  } catch (error) {\n    return err(toDependencyFailure(error, 'Failed to update agent capabilities.'));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\register-workspace.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\register-workspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\start-workflow.test.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Arrow function has too many lines (526). Maximum allowed is 300.","line":58,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":619,"endColumn":2},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (579). Maximum allowed is 350.","line":375,"column":1,"nodeType":null,"messageId":"exceed","endLine":620,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';\n\nimport { parseAdapterRegistrationV1 } from '../../domain/adapters/adapter-registration-v1.js';\nimport { TenantId } from '../../domain/primitives/index.js';\nimport { parseRunV1 } from '../../domain/runs/index.js';\nimport { parseWorkflowV1 } from '../../domain/workflows/workflow-v1.js';\nimport { toAppContext } from '../common/context.js';\nimport { APP_ACTIONS } from '../common/actions.js';\nimport {\n  type AdapterRegistrationStore,\n  type AuthorizationPort,\n  type Clock,\n  type EventPublisher,\n  type IdGenerator,\n  type IdempotencyStore,\n  type RunStore,\n  type UnitOfWork,\n  type WorkflowOrchestrator,\n  type WorkflowStore,\n} from '../ports/index.js';\nimport { startWorkflow } from './start-workflow.js';\n\nconst WORKFLOW = parseWorkflowV1({\n  schemaVersion: 1,\n  workflowId: 'wf-1',\n  workspaceId: 'ws-1',\n  name: 'Onboard',\n  version: 1,\n  active: true,\n  executionTier: 'Auto',\n  actions: [\n    {\n      actionId: 'act-1',\n      order: 1,\n      portFamily: 'ItsmItOps',\n      operation: 'workflow:simulate',\n    },\n  ],\n});\n\nconst ADAPTER_REGISTRATION = parseAdapterRegistrationV1({\n  schemaVersion: 1,\n  adapterId: 'adapter-itsm-1',\n  workspaceId: 'ws-1',\n  providerSlug: 'service-now',\n  portFamily: 'ItsmItOps',\n  enabled: true,\n  capabilityMatrix: [{ operation: 'workflow:simulate', requiresAuth: true }],\n  executionPolicy: {\n    tenantIsolationMode: 'PerTenantWorker',\n    egressAllowlist: ['https://api.service-now.example'],\n    credentialScope: 'capabilityMatrix',\n    sandboxVerified: true,\n    sandboxAvailable: true,\n  },\n});\n\ndescribe('startWorkflow', () => {\n  let authorization: AuthorizationPort;\n  let clock: Clock;\n  let idGenerator: IdGenerator;\n  let idempotency: IdempotencyStore;\n  let unitOfWork: UnitOfWork;\n  let workflowStore: WorkflowStore;\n  let adapterRegistrationStore: AdapterRegistrationStore;\n  let runStore: RunStore;\n  let orchestrator: WorkflowOrchestrator;\n  let eventPublisher: EventPublisher;\n\n  beforeEach(() => {\n    authorization = { isAllowed: vi.fn(async () => true) };\n    clock = { nowIso: vi.fn(() => '2026-02-17T00:01:00.000Z') };\n    let sequence = 1;\n    idGenerator = {\n      generateId: vi.fn(() => `id-${sequence++}`),\n    };\n    idempotency = {\n      get: vi.fn(async () => null),\n      set: vi.fn(async () => undefined),\n    };\n    unitOfWork = { execute: vi.fn(async (fn) => fn()) };\n    workflowStore = {\n      getWorkflowById: vi.fn(async () => WORKFLOW),\n      listWorkflowsByName: vi.fn(async () => [WORKFLOW]),\n    };\n    adapterRegistrationStore = {\n      listByWorkspace: vi.fn(async () => [ADAPTER_REGISTRATION]),\n    };\n    runStore = {\n      getRunById: vi.fn(async () => null),\n      saveRun: vi.fn(async () => undefined),\n    };\n    orchestrator = {\n      startRun: vi.fn(async () => undefined),\n    };\n    eventPublisher = {\n      publish: vi.fn(async () => undefined),\n    };\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('starts a run, stores state, and emits an event', async () => {\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(true);\n    if (!result.ok) {\n      throw new Error('Expected success response.');\n    }\n    expect(result.value.runId.startsWith('id-')).toBe(true);\n    expect(runStore.saveRun).toHaveBeenCalledTimes(1);\n    expect(orchestrator.startRun).toHaveBeenCalledTimes(1);\n    expect(eventPublisher.publish).toHaveBeenCalledTimes(1);\n\n    const published = (eventPublisher.publish as ReturnType<typeof vi.fn>).mock\n      .calls[0]?.[0] as Record<string, unknown>;\n    expect(published['specversion']).toBe('1.0');\n    expect(published['type']).toBe('com.portarium.run.RunStarted');\n    expect(published['tenantid']).toBe('tenant-1');\n    expect(published['correlationid']).toBe('corr-1');\n    expect(published['source']).toBe('portarium.control-plane.workflow-runtime');\n  });\n\n  it('replays from idempotency cache', async () => {\n    const cachedRun = { runId: 'run-cached' as const };\n    idempotency.get = vi.fn(async () => cachedRun) as IdempotencyStore['get'];\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(true);\n    if (!result.ok) {\n      throw new Error('Expected success response.');\n    }\n    expect(result.value.runId).toBe('run-cached');\n    expect(runStore.saveRun).not.toHaveBeenCalled();\n    expect(orchestrator.startRun).not.toHaveBeenCalled();\n  });\n\n  it('requires run:start authorisation', async () => {\n    authorization.isAllowed = vi.fn(async () => false);\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['auditor'],\n      }),\n      {\n        idempotencyKey: 'req-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) {\n      throw new Error('Expected forbidden response.');\n    }\n    expect(result.error.kind).toBe('Forbidden');\n    expect(authorization.isAllowed).toHaveBeenCalledWith(\n      expect.objectContaining({ tenantId: TenantId('tenant-1') }),\n      APP_ACTIONS.runStart,\n    );\n  });\n\n  it('rejects empty timestamp from clock', async () => {\n    clock.nowIso = vi.fn(() => '');\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) {\n      throw new Error('Expected dependency failure response.');\n    }\n    expect(result.error.kind).toBe('DependencyFailure');\n  });\n\n  it('rejects empty generated run identifier', async () => {\n    idGenerator.generateId = vi.fn(() => '');\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) {\n      throw new Error('Expected dependency failure response.');\n    }\n    expect(result.error.kind).toBe('DependencyFailure');\n  });\n\n  it('rejects empty generated event identifier', async () => {\n    idGenerator.generateId = vi.fn().mockReturnValueOnce('run-1').mockReturnValueOnce('');\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) {\n      throw new Error('Expected dependency failure response.');\n    }\n    expect(result.error.kind).toBe('DependencyFailure');\n  });\n\n  it('passes idempotencyKey to orchestrator for Temporal-level deduplication', async () => {\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-concurrent',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(true);\n    expect(orchestrator.startRun).toHaveBeenCalledWith(\n      expect.objectContaining({ idempotencyKey: 'req-concurrent' }),\n    );\n  });\n\n  it('propagates traceparent and tracestate into orchestrator input', async () => {\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n        traceparent: '00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01',\n        tracestate: 'vendor=value',\n      }),\n      {\n        idempotencyKey: 'req-trace',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(true);\n    expect(orchestrator.startRun).toHaveBeenCalledWith(\n      expect.objectContaining({\n        traceparent: '00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01',\n        tracestate: 'vendor=value',\n      }),\n    );\n  });\n\n  it('rejects starts when workflow versioning has multiple active versions', async () => {\n    workflowStore.listWorkflowsByName = vi.fn(async () => [\n      WORKFLOW,\n      parseWorkflowV1({\n        ...WORKFLOW,\n        workflowId: 'wf-2',\n        version: 2,\n        active: true,\n      }),\n    ]);\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-version-conflict',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) throw new Error('Expected conflict response.');\n    expect(result.error.kind).toBe('Conflict');\n    expect(result.error.message).toContain('multiple active versions');\n  });\n\n  it('rejects starts when selected workflow is not the active head version', async () => {\n    workflowStore.listWorkflowsByName = vi.fn(async () => [\n      parseWorkflowV1({\n        ...WORKFLOW,\n        workflowId: 'wf-1',\n        version: 1,\n        active: false,\n      }),\n      parseWorkflowV1({\n        ...WORKFLOW,\n        workflowId: 'wf-2',\n        version: 2,\n        active: true,\n      }),\n    ]);\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-stale-workflow',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) throw new Error('Expected conflict response.');\n    expect(result.error.kind).toBe('Conflict');\n    expect(result.error.message).toContain('not currently active');\n  });\n\n  it('rejects starts when no active adapter exists for a required port family', async () => {\n    adapterRegistrationStore.listByWorkspace = vi.fn(async () => []);\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-no-adapter',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) throw new Error('Expected conflict response.');\n    expect(result.error.kind).toBe('Conflict');\n    expect(result.error.message).toContain('no active adapter');\n  });\n\n  it('rejects starts when multiple active adapters exist for the same port family', async () => {\n    adapterRegistrationStore.listByWorkspace = vi.fn(async () => [\n      ADAPTER_REGISTRATION,\n      parseAdapterRegistrationV1({\n        ...ADAPTER_REGISTRATION,\n        adapterId: 'adapter-itsm-2',\n        providerSlug: 'freshservice',\n      }),\n    ]);\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-multi-adapter',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) throw new Error('Expected conflict response.');\n    expect(result.error.kind).toBe('Conflict');\n    expect(result.error.message).toContain('multiple active adapters');\n  });\n\n  it('rejects starts when generated run id already exists', async () => {\n    runStore.getRunById = vi.fn(async () =>\n      parseRunV1({\n        schemaVersion: 1,\n        runId: 'id-1',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n        correlationId: 'corr-existing',\n        executionTier: 'Auto',\n        initiatedByUserId: 'user-existing',\n        status: 'Pending',\n        createdAtIso: '2026-02-16T00:00:00.000Z',\n      }),\n    );\n\n    const result = await startWorkflow(\n      {\n        authorization,\n        clock,\n        idGenerator,\n        idempotency,\n        unitOfWork,\n        workflowStore,\n        adapterRegistrationStore,\n        runStore,\n        orchestrator,\n        eventPublisher,\n      },\n      toAppContext({\n        tenantId: 'tenant-1',\n        principalId: 'user-1',\n        correlationId: 'corr-1',\n        roles: ['operator'],\n      }),\n      {\n        idempotencyKey: 'req-run-conflict',\n        workspaceId: 'ws-1',\n        workflowId: 'wf-1',\n      },\n    );\n\n    expect(result.ok).toBe(false);\n    if (result.ok) throw new Error('Expected conflict response.');\n    expect(result.error.kind).toBe('Conflict');\n    expect(result.error.message).toContain('already exists');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\start-workflow.trigger-routing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\start-workflow.trigger-routing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\start-workflow.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async function 'buildStartWorkflowPlan' has a complexity of 12. Maximum allowed is 10.","line":319,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":319,"endColumn":38},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (385). Maximum allowed is 350.","line":393,"column":1,"nodeType":null,"messageId":"exceed","endLine":435,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  type RunId as RunIdType,\n  type WorkspaceId as WorkspaceIdType,\n  type WorkflowId as WorkflowIdType,\n  WorkspaceId,\n  WorkflowId,\n} from '../../domain/primitives/index.js';\nimport { parseRunV1, type RunV1 } from '../../domain/runs/index.js';\nimport { parseWorkflowTriggerV1, type WorkflowTriggerV1 } from '../../domain/schedule/index.js';\nimport type { WorkflowV1 } from '../../domain/workflows/index.js';\nimport { parseWorkflowV1 } from '../../domain/workflows/index.js';\nimport {\n  type AppContext,\n  type Conflict,\n  type DependencyFailure,\n  type Forbidden,\n  APP_ACTIONS,\n  err,\n  ok,\n  type Result,\n  type ValidationFailed,\n  type NotFound,\n} from '../common/index.js';\nimport { domainEventToPortariumCloudEvent } from '../events/cloudevent.js';\nimport type { DomainEventV1 } from '../../domain/events/domain-events-v1.js';\nimport type {\n  AdapterRegistrationStore,\n  AuthorizationPort,\n  Clock,\n  EventPublisher,\n  IdGenerator,\n  IdempotencyStore,\n  IdempotencyKey,\n  RunStore,\n  UnitOfWork,\n  WorkflowOrchestrator,\n  WorkflowStore,\n} from '../ports/index.js';\nimport type { TriggerExecutionRouterPort } from '../services/trigger-execution-router.js';\nimport {\n  ensureRunIdIsUnique,\n  ensureSingleActiveAdapterPerPort,\n  ensureSingleActiveWorkflowVersion,\n} from '../services/repository-aggregate-invariants.js';\n\nconst START_WORKFLOW_COMMAND = 'StartWorkflow';\nconst START_WORKFLOW_SOURCE = 'portarium.control-plane.workflow-runtime';\n\nexport type StartWorkflowInput = Readonly<{\n  idempotencyKey: string;\n  workspaceId: string;\n  workflowId: string;\n  trigger?: unknown;\n}>;\n\nexport type StartWorkflowOutput = Readonly<{\n  runId: RunIdType;\n}>;\n\nexport type StartWorkflowError =\n  | Forbidden\n  | ValidationFailed\n  | NotFound\n  | Conflict\n  | DependencyFailure;\n\nexport interface StartWorkflowDeps {\n  authorization: AuthorizationPort;\n  clock: Clock;\n  idGenerator: IdGenerator;\n  idempotency: IdempotencyStore;\n  unitOfWork: UnitOfWork;\n  workflowStore: WorkflowStore;\n  adapterRegistrationStore: AdapterRegistrationStore;\n  runStore: RunStore;\n  orchestrator: WorkflowOrchestrator;\n  eventPublisher: EventPublisher;\n  triggerRouter?: TriggerExecutionRouterPort;\n}\n\ntype Err<E> = Readonly<{ ok: false; error: E }>;\n\ntype ParsedIds = Readonly<{\n  workspaceId: WorkspaceIdType;\n  workflowId: WorkflowIdType;\n}>;\n\ntype GeneratedValues = Readonly<{\n  runIdValue: string;\n  createdAtIso: string;\n  eventIdValue: string;\n}>;\n\nfunction requireNonEmpty(\n  value: string | undefined | null,\n  fieldName: string,\n): Result<string, ValidationFailed> {\n  if (typeof value !== 'string' || value.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: `${fieldName} must be a non-empty string.` });\n  }\n  return ok(value);\n}\n\nfunction validateInput(input: StartWorkflowInput): Result<ParsedIds, StartWorkflowError> {\n  const wsCheck = requireNonEmpty(input.workspaceId, 'workspaceId');\n  if (!wsCheck.ok) return wsCheck;\n  const wfCheck = requireNonEmpty(input.workflowId, 'workflowId');\n  if (!wfCheck.ok) return wfCheck;\n\n  try {\n    return ok({\n      workspaceId: WorkspaceId(input.workspaceId),\n      workflowId: WorkflowId(input.workflowId),\n    });\n  } catch {\n    return err({ kind: 'ValidationFailed', message: 'Invalid workflow identifiers.' });\n  }\n}\n\nfunction parseTriggerFromInput(\n  raw: unknown,\n  ids: ParsedIds,\n): Result<WorkflowTriggerV1 | undefined, ValidationFailed> {\n  if (raw === undefined || raw === null) {\n    return ok(undefined);\n  }\n\n  let trigger: WorkflowTriggerV1;\n  try {\n    trigger = parseWorkflowTriggerV1(raw);\n  } catch {\n    return err({ kind: 'ValidationFailed', message: 'Invalid trigger payload.' });\n  }\n\n  if (\n    trigger.workspaceId.toString() !== ids.workspaceId.toString() ||\n    trigger.workflowId.toString() !== ids.workflowId.toString()\n  ) {\n    return err({\n      kind: 'ValidationFailed',\n      message: 'trigger workspaceId/workflowId must match the command workspaceId/workflowId.',\n    });\n  }\n\n  return ok(trigger);\n}\n\nasync function checkAuthorization(\n  authorization: AuthorizationPort,\n  ctx: AppContext,\n): Promise<Err<Forbidden> | null> {\n  const allowed = await authorization.isAllowed(ctx, APP_ACTIONS.runStart);\n  if (!allowed) {\n    return err({\n      kind: 'Forbidden',\n      action: APP_ACTIONS.runStart,\n      message: 'Caller is not permitted to start runs.',\n    });\n  }\n  return null;\n}\n\nasync function resolveWorkflow(\n  store: WorkflowStore,\n  ctx: AppContext,\n  ids: ParsedIds,\n  rawWorkflowId: string,\n): Promise<Result<WorkflowV1, StartWorkflowError>> {\n  const workflow = await store.getWorkflowById(ctx.tenantId, ids.workspaceId, ids.workflowId);\n  if (workflow === null) {\n    return err({\n      kind: 'NotFound',\n      message: `Workflow ${rawWorkflowId} not found.`,\n      resource: 'Workflow',\n    });\n  }\n\n  let parsed: WorkflowV1;\n  try {\n    parsed = parseWorkflowV1(workflow);\n  } catch (error) {\n    return err({\n      kind: 'DependencyFailure',\n      message: error instanceof Error ? error.message : 'Stored workflow is invalid.',\n    });\n  }\n\n  if (!parsed.active) {\n    return err({ kind: 'Conflict', message: `Workflow ${rawWorkflowId} is not active.` });\n  }\n  if (parsed.workspaceId !== ids.workspaceId) {\n    return err({\n      kind: 'Forbidden',\n      action: APP_ACTIONS.runStart,\n      message: 'Workspace mismatch for workflow reference.',\n    });\n  }\n  return ok(parsed);\n}\n\nfunction generateDepsValues(\n  idGenerator: IdGenerator,\n  clock: Clock,\n): Result<GeneratedValues, DependencyFailure> {\n  const runIdValue = idGenerator.generateId();\n  if (runIdValue.trim() === '') {\n    return err({ kind: 'DependencyFailure', message: 'Unable to generate run identifier.' });\n  }\n\n  const createdAtIso = clock.nowIso();\n  if (createdAtIso.trim() === '') {\n    return err({ kind: 'DependencyFailure', message: 'Clock returned an empty timestamp.' });\n  }\n\n  const eventIdValue = idGenerator.generateId();\n  if (eventIdValue.trim() === '') {\n    return err({ kind: 'DependencyFailure', message: 'Unable to generate event identifier.' });\n  }\n\n  return ok({ runIdValue, createdAtIso, eventIdValue });\n}\n\nfunction buildRun(\n  ctx: AppContext,\n  ids: ParsedIds,\n  workflow: WorkflowV1,\n  generated: GeneratedValues,\n): Result<RunV1, ValidationFailed> {\n  try {\n    return ok(\n      parseRunV1({\n        schemaVersion: 1,\n        runId: generated.runIdValue,\n        workspaceId: ids.workspaceId.toString(),\n        workflowId: ids.workflowId.toString(),\n        correlationId: ctx.correlationId.toString(),\n        executionTier: workflow.executionTier,\n        initiatedByUserId: ctx.principalId.toString(),\n        status: 'Pending',\n        createdAtIso: generated.createdAtIso,\n      }),\n    );\n  } catch (error) {\n    return err({\n      kind: 'ValidationFailed',\n      message: error instanceof Error ? error.message : 'Unable to construct run payload.',\n    });\n  }\n}\n\nasync function executeTransaction(\n  deps: StartWorkflowDeps,\n  ctx: AppContext,\n  plan: NewStartWorkflowPlan,\n): Promise<Result<StartWorkflowOutput, DependencyFailure>> {\n  const domainEvent: DomainEventV1 = {\n    schemaVersion: 1,\n    eventId: plan.generated.eventIdValue,\n    eventType: 'RunStarted',\n    aggregateKind: 'Run',\n    aggregateId: plan.run.runId,\n    occurredAtIso: plan.generated.createdAtIso,\n    workspaceId: ctx.tenantId,\n    correlationId: ctx.correlationId,\n    actorUserId: ctx.principalId,\n    payload: {\n      runId: plan.run.runId,\n      workflowId: plan.ids.workflowId.toString(),\n      workspaceId: plan.ids.workspaceId.toString(),\n    },\n  };\n\n  try {\n    return await deps.unitOfWork.execute(async () => {\n      await deps.runStore.saveRun(ctx.tenantId, plan.run);\n      await deps.orchestrator.startRun({\n        runId: plan.run.runId,\n        tenantId: ctx.tenantId,\n        workflowId: plan.ids.workflowId,\n        workflow: plan.workflow,\n        initiatedByUserId: ctx.principalId,\n        correlationId: ctx.correlationId,\n        ...(ctx.traceparent ? { traceparent: ctx.traceparent } : {}),\n        ...(ctx.tracestate ? { tracestate: ctx.tracestate } : {}),\n        executionTier: plan.workflow.executionTier,\n        idempotencyKey: plan.commandKey.requestKey,\n      });\n      await deps.eventPublisher.publish(\n        domainEventToPortariumCloudEvent(domainEvent, START_WORKFLOW_SOURCE),\n      );\n      const output: StartWorkflowOutput = { runId: plan.run.runId };\n      await deps.idempotency.set(plan.commandKey, output);\n      return ok(output);\n    });\n  } catch (error) {\n    const message =\n      error instanceof Error ? error.message : 'Workflow start failed due to a dependency failure.';\n    return err({ kind: 'DependencyFailure', message });\n  }\n}\n\ntype NewStartWorkflowPlan = Readonly<{\n  kind: 'new';\n  ids: ParsedIds;\n  workflow: WorkflowV1;\n  generated: GeneratedValues;\n  run: RunV1;\n  commandKey: IdempotencyKey;\n  trigger?: WorkflowTriggerV1;\n}>;\n\ntype CachedStartWorkflowPlan = Readonly<{\n  kind: 'cached';\n  output: StartWorkflowOutput;\n}>;\n\ntype StartWorkflowPlan = CachedStartWorkflowPlan | NewStartWorkflowPlan;\n\nasync function buildStartWorkflowPlan(\n  deps: StartWorkflowDeps,\n  ctx: AppContext,\n  input: StartWorkflowInput,\n): Promise<Result<StartWorkflowPlan, StartWorkflowError>> {\n  const keyCheck = requireNonEmpty(input.idempotencyKey, 'idempotencyKey');\n  if (!keyCheck.ok) return keyCheck;\n\n  const idsResult = validateInput(input);\n  if (!idsResult.ok) return idsResult;\n\n  const commandKey = {\n    tenantId: ctx.tenantId,\n    commandName: START_WORKFLOW_COMMAND,\n    requestKey: keyCheck.value,\n  };\n\n  const cached = await deps.idempotency.get<StartWorkflowOutput>(commandKey);\n  if (cached) {\n    return ok({ kind: 'cached', output: cached });\n  }\n\n  // Validate and parse trigger before doing expensive lookups\n  const triggerResult = parseTriggerFromInput(input.trigger, idsResult.value);\n  if (!triggerResult.ok) return triggerResult;\n\n  const workflowResult = await resolveWorkflow(\n    deps.workflowStore,\n    ctx,\n    idsResult.value,\n    input.workflowId,\n  );\n  if (!workflowResult.ok) return workflowResult;\n\n  const workflowVersions = await deps.workflowStore.listWorkflowsByName(\n    ctx.tenantId,\n    idsResult.value.workspaceId,\n    workflowResult.value.name,\n  );\n  const workflowVersionConflict = ensureSingleActiveWorkflowVersion({\n    workflowName: workflowResult.value.name,\n    selectedWorkflowId: workflowResult.value.workflowId,\n    workflowVersions,\n  });\n  if (workflowVersionConflict) return err(workflowVersionConflict);\n\n  const adapterRegistrations = await deps.adapterRegistrationStore.listByWorkspace(\n    ctx.tenantId,\n    idsResult.value.workspaceId,\n  );\n  const adapterConflict = ensureSingleActiveAdapterPerPort({\n    portFamilies: workflowResult.value.actions.map((action) => action.portFamily),\n    adapterRegistrations,\n  });\n  if (adapterConflict) return err(adapterConflict);\n\n  const genResult = generateDepsValues(deps.idGenerator, deps.clock);\n  if (!genResult.ok) return genResult;\n\n  const runResult = buildRun(ctx, idsResult.value, workflowResult.value, genResult.value);\n  if (!runResult.ok) return runResult;\n\n  const existingRun = await deps.runStore.getRunById(\n    ctx.tenantId,\n    idsResult.value.workspaceId,\n    runResult.value.runId,\n  );\n  const runConflict = ensureRunIdIsUnique(existingRun, runResult.value.runId);\n  if (runConflict) return err(runConflict);\n\n  return ok({\n    kind: 'new',\n    ids: idsResult.value,\n    workflow: workflowResult.value,\n    generated: genResult.value,\n    run: runResult.value,\n    commandKey,\n    ...(triggerResult.value !== undefined ? { trigger: triggerResult.value } : {}),\n  });\n}\n\nexport async function startWorkflow(\n  deps: StartWorkflowDeps,\n  ctx: AppContext,\n  input: StartWorkflowInput,\n): Promise<Result<StartWorkflowOutput, StartWorkflowError>> {\n  const authErr = await checkAuthorization(deps.authorization, ctx);\n  if (authErr) return authErr;\n\n  const planResult = await buildStartWorkflowPlan(deps, ctx, input);\n  if (!planResult.ok) return planResult;\n  const plan = planResult.value;\n\n  if (plan.kind === 'cached') {\n    return ok(plan.output);\n  }\n\n  const txResult = await executeTransaction(deps, ctx, plan);\n  if (!txResult.ok) return txResult;\n\n  // Route trigger if one was provided and a router is configured\n  if (plan.trigger && deps.triggerRouter) {\n    await deps.triggerRouter.routeAtWorkflowStart({\n      trigger: plan.trigger,\n      tenantId: ctx.tenantId,\n      runId: txResult.value.runId,\n      correlationId: ctx.correlationId,\n      payload: {\n        workflowId: plan.ids.workflowId.toString(),\n        workspaceId: plan.ids.workspaceId.toString(),\n      },\n    });\n  }\n\n  return txResult;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\submit-approval.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\submit-approval.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\submit-map-command-intent.audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\submit-map-command-intent.helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\submit-map-command-intent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\commands\\submit-map-command-intent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\actions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\command-observability.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\command-observability.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\errors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\jwt-claims-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\jwt-claims-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\query-validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\query-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\query.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\query.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\result.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\trace-context.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\trace-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\common\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\contracts\\application-command-query-contract.fixture.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\contracts\\application-command-query-contract.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\events\\cloudevent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\events\\cloudevent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\events\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\claims-to-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\rbac\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\rbac\\workspace-rbac-authorization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\rbac\\workspace-rbac.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\rbac\\workspace-rbac.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\workspace-actor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\iam\\workspace-actor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\integration\\agent-capability-drift-quarantine.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\integration\\register-workspace-flow.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\integration\\start-workflow-flow.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\middleware\\command-guardrails.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\middleware\\command-guardrails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\action-runner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\action-runner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\adapter-registration-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\ads-platforms-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\analytics-bi-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\approval-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\authentication.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\authorization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\clock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\comms-collaboration-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\compliance-grc-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\credential-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\credential-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\crm-sales-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\customer-support-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\documents-esign-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\event-publisher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\evidence-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\evidence-payload-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\finance-accounting-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\hris-hcm-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\human-task-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\iam-directory-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\id-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\idempotency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\itsm-it-ops-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\machine-invoker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\machine-invoker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\machine-registry-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\marketing-automation-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\mission-port.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\mission-port.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\monitoring-incident-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\outbox.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\payments-billing-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\payroll-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\policy-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\procurement-spend-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\projects-work-mgmt-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\run-resumer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\run-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\secrets-vaulting-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\unit-of-work.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\work-item-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\workflow-orchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\workflow-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\workforce-member-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\workforce-queue-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\ports\\workspace-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\bus.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\bus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-agent-work-items.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-agent-work-items.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async function 'getAgentWorkItems' has a complexity of 16. Maximum allowed is 10.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":44,"endColumn":40}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AgentId, WorkspaceId } from '../../domain/primitives/index.js';\nimport type { WorkItemV1 } from '../../domain/work-items/index.js';\nimport {\n  type AppContext,\n  type Forbidden,\n  type NotFound,\n  type ValidationFailed,\n  APP_ACTIONS,\n  err,\n  ok,\n  type Result,\n} from '../common/index.js';\nimport type {\n  AuthorizationPort,\n  MachineRegistryStore,\n  WorkItemListPage,\n  WorkItemStore,\n} from '../ports/index.js';\n\nexport type GetAgentWorkItemsInput = Readonly<{\n  workspaceId: string;\n  agentId: string;\n  status?: string;\n  limit?: number;\n  cursor?: string;\n}>;\n\nexport type GetAgentWorkItemsOutput = Readonly<{\n  agentId: string;\n  items: readonly WorkItemV1[];\n  nextCursor?: string;\n}>;\n\nexport type GetAgentWorkItemsError = Forbidden | NotFound | ValidationFailed;\n\nexport interface GetAgentWorkItemsDeps {\n  authorization: AuthorizationPort;\n  workItemStore: WorkItemStore;\n  machineRegistryStore: MachineRegistryStore;\n}\n\nconst VALID_STATUSES = ['Open', 'InProgress', 'Blocked', 'Resolved', 'Closed'] as const;\n\nexport async function getAgentWorkItems(\n  deps: GetAgentWorkItemsDeps,\n  ctx: AppContext,\n  input: GetAgentWorkItemsInput,\n): Promise<Result<GetAgentWorkItemsOutput, GetAgentWorkItemsError>> {\n  if (typeof input.workspaceId !== 'string' || input.workspaceId.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: 'workspaceId must be a non-empty string.' });\n  }\n  if (typeof input.agentId !== 'string' || input.agentId.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: 'agentId must be a non-empty string.' });\n  }\n  if (input.status !== undefined && !(VALID_STATUSES as readonly string[]).includes(input.status)) {\n    return err({ kind: 'ValidationFailed', message: 'status is invalid.' });\n  }\n  if (input.limit !== undefined && (!Number.isInteger(input.limit) || input.limit <= 0)) {\n    return err({ kind: 'ValidationFailed', message: 'limit must be a positive integer.' });\n  }\n\n  const allowed = await deps.authorization.isAllowed(ctx, APP_ACTIONS.workItemRead);\n  if (!allowed) {\n    return err({\n      kind: 'Forbidden',\n      action: APP_ACTIONS.workItemRead,\n      message: 'Caller is not permitted to read agent work items.',\n    });\n  }\n\n  const workspaceId = WorkspaceId(input.workspaceId);\n  const agentId = AgentId(input.agentId);\n\n  const agent = await deps.machineRegistryStore.getAgentConfigById(ctx.tenantId, agentId);\n  if (agent === null) {\n    return err({\n      kind: 'NotFound',\n      resource: 'AgentConfig',\n      message: `Agent ${input.agentId} not found.`,\n    });\n  }\n\n  const page: WorkItemListPage = await deps.workItemStore.listWorkItems(ctx.tenantId, workspaceId, {\n    ...(input.status ? { status: input.status as WorkItemV1['status'] } : {}),\n    ...(input.limit !== undefined ? { limit: input.limit } : {}),\n    ...(input.cursor ? { cursor: input.cursor } : {}),\n  });\n\n  return ok({\n    agentId: input.agentId,\n    items: page.items,\n    ...(page.nextCursor ? { nextCursor: page.nextCursor } : {}),\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-approval.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-approval.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-run.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-run.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-work-item.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-work-item.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-workspace.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\get-workspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-approvals.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-approvals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-runs.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-runs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-work-items.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-work-items.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async function 'listWorkItems' has a complexity of 21. Maximum allowed is 10.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":44,"endColumn":36},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 18 to the 15 allowed.","line":44,"column":23,"nodeType":null,"messageId":"refactorFunction","endLine":44,"endColumn":36}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ApprovalId,\n  EvidenceId,\n  RunId,\n  UserId,\n  WorkflowId,\n  WorkspaceId,\n} from '../../domain/primitives/index.js';\nimport type { WorkItemStatus } from '../../domain/work-items/index.js';\nimport {\n  type AppContext,\n  type Forbidden,\n  APP_ACTIONS,\n  type ValidationFailed,\n  err,\n  ok,\n  type Result,\n} from '../common/index.js';\nimport type { AuthorizationPort, ListWorkItemsFilter, WorkItemStore } from '../ports/index.js';\n\nexport type ListWorkItemsInput = Readonly<{\n  workspaceId: string;\n  status?: WorkItemStatus;\n  ownerUserId?: string;\n  runId?: string;\n  workflowId?: string;\n  approvalId?: string;\n  evidenceId?: string;\n  limit?: number;\n  cursor?: string;\n}>;\n\nexport type ListWorkItemsOutput = Awaited<ReturnType<WorkItemStore['listWorkItems']>>;\n\nexport type ListWorkItemsError = Forbidden | ValidationFailed;\n\nexport interface ListWorkItemsDeps {\n  authorization: AuthorizationPort;\n  workItemStore: WorkItemStore;\n}\n\nconst WORK_ITEM_STATUSES = ['Open', 'InProgress', 'Blocked', 'Resolved', 'Closed'] as const;\n\nexport async function listWorkItems(\n  deps: ListWorkItemsDeps,\n  ctx: AppContext,\n  input: ListWorkItemsInput,\n): Promise<Result<ListWorkItemsOutput, ListWorkItemsError>> {\n  const allowed = await deps.authorization.isAllowed(ctx, APP_ACTIONS.workItemRead);\n  if (!allowed) {\n    return err({\n      kind: 'Forbidden',\n      action: APP_ACTIONS.workItemRead,\n      message: 'Caller is not permitted to list work items.',\n    });\n  }\n\n  if (typeof input.workspaceId !== 'string' || input.workspaceId.trim() === '') {\n    return err({ kind: 'ValidationFailed', message: 'workspaceId must be a non-empty string.' });\n  }\n\n  if (input.limit !== undefined && (!Number.isInteger(input.limit) || input.limit <= 0)) {\n    return err({ kind: 'ValidationFailed', message: 'limit must be a positive integer.' });\n  }\n\n  if (input.status !== undefined && !WORK_ITEM_STATUSES.includes(input.status)) {\n    return err({ kind: 'ValidationFailed', message: 'status is invalid.' });\n  }\n\n  for (const [field, value] of [\n    ['ownerUserId', input.ownerUserId],\n    ['runId', input.runId],\n    ['workflowId', input.workflowId],\n    ['approvalId', input.approvalId],\n    ['evidenceId', input.evidenceId],\n  ] as const) {\n    if (value?.trim() === '') {\n      return err({ kind: 'ValidationFailed', message: `${field} must be a non-empty string.` });\n    }\n  }\n\n  try {\n    const workspaceId = WorkspaceId(input.workspaceId);\n    const filter: ListWorkItemsFilter = {\n      ...(input.status ? { status: input.status } : {}),\n      ...(input.ownerUserId ? { ownerUserId: UserId(input.ownerUserId) } : {}),\n      ...(input.runId ? { runId: RunId(input.runId) } : {}),\n      ...(input.workflowId ? { workflowId: WorkflowId(input.workflowId) } : {}),\n      ...(input.approvalId ? { approvalId: ApprovalId(input.approvalId) } : {}),\n      ...(input.evidenceId ? { evidenceId: EvidenceId(input.evidenceId) } : {}),\n      ...(input.limit !== undefined ? { limit: input.limit } : {}),\n      ...(input.cursor ? { cursor: input.cursor } : {}),\n    };\n    const page = await deps.workItemStore.listWorkItems(ctx.tenantId, workspaceId, filter);\n    return ok(page);\n  } catch {\n    return err({\n      kind: 'ValidationFailed',\n      message:\n        'Invalid query filter values. ownerUserId/runId/workflowId/approvalId/evidenceId must be valid identifiers.',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-workspaces.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\queries\\list-workspaces.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\outbox-dispatcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\outbox-dispatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\quota-aware-execution.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\quota-aware-execution.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async function 'invokeMachineWithQuotaRetryV1' has a complexity of 12. Maximum allowed is 10.","line":80,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":80,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { QuotaSemanticsV1 } from '../../domain/quota/quota-semantics-v1.js';\nimport type { MachineInvokerFailure, MachineInvokerResult } from '../ports/machine-invoker.js';\n\nexport type QuotaUsageSnapshotV1 = Readonly<{\n  minuteWindowStartedAtIso: string;\n  minuteCount: number;\n  dayWindowDateUtc: string;\n  dayCount: number;\n}>;\n\nexport type QuotaScheduleDecisionV1 =\n  | Readonly<{ kind: 'DispatchNow'; nextUsage: QuotaUsageSnapshotV1 }>\n  | Readonly<{\n      kind: 'Deferred';\n      reason: 'RateLimit' | 'DailyCap';\n      retryAtIso: string;\n      nextUsage: QuotaUsageSnapshotV1;\n    }>;\n\nexport function scheduleQuotaAwareDispatchV1(params: {\n  quota: QuotaSemanticsV1;\n  nowIso: string;\n  usage: QuotaUsageSnapshotV1;\n}): QuotaScheduleDecisionV1 {\n  const nowMs = Date.parse(params.nowIso);\n  const nowDate = new Date(nowMs);\n\n  const currentMinuteStartIso = toMinuteStartIso(nowDate);\n  const currentDayDateUtc = toUtcDate(nowDate);\n\n  const minuteCount =\n    params.usage.minuteWindowStartedAtIso === currentMinuteStartIso ? params.usage.minuteCount : 0;\n  const dayCount = params.usage.dayWindowDateUtc === currentDayDateUtc ? params.usage.dayCount : 0;\n\n  const nextUsageBase: QuotaUsageSnapshotV1 = {\n    minuteWindowStartedAtIso: currentMinuteStartIso,\n    minuteCount,\n    dayWindowDateUtc: currentDayDateUtc,\n    dayCount,\n  };\n\n  const rpm = params.quota.rateLimit?.requestsPerMinute;\n  if (rpm !== undefined && minuteCount >= rpm) {\n    return {\n      kind: 'Deferred',\n      reason: 'RateLimit',\n      retryAtIso: new Date(minuteStartMs(nowMs) + 60_000).toISOString(),\n      nextUsage: nextUsageBase,\n    };\n  }\n\n  const dailyCap = params.quota.dailyCap?.requestsPerDay;\n  if (dailyCap !== undefined && dayCount >= dailyCap) {\n    return {\n      kind: 'Deferred',\n      reason: 'DailyCap',\n      retryAtIso: computeNextDailyResetIso(params.nowIso, params.quota.dailyCap?.resetAtUtcHour),\n      nextUsage: nextUsageBase,\n    };\n  }\n\n  return {\n    kind: 'DispatchNow',\n    nextUsage: {\n      ...nextUsageBase,\n      minuteCount: minuteCount + 1,\n      dayCount: dayCount + 1,\n    },\n  };\n}\n\nexport type QuotaAwareInvokeResultV1 = Readonly<{\n  result: MachineInvokerResult;\n  attempts: number;\n  retryBudgetUsed: number;\n  retryBudgetRemaining: number;\n  backoffMsHistory: readonly number[];\n}>;\n\nexport async function invokeMachineWithQuotaRetryV1(params: {\n  invoke: () => Promise<MachineInvokerResult>;\n  maxRetries: number;\n  retryAfterMs?: (failure: MachineInvokerFailure) => number | undefined;\n  baseBackoffMs?: number;\n  maxBackoffMs?: number;\n  jitterRatio?: number;\n  random?: () => number;\n  sleep?: (ms: number) => Promise<void>;\n}): Promise<QuotaAwareInvokeResultV1> {\n  const baseBackoffMs = params.baseBackoffMs ?? 500;\n  const maxBackoffMs = params.maxBackoffMs ?? 60_000;\n  const jitterRatio = params.jitterRatio ?? 0.2;\n  const random = params.random ?? Math.random;\n  const sleep = params.sleep ?? defaultSleep;\n\n  const backoffMsHistory: number[] = [];\n  let retriesUsed = 0;\n  let attempts = 0;\n\n  for (;;) {\n    attempts += 1;\n    const result = await params.invoke();\n    if (result.ok || result.errorKind !== 'RateLimited') {\n      return {\n        result,\n        attempts,\n        retryBudgetUsed: retriesUsed,\n        retryBudgetRemaining: Math.max(0, params.maxRetries - retriesUsed),\n        backoffMsHistory,\n      };\n    }\n\n    if (retriesUsed >= params.maxRetries) {\n      return {\n        result,\n        attempts,\n        retryBudgetUsed: retriesUsed,\n        retryBudgetRemaining: 0,\n        backoffMsHistory,\n      };\n    }\n\n    const retryAfter = params.retryAfterMs?.(result);\n    const computedBackoff = computeExponentialBackoffMs({\n      retryIndex: retriesUsed,\n      baseBackoffMs,\n      maxBackoffMs,\n      jitterRatio,\n      random,\n    });\n    const delayMs = sanitizeDelayMs(retryAfter) ?? computedBackoff;\n    backoffMsHistory.push(delayMs);\n\n    retriesUsed += 1;\n    await sleep(delayMs);\n  }\n}\n\nfunction defaultSleep(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nfunction sanitizeDelayMs(value: number | undefined): number | undefined {\n  if (value === undefined) return undefined;\n  if (!Number.isFinite(value)) return undefined;\n  if (value <= 0) return undefined;\n  return Math.floor(value);\n}\n\nfunction computeExponentialBackoffMs(params: {\n  retryIndex: number;\n  baseBackoffMs: number;\n  maxBackoffMs: number;\n  jitterRatio: number;\n  random: () => number;\n}): number {\n  const withoutJitter = Math.min(\n    params.maxBackoffMs,\n    params.baseBackoffMs * 2 ** params.retryIndex,\n  );\n  const jitter = (params.random() * 2 - 1) * params.jitterRatio;\n  const withJitter = Math.round(withoutJitter * (1 + jitter));\n  return Math.max(1, withJitter);\n}\n\nfunction minuteStartMs(nowMs: number): number {\n  return nowMs - (nowMs % 60_000);\n}\n\nfunction toMinuteStartIso(value: Date): string {\n  return new Date(minuteStartMs(value.getTime())).toISOString();\n}\n\nfunction toUtcDate(value: Date): string {\n  const year = value.getUTCFullYear();\n  const month = String(value.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(value.getUTCDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\nfunction computeNextDailyResetIso(nowIso: string, resetAtUtcHour: number | undefined): string {\n  const now = new Date(Date.parse(nowIso));\n  const resetHour = resetAtUtcHour ?? 0;\n\n  const nextReset = new Date(\n    Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), resetHour, 0, 0, 0),\n  );\n\n  if (nextReset.getTime() <= now.getTime()) {\n    nextReset.setUTCDate(nextReset.getUTCDate() + 1);\n  }\n\n  return nextReset.toISOString();\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\repository-aggregate-invariants.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\repository-aggregate-invariants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\trigger-execution-router.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\application\\services\\trigger-execution-router.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\commands\\agent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\commands\\approve.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\commands\\events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\commands\\login.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\commands\\run.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\commands\\workspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\portarium-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\cli\\portarium-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\adapters\\adapter-registration-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\adapters\\adapter-registration-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\adapters\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\approvals\\approval-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\approvals\\approval-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\approvals\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\account-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\account-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\asset-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\asset-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\campaign-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\campaign-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\consent-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\consent-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\document-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\document-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\external-object-ref.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\external-object-ref.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\invoice-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\invoice-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\opportunity-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\opportunity-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\order-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\order-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\party-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\party-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\payment-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\payment-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\privacy-policy-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\privacy-policy-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\product-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\product-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\subscription-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\subscription-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\task-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\task-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\ticket-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\canonical\\ticket-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\credentials\\credential-grant-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\credentials\\credential-grant-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\credentials\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\deployment\\definition-truth-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\deployment\\definition-truth-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\deployment\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\agent-events-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\agent-events-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\cloudevents-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\cloudevents-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\robot-events-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\event-stream\\robot-events-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\events\\domain-events-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\events\\domain-events-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\events\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\canonical-json.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\canonical-json.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-chain-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-chain-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-entry-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-entry-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-hasher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-hasher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-privacy-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\evidence-privacy-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\retention-schedule-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\evidence\\retention-schedule-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\location\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\location\\location-event-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\location\\location-event-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\location\\map-layer-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\location\\map-layer-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\capability-drift-quarantine-policy-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\capability-drift-quarantine-policy-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\capability-handshake-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\capability-handshake-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\machine-registration-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\machine-registration-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\openclaw-tool-blast-radius-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\openclaw-tool-blast-radius-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\robot-intent-command-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\machines\\robot-intent-command-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\core-extension-points.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\core-extension-points.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-compliance-profile-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-compliance-profile-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-connector-mapping-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-connector-mapping-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-enablement-compliance-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-enablement-compliance-v1.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Function 'deny' has too many parameters (6). Maximum allowed is 4.","line":124,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":124,"endColumn":14},{"ruleId":"max-params","severity":2,"message":"Function 'buildAudit' has too many parameters (5). Maximum allowed is 4.","line":145,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":145,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { PackId as PackIdType } from '../primitives/index.js';\nimport type { PackManifestV1 } from './pack-manifest.js';\nimport type { PackComplianceProfileV1 } from './pack-compliance-profile-v1.js';\n\nexport type PackEnablementComplianceReasonV1 =\n  | 'MissingComplianceAssetDeclaration'\n  | 'MissingParsedComplianceProfile'\n  | 'UndeclaredComplianceAsset'\n  | 'PackIdMismatch'\n  | 'MissingRequiredComplianceProfile';\n\nexport type PackEnablementComplianceAuditV1 = Readonly<{\n  packId: PackIdType;\n  declaredComplianceAssets: readonly string[];\n  validatedProfileIds: readonly string[];\n  requiredProfileIds: readonly string[];\n  missingRequiredProfileIds: readonly string[];\n}>;\n\nexport type PackEnablementComplianceAllowedV1 = Readonly<{\n  allowed: true;\n  audit: PackEnablementComplianceAuditV1;\n}>;\n\nexport type PackEnablementComplianceDeniedV1 = Readonly<{\n  allowed: false;\n  reason: PackEnablementComplianceReasonV1;\n  audit: PackEnablementComplianceAuditV1;\n}>;\n\nexport type PackEnablementComplianceDecisionV1 =\n  | PackEnablementComplianceAllowedV1\n  | PackEnablementComplianceDeniedV1;\n\nexport type EvaluatePackEnablementComplianceInputV1 = Readonly<{\n  manifest: PackManifestV1;\n  parsedProfilesByAsset: Readonly<Record<string, PackComplianceProfileV1>>;\n  requiredProfileIds: readonly string[];\n}>;\n\nexport function evaluatePackEnablementComplianceV1(\n  input: EvaluatePackEnablementComplianceInputV1,\n): PackEnablementComplianceDecisionV1 {\n  const declaredComplianceAssets = [...(input.manifest.assets.complianceProfiles ?? [])];\n  const declaredAssetSet = new Set(declaredComplianceAssets);\n  const parsedEntries = Object.entries(input.parsedProfilesByAsset);\n  const requiredProfileIds = toSortedUnique(input.requiredProfileIds);\n\n  if (requiredProfileIds.length > 0 && declaredComplianceAssets.length === 0) {\n    return deny(\n      'MissingComplianceAssetDeclaration',\n      input.manifest.id,\n      declaredComplianceAssets,\n      [],\n      requiredProfileIds,\n    );\n  }\n\n  for (const [assetPath] of parsedEntries) {\n    if (!declaredAssetSet.has(assetPath)) {\n      return deny(\n        'UndeclaredComplianceAsset',\n        input.manifest.id,\n        declaredComplianceAssets,\n        [],\n        requiredProfileIds,\n      );\n    }\n  }\n\n  const validatedProfileIds: string[] = [];\n  for (const declaredAsset of declaredComplianceAssets) {\n    const profile = input.parsedProfilesByAsset[declaredAsset];\n    if (profile === undefined) {\n      return deny(\n        'MissingParsedComplianceProfile',\n        input.manifest.id,\n        declaredComplianceAssets,\n        validatedProfileIds,\n        requiredProfileIds,\n      );\n    }\n\n    if (profile.packId !== input.manifest.id) {\n      return deny(\n        'PackIdMismatch',\n        input.manifest.id,\n        declaredComplianceAssets,\n        validatedProfileIds,\n        requiredProfileIds,\n      );\n    }\n\n    validatedProfileIds.push(String(profile.profileId));\n  }\n\n  const uniqueValidatedProfileIds = toSortedUnique(validatedProfileIds);\n  const missingRequiredProfileIds = requiredProfileIds.filter(\n    (requiredId) => !uniqueValidatedProfileIds.includes(requiredId),\n  );\n  if (missingRequiredProfileIds.length > 0) {\n    return deny(\n      'MissingRequiredComplianceProfile',\n      input.manifest.id,\n      declaredComplianceAssets,\n      uniqueValidatedProfileIds,\n      requiredProfileIds,\n      missingRequiredProfileIds,\n    );\n  }\n\n  return {\n    allowed: true,\n    audit: buildAudit(\n      input.manifest.id,\n      declaredComplianceAssets,\n      uniqueValidatedProfileIds,\n      requiredProfileIds,\n      [],\n    ),\n  };\n}\n\nfunction deny(\n  reason: PackEnablementComplianceReasonV1,\n  packId: PackIdType,\n  declaredComplianceAssets: readonly string[],\n  validatedProfileIds: readonly string[],\n  requiredProfileIds: readonly string[],\n  missingRequiredProfileIds: readonly string[] = [],\n): PackEnablementComplianceDeniedV1 {\n  return {\n    allowed: false,\n    reason,\n    audit: buildAudit(\n      packId,\n      declaredComplianceAssets,\n      validatedProfileIds,\n      requiredProfileIds,\n      missingRequiredProfileIds,\n    ),\n  };\n}\n\nfunction buildAudit(\n  packId: PackIdType,\n  declaredComplianceAssets: readonly string[],\n  validatedProfileIds: readonly string[],\n  requiredProfileIds: readonly string[],\n  missingRequiredProfileIds: readonly string[],\n): PackEnablementComplianceAuditV1 {\n  return {\n    packId,\n    declaredComplianceAssets: [...declaredComplianceAssets],\n    validatedProfileIds: [...validatedProfileIds],\n    requiredProfileIds: [...requiredProfileIds],\n    missingRequiredProfileIds: [...missingRequiredProfileIds],\n  };\n}\n\nfunction toSortedUnique(values: readonly string[]): readonly string[] {\n  return [...new Set(values)].sort((left, right) => left.localeCompare(right));\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-manifest.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-manifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-registry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-resolver.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-resolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-schema-extension-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-schema-extension-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-test-asset-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-test-asset-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-ui-template-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-ui-template-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-workflow-definition-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\pack-workflow-definition-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\packs\\software-change-management-reference-pack.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\plan\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\plan\\plan-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\plan\\plan-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\execution-tier-policy-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\execution-tier-policy-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-condition-dsl-v1.evaluator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-condition-dsl-v1.parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-condition-dsl-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-condition-dsl-v1.tokenizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-condition-dsl-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-condition-dsl-v1.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-rule-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-rule-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\policy-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\sod-constraints-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\sod-constraints-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\tool-exposure-policy-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\policy\\tool-exposure-policy-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\ports\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\ports\\port-family-capabilities-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\ports\\port-family-capabilities-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\ports\\port-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\ports\\port-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\primitives\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\primitives\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\quota\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\quota\\quota-semantics-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\quota\\quota-semantics-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\mission-action-semantics-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\mission-action-semantics-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\mission-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\mission-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\robot-fleet-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\robot-fleet-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\safety-constraint-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\robots\\safety-constraint-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\runs\\artifact-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\runs\\artifact-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\runs\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\runs\\run-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\runs\\run-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\schedule\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\schedule\\workflow-trigger-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\schedule\\workflow-trigger-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\approval-routing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\approval-routing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\capability-enforcement.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\capability-enforcement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\diff.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\diff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\planning.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\planning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\policy-evaluation.inline-rules.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\policy-evaluation.robot-context.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\policy-evaluation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\policy-evaluation.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Function 'evaluateInlineRules' has a complexity of 11. Maximum allowed is 10.","line":218,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":218,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { PolicyV1 } from '../policy/policy-v1.js';\nimport type {\n  PerformedDutyV1,\n  RobotSodContextV1,\n  SodEvaluationContextV1,\n  SodViolationV1,\n} from '../policy/sod-constraints-v1.js';\nimport { evaluateSodConstraintsV1 } from '../policy/sod-constraints-v1.js';\nimport { evaluatePolicyConditionDslV1 } from '../policy/policy-condition-dsl-v1.js';\nimport type { PolicyId as PolicyIdType, UserId as UserIdType } from '../primitives/index.js';\nimport {\n  evaluateSafetyPolicyContext,\n  type HazardClassificationV1,\n  type SafetyPolicyContextV1,\n  type SafetyTierRecommendation,\n} from './policy-safety-evaluation.js';\n\nexport type PolicyEvaluationContextV1 = Readonly<{\n  initiatorUserId: UserIdType;\n  approverUserIds: readonly UserIdType[];\n  performedDuties?: readonly PerformedDutyV1[];\n  robotContext?: RobotSodContextV1;\n  ruleContext?: Readonly<Record<string, unknown>>;\n  ruleEvaluationMaxOperations?: number;\n}> &\n  SafetyPolicyContextV1;\n\nexport type PolicyDecisionV1 = 'Allow' | 'RequireApproval' | 'Deny';\n\nexport type PolicyEvaluationResultV1 = Readonly<{\n  decision: PolicyDecisionV1;\n  violations: readonly SodViolationV1[];\n  evaluatedPolicyIds: readonly PolicyIdType[];\n  safetyTierRecommendation?: SafetyTierRecommendation;\n  hazardClassifications?: readonly HazardClassificationV1[];\n  inlineRuleErrors?: readonly string[];\n}>;\n\nexport type PolicyEvaluationEvidenceV1 = Readonly<{\n  decision: PolicyDecisionV1;\n  evaluatedPolicyIds: readonly PolicyIdType[];\n  violationKinds: readonly SodViolationV1['kind'][];\n  safetyTierRecommendation?: SafetyTierRecommendation;\n  hazardClassifications?: readonly HazardClassificationV1[];\n}>;\n\nconst DECISION_SEVERITY: Record<PolicyDecisionV1, number> = {\n  Allow: 0,\n  RequireApproval: 1,\n  Deny: 2,\n};\n\nexport function evaluatePolicy(params: {\n  policy: PolicyV1;\n  context: PolicyEvaluationContextV1;\n}): PolicyEvaluationResultV1 {\n  const { policy, context } = params;\n  const safety = evaluateSafetyPolicyContext(context);\n  const evaluatedPolicyIds = [policy.policyId] as const;\n\n  // --- Inline rule evaluation ---\n  const inlineResult = evaluateInlineRules(policy, context);\n  if (inlineResult.errors.length > 0) {\n    // Fail closed: any parse/timeout error  Deny\n    return {\n      decision: 'Deny',\n      violations: [],\n      evaluatedPolicyIds,\n      inlineRuleErrors: inlineResult.errors,\n    };\n  }\n  if (inlineResult.decision !== null) {\n    return buildPolicyResult({\n      baseDecision: inlineResult.decision,\n      violations: [],\n      evaluatedPolicyIds,\n      safety,\n    });\n  }\n\n  // --- SoD constraint evaluation ---\n  if (!policy.sodConstraints || policy.sodConstraints.length === 0) {\n    return buildPolicyResult({\n      baseDecision: 'Allow',\n      violations: [],\n      evaluatedPolicyIds,\n      safety,\n    });\n  }\n\n  const sodContext: SodEvaluationContextV1 = {\n    initiatorUserId: context.initiatorUserId,\n    approverUserIds: context.approverUserIds,\n    ...(context.performedDuties ? { performedDuties: context.performedDuties } : {}),\n    ...(context.robotContext ? { robotContext: context.robotContext } : {}),\n  };\n\n  const violations = evaluateSodConstraintsV1({\n    constraints: policy.sodConstraints,\n    context: sodContext,\n  });\n\n  return buildPolicyResult({\n    baseDecision: decisionFromViolations(violations),\n    violations,\n    evaluatedPolicyIds,\n    safety,\n  });\n}\n\nexport function evaluatePolicies(params: {\n  policies: readonly PolicyV1[];\n  context: PolicyEvaluationContextV1;\n}): PolicyEvaluationResultV1 {\n  const { policies, context } = params;\n  const safety = evaluateSafetyPolicyContext(context);\n\n  if (policies.length === 0) {\n    return buildPolicyResult({\n      baseDecision: 'Allow',\n      violations: [],\n      evaluatedPolicyIds: [],\n      safety,\n    });\n  }\n\n  const allViolations: SodViolationV1[] = [];\n  const allPolicyIds: PolicyIdType[] = [];\n  const allInlineErrors: string[] = [];\n  let strongestPolicyDecision: PolicyDecisionV1 = 'Allow';\n\n  for (const policy of policies) {\n    const result = evaluatePolicy({ policy, context });\n    allViolations.push(...result.violations);\n    allPolicyIds.push(...result.evaluatedPolicyIds);\n    if (result.inlineRuleErrors) {\n      allInlineErrors.push(...result.inlineRuleErrors);\n    }\n    if (DECISION_SEVERITY[result.decision] > DECISION_SEVERITY[strongestPolicyDecision]) {\n      strongestPolicyDecision = result.decision;\n    }\n  }\n\n  // Fail closed: if any policy had inline rule errors, propagate Deny\n  if (allInlineErrors.length > 0) {\n    return {\n      decision: 'Deny',\n      violations: allViolations,\n      evaluatedPolicyIds: allPolicyIds,\n      inlineRuleErrors: allInlineErrors,\n    };\n  }\n\n  const sodBaseDecision = decisionFromViolations(allViolations);\n  const baseDecision =\n    DECISION_SEVERITY[strongestPolicyDecision] > DECISION_SEVERITY[sodBaseDecision]\n      ? strongestPolicyDecision\n      : sodBaseDecision;\n\n  return buildPolicyResult({\n    baseDecision,\n    violations: allViolations,\n    evaluatedPolicyIds: allPolicyIds,\n    safety,\n  });\n}\n\nexport function toPolicyEvaluationEvidenceV1(\n  result: PolicyEvaluationResultV1,\n): PolicyEvaluationEvidenceV1 {\n  return {\n    decision: result.decision,\n    evaluatedPolicyIds: result.evaluatedPolicyIds,\n    violationKinds: result.violations.map((violation) => violation.kind),\n    ...(result.safetyTierRecommendation\n      ? { safetyTierRecommendation: result.safetyTierRecommendation }\n      : {}),\n    ...(result.hazardClassifications\n      ? { hazardClassifications: result.hazardClassifications }\n      : {}),\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Inline rule evaluation helpers\n// ---------------------------------------------------------------------------\n\ntype InlineRuleEvalResult = Readonly<{\n  decision: PolicyDecisionV1 | null;\n  errors: readonly string[];\n}>;\n\n/**\n * Builds the flattened context object passed to the inline rule expression\n * evaluator. The context exposes:\n *   - every top-level scalar field of PolicyEvaluationContextV1\n *   - every key from ruleContext (merged at the top level)\n *   - a `run` object with `tier` aliased to `executionTier`\n */\nfunction buildRuleEvaluationContext(\n  context: PolicyEvaluationContextV1,\n): Readonly<Record<string, unknown>> {\n  const base: Record<string, unknown> = {\n    executionTier: context.executionTier,\n    actionOperation: context.actionOperation ?? null,\n    run: { tier: context.executionTier },\n  };\n\n  if (context.ruleContext) {\n    for (const [key, value] of Object.entries(context.ruleContext)) {\n      base[key] = value;\n    }\n  }\n\n  return base;\n}\n\nfunction evaluateInlineRules(\n  policy: PolicyV1,\n  context: PolicyEvaluationContextV1,\n): InlineRuleEvalResult {\n  if (!policy.rules || policy.rules.length === 0) {\n    return { decision: null, errors: [] };\n  }\n\n  const evalCtx = buildRuleEvaluationContext(context);\n  const maxOps = context.ruleEvaluationMaxOperations ?? 1000;\n  const errors: string[] = [];\n  let strongestDecision: PolicyDecisionV1 | null = null;\n\n  for (const rule of policy.rules) {\n    const evalResult = evaluatePolicyConditionDslV1({\n      condition: rule.condition,\n      context: evalCtx,\n      maxOperations: maxOps,\n    });\n\n    if (!evalResult.ok) {\n      errors.push(evalResult.message);\n      continue;\n    }\n\n    if (evalResult.value) {\n      const ruleDecision: PolicyDecisionV1 = rule.effect === 'Deny' ? 'Deny' : 'Allow';\n      if (\n        strongestDecision === null ||\n        DECISION_SEVERITY[ruleDecision] > DECISION_SEVERITY[strongestDecision]\n      ) {\n        strongestDecision = ruleDecision;\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    return { decision: null, errors };\n  }\n\n  return { decision: strongestDecision, errors: [] };\n}\n\n// ---------------------------------------------------------------------------\n// SoD helpers\n// ---------------------------------------------------------------------------\n\nfunction decisionFromViolations(violations: readonly SodViolationV1[]): PolicyDecisionV1 {\n  let worst: PolicyDecisionV1 = 'Allow';\n  for (const violation of violations) {\n    const decision = violationToDecision(violation);\n    if (DECISION_SEVERITY[decision] > DECISION_SEVERITY[worst]) {\n      worst = decision;\n    }\n  }\n  return worst;\n}\n\nfunction violationToDecision(violation: SodViolationV1): PolicyDecisionV1 {\n  switch (violation.kind) {\n    case 'IncompatibleDutiesViolation':\n      return 'Deny';\n    case 'MakerCheckerViolation':\n    case 'DistinctApproversViolation':\n    case 'HazardousZoneNoSelfApprovalViolation':\n    case 'SafetyClassifiedZoneDualApprovalViolation':\n    case 'RemoteEstopRequesterSeparationViolation':\n      return 'RequireApproval';\n  }\n}\n\nfunction mergeDecision(a: PolicyDecisionV1, b: PolicyDecisionV1): PolicyDecisionV1 {\n  return DECISION_SEVERITY[a] >= DECISION_SEVERITY[b] ? a : b;\n}\n\nfunction buildPolicyResult(input: {\n  baseDecision: PolicyDecisionV1;\n  violations: readonly SodViolationV1[];\n  evaluatedPolicyIds: readonly PolicyIdType[];\n  safety: ReturnType<typeof evaluateSafetyPolicyContext>;\n}): PolicyEvaluationResultV1 {\n  return {\n    decision: mergeDecision(input.baseDecision, input.safety.decision),\n    violations: input.violations,\n    evaluatedPolicyIds: input.evaluatedPolicyIds,\n    ...(input.safety.recommendation\n      ? { safetyTierRecommendation: input.safety.recommendation }\n      : {}),\n    ...(input.safety.hazardClassifications.length > 0\n      ? { hazardClassifications: input.safety.hazardClassifications }\n      : {}),\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\policy-safety-evaluation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\policy-sod-fault-injection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\provider-selection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\provider-selection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\run-status-transitions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\run-status-transitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\workforce-routing-policy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\services\\workforce-routing-policy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\tenancy\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\tenancy\\tenant-config-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\tenancy\\tenant-config-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\testing\\canonical-seeds-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\testing\\canonical-seeds-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\testing\\synthetic-evidence-retention-fixtures-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\testing\\tenant-isolated-aggregate-fixtures-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\testing\\tenant-isolated-aggregate-fixtures-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\users\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\users\\workspace-user-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\users\\workspace-user-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\validation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\validation\\parse-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\validation\\parse-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\versioning\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\versioning\\semver-range.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\versioning\\semver-range.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\versioning\\semver.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\versioning\\semver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\work-items\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\work-items\\work-item-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\work-items\\work-item-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workflows\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workflows\\workflow-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workflows\\workflow-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\human-task-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\human-task-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\workforce-member-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\workforce-member-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\workforce-queue-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workforce\\workforce-queue-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workspaces\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workspaces\\project-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workspaces\\project-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workspaces\\workspace-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\domain\\workspaces\\workspace-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\activepieces\\activepieces-action-executor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\activepieces\\activepieces-action-executor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\activepieces\\activepieces-piece-package-pattern.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\activepieces\\activepieces-piece-package-pattern.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\ads-platforms\\in-memory-ads-platforms-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\ads-platforms\\in-memory-ads-platforms-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\ads-platforms\\in-memory-ads-platforms-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\analytics-bi\\in-memory-analytics-bi-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\analytics-bi\\in-memory-analytics-bi-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\analytics-bi\\in-memory-analytics-bi-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\comms-collaboration\\in-memory-comms-collaboration-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\comms-collaboration\\in-memory-comms-collaboration-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\comms-collaboration\\in-memory-comms-collaboration-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\compliance-grc\\in-memory-compliance-grc-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\compliance-grc\\in-memory-compliance-grc-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\compliance-grc\\in-memory-compliance-grc-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\crm-sales\\in-memory-crm-sales-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\crm-sales\\in-memory-crm-sales-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\crm-sales\\in-memory-crm-sales-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\customer-support\\in-memory-customer-support-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\customer-support\\in-memory-customer-support-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\customer-support\\in-memory-customer-support-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\documents-esign\\in-memory-documents-esign-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\documents-esign\\in-memory-documents-esign-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\documents-esign\\in-memory-documents-esign-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\finance-accounting\\in-memory-finance-accounting-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\finance-accounting\\in-memory-finance-accounting-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\finance-accounting\\in-memory-finance-accounting-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\hris-hcm\\in-memory-hris-hcm-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\hris-hcm\\in-memory-hris-hcm-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\hris-hcm\\in-memory-hris-hcm-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\iam-directory\\in-memory-iam-directory-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\iam-directory\\in-memory-iam-directory-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\iam-directory\\in-memory-iam-directory-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\itsm-it-ops\\in-memory-itsm-it-ops-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\itsm-it-ops\\in-memory-itsm-it-ops-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\itsm-it-ops\\in-memory-itsm-it-ops-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\marketing-automation\\in-memory-marketing-automation-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\marketing-automation\\in-memory-marketing-automation-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\marketing-automation\\in-memory-marketing-automation-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\monitoring-incident\\in-memory-monitoring-incident-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\monitoring-incident\\in-memory-monitoring-incident-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\monitoring-incident\\in-memory-monitoring-incident-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\payments-billing\\in-memory-payments-billing-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\payments-billing\\in-memory-payments-billing-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\payments-billing\\in-memory-payments-billing-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\payroll\\in-memory-payroll-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\payroll\\in-memory-payroll-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\payroll\\in-memory-payroll-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\procurement-spend\\in-memory-procurement-spend-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\procurement-spend\\in-memory-procurement-spend-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\procurement-spend\\in-memory-procurement-spend-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\projects-work-mgmt\\in-memory-projects-work-mgmt-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\projects-work-mgmt\\in-memory-projects-work-mgmt-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\projects-work-mgmt\\in-memory-projects-work-mgmt-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\secrets-vaulting\\in-memory-secrets-vaulting-adapter.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\secrets-vaulting\\in-memory-secrets-vaulting-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\adapters\\secrets-vaulting\\in-memory-secrets-vaulting-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\jose-jwt-authentication.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\jose-jwt-authentication.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\jwt-claim-schema-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\jwt-claim-schema-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\openfga-agent-machine-model.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\openfga-agent-machine-model.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\openfga-authorization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\openfga-authorization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\openfga-resource-authorization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\auth\\openfga-resource-authorization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\beads\\bd-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\beads\\evaluate-stop-loss-thresholds.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\beads\\generate-bead-acceptance-scorecard.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\beads\\generate-bead-metadata-audit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\beads\\generate-weekly-pe-audit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\crypto\\node-crypto-evidence-hasher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\crypto\\node-crypto-evidence-hasher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\domain-atlas\\domain-atlas-artifacts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\domain-atlas\\operation-contract-stubs.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\emulator\\run-emulator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\emulator\\run-emulator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\activepieces-domain-event-trigger-publisher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\activepieces-domain-event-trigger-publisher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\nats-event-publisher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\nats-event-publisher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\outbox-dispatcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\outbox-dispatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\postgres-outbox-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\eventing\\postgres-outbox-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\agent-action-evidence-hooks.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\agent-action-evidence-hooks.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Function 'parseAgentActionEvidencePayload' has a complexity of 12. Maximum allowed is 10.","line":146,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":146,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from 'node:crypto';\n\nimport { createPortariumCloudEvent } from '../../application/events/cloudevent.js';\nimport type {\n  EvidenceLogPort,\n  EvidencePayloadStorePort,\n  EventPublisher,\n} from '../../application/ports/index.js';\nimport {\n  AGENT_CLOUD_EVENT_SOURCE,\n  AGENT_CLOUD_EVENT_TYPES,\n} from '../../domain/event-stream/agent-events-v1.js';\nimport type { DomainEventV1 } from '../../domain/events/domain-events-v1.js';\nimport {\n  ActionId,\n  CorrelationId,\n  EvidenceId,\n  RunId,\n  TenantId,\n  UserId,\n  WorkspaceId,\n} from '../../domain/primitives/index.js';\n\ntype SupportedAgentActionEventType = 'ActionDispatched' | 'ActionCompleted' | 'ActionFailed';\n\ntype AgentActionEvidencePayload = Readonly<{\n  eventType: SupportedAgentActionEventType;\n  runId: string;\n  actionId: string;\n  machineId?: string;\n  agentId?: string;\n  toolName?: string;\n  status?: string;\n  errorMessage?: string;\n  timestamp: string;\n}>;\n\nexport interface AgentActionEvidenceHooksDeps {\n  evidenceLog: EvidenceLogPort;\n  payloadStore: EvidencePayloadStorePort;\n  eventPublisher: EventPublisher;\n  payloadBucket?: string;\n  retentionDays?: number;\n}\n\nconst DEFAULT_PAYLOAD_BUCKET = 'evidence';\nconst DEFAULT_RETENTION_DAYS = 365;\n\nexport class AgentActionEvidenceHooks {\n  readonly #deps: AgentActionEvidenceHooksDeps;\n\n  public constructor(deps: AgentActionEvidenceHooksDeps) {\n    this.#deps = deps;\n  }\n\n  public async record(event: DomainEventV1): Promise<void> {\n    const eventType = event.eventType;\n    if (!isSupportedEvent(eventType)) return;\n\n    const payload = parseAgentActionEvidencePayload(event, eventType);\n    const location = {\n      bucket: this.#deps.payloadBucket ?? DEFAULT_PAYLOAD_BUCKET,\n      key: buildPayloadKey(event.workspaceId, payload.runId, payload.actionId, event.eventId),\n    };\n    const bytes = new TextEncoder().encode(JSON.stringify(payload));\n    await this.#deps.payloadStore.put({ location, bytes });\n\n    const retentionDays = this.#deps.retentionDays ?? DEFAULT_RETENTION_DAYS;\n    const retainUntilIso = new Date(\n      Date.parse(event.occurredAtIso) + retentionDays * 86_400_000,\n    ).toISOString();\n    await this.#deps.payloadStore.applyWormControls({\n      location,\n      retentionSchedule: {\n        retentionClass: 'Compliance',\n        retainUntilIso,\n      },\n    });\n\n    const evidenceId = EvidenceId(`evi-${randomUUID()}`);\n    await this.#deps.evidenceLog.appendEntry(TenantId(event.workspaceId), {\n      schemaVersion: 1,\n      evidenceId,\n      workspaceId: WorkspaceId(event.workspaceId),\n      correlationId: CorrelationId(event.correlationId),\n      occurredAtIso: event.occurredAtIso,\n      category: 'Action',\n      summary: `${eventType} evidence for action ${payload.actionId}.`,\n      actor: event.actorUserId\n        ? { kind: 'User', userId: UserId(event.actorUserId) }\n        : { kind: 'System' },\n      links: {\n        runId: RunId(payload.runId),\n      },\n      payloadRefs: [\n        {\n          kind: 'Snapshot',\n          uri: `evidence://${location.bucket}/${location.key}`,\n          contentType: 'application/json',\n        },\n      ],\n    });\n\n    await this.#deps.eventPublisher.publish(\n      createPortariumCloudEvent({\n        source: AGENT_CLOUD_EVENT_SOURCE,\n        eventType: eventTypeToCloudEventType(eventType),\n        eventId: event.eventId,\n        tenantId: event.workspaceId,\n        correlationId: event.correlationId,\n        subject: `runs/${payload.runId}/actions/${payload.actionId}`,\n        occurredAtIso: event.occurredAtIso,\n        runId: RunId(payload.runId),\n        actionId: ActionId(payload.actionId),\n        data: payload,\n      }),\n    );\n  }\n}\n\nfunction isSupportedEvent(\n  eventType: DomainEventV1['eventType'],\n): eventType is SupportedAgentActionEventType {\n  return (\n    eventType === 'ActionDispatched' ||\n    eventType === 'ActionCompleted' ||\n    eventType === 'ActionFailed'\n  );\n}\n\nfunction eventTypeToCloudEventType(\n  eventType: SupportedAgentActionEventType,\n): (typeof AGENT_CLOUD_EVENT_TYPES)[SupportedAgentActionEventType] {\n  return AGENT_CLOUD_EVENT_TYPES[eventType];\n}\n\nfunction buildPayloadKey(\n  workspaceId: string,\n  runId: string,\n  actionId: string,\n  eventId: string,\n): string {\n  return `workspaces/${encodeURIComponent(workspaceId)}/runs/${encodeURIComponent(runId)}/agent-actions/${encodeURIComponent(actionId)}/${encodeURIComponent(eventId)}.json`;\n}\n\nfunction parseAgentActionEvidencePayload(\n  event: DomainEventV1,\n  eventType: SupportedAgentActionEventType,\n): AgentActionEvidencePayload {\n  const payload = isRecord(event.payload) ? event.payload : {};\n  const runId = asNonEmptyString(payload['runId']) ?? event.aggregateId;\n  const actionId = asNonEmptyString(payload['actionId']) ?? asNonEmptyString(payload['stepId']);\n  if (!runId || !actionId) {\n    throw new Error(`Agent action payload missing required runId/actionId for ${event.eventType}.`);\n  }\n\n  const machineId = asNonEmptyString(payload['machineId']);\n  const agentId = asNonEmptyString(payload['agentId']);\n  const toolName = asNonEmptyString(payload['toolName']);\n  const status = asNonEmptyString(payload['status']);\n  const errorMessage =\n    asNonEmptyString(payload['errorMessage']) ?? asNonEmptyString(payload['error']);\n\n  return {\n    eventType,\n    runId,\n    actionId,\n    ...(machineId ? { machineId } : {}),\n    ...(agentId ? { agentId } : {}),\n    ...(toolName ? { toolName } : {}),\n    ...(status ? { status } : {}),\n    ...(errorMessage ? { errorMessage } : {}),\n    timestamp: event.occurredAtIso,\n  };\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction asNonEmptyString(value: unknown): string | undefined {\n  if (typeof value !== 'string') return undefined;\n  const trimmed = value.trim();\n  return trimmed === '' ? undefined : trimmed;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\evidence-retention-chain-continuity.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\human-task-evidence-hooks.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\human-task-evidence-hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\in-memory-worm-evidence-payload-store.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\in-memory-worm-evidence-payload-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\s3-worm-evidence-payload-store.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\s3-worm-evidence-payload-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\evidence\\synthetic-evidence-retention-fixtures.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\agent-gateway.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\agent-gateway.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async method 'handleRequest' has a complexity of 15. Maximum allowed is 10.","line":71,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":71,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Buffer<ArrayBufferLike>`.","line":93,"column":25,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":93,"endColumn":79}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Portarium Agent Gateway -- thin proxy service.\n *\n * Responsibilities:\n * 1. Terminate external auth (JWT / OAuth2 / mTLS)\n * 2. Inject W3C trace-context headers (traceparent, tracestate)\n * 3. Enforce per-workspace rate limits (token bucket)\n * 4. Validate request shape (fast-fail before proxy)\n * 5. Proxy to the internal control plane\n */\n\nimport { randomUUID } from 'node:crypto';\nimport type { IncomingMessage, ServerResponse } from 'node:http';\n\nimport type { TokenBucketRateLimiter } from './rate-limiter.js';\nimport { validateRequest, type RequestValidatorConfig } from './request-validator.js';\n\n// ---------------------------------------------------------------------------\n// Types\n// ---------------------------------------------------------------------------\n\ntype ProblemDetails = Readonly<{\n  type: string;\n  title: string;\n  status: number;\n  detail?: string;\n}>;\n\nexport type AuthVerifier = (authorizationHeader: string | undefined) => Promise<AuthVerifyResult>;\n\nexport type AuthVerifyResult =\n  | Readonly<{ ok: true; workspaceId: string; subject: string }>\n  | Readonly<{ ok: false; reason: string }>;\n\nexport type AgentGatewayConfig = Readonly<{\n  /** Base URL of the internal control plane (e.g. http://control-plane:3000). */\n  controlPlaneBaseUrl: string;\n  /** Auth verifier  decodes and validates incoming credentials. */\n  authVerifier: AuthVerifier;\n  /** Per-workspace rate limiter. */\n  rateLimiter: TokenBucketRateLimiter;\n  /** Optional request validation config. */\n  requestValidation?: RequestValidatorConfig;\n  /** Optional fetch implementation for proxying (defaults to global fetch). */\n  fetchImpl?: typeof fetch;\n}>;\n\n// ---------------------------------------------------------------------------\n// Gateway handler\n// ---------------------------------------------------------------------------\n\nexport class AgentGateway {\n  readonly #controlPlaneBaseUrl: string;\n  readonly #authVerifier: AuthVerifier;\n  readonly #rateLimiter: TokenBucketRateLimiter;\n  readonly #requestValidation: RequestValidatorConfig | undefined;\n  readonly #fetchImpl: typeof fetch;\n\n  public constructor(config: AgentGatewayConfig) {\n    this.#controlPlaneBaseUrl = config.controlPlaneBaseUrl.replace(/\\/+$/, '');\n    this.#authVerifier = config.authVerifier;\n    this.#rateLimiter = config.rateLimiter;\n    this.#requestValidation = config.requestValidation;\n    this.#fetchImpl = config.fetchImpl ?? fetch;\n  }\n\n  /**\n   * Handle an inbound HTTP request. This is the top-level entry point used\n   * by the HTTP server (e.g. `http.createServer(gateway.handleRequest)`).\n   */\n  public handleRequest = async (req: IncomingMessage, res: ServerResponse): Promise<void> => {\n    try {\n      // 1. Authenticate\n      const authHeader = req.headers.authorization;\n      const authResult = await this.#authVerifier(authHeader);\n      if (!authResult.ok) {\n        return sendProblem(res, 401, 'Unauthorized', authResult.reason);\n      }\n\n      // 2. Rate limit\n      const rateResult = this.#rateLimiter.tryConsume(authResult.workspaceId);\n      if (!rateResult.allowed) {\n        res.setHeader('retry-after', String(rateResult.retryAfterSeconds));\n        return sendProblem(res, 429, 'Too Many Requests', 'Rate limit exceeded.');\n      }\n\n      // 3. Validate request shape\n      const method = (req.method ?? 'GET').toUpperCase();\n      const path = req.url ?? '/';\n      const contentType = req.headers['content-type'];\n      const bodyChunks: Buffer[] = [];\n      for await (const chunk of req) {\n        bodyChunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\n      }\n      const bodyBuffer = Buffer.concat(bodyChunks);\n\n      const validation = validateRequest(\n        {\n          method,\n          path,\n          bodySize: bodyBuffer.length,\n          ...(contentType !== undefined ? { contentType } : {}),\n        },\n        this.#requestValidation,\n      );\n      if (!validation.valid) {\n        return sendProblem(res, 422, 'Validation Failed', validation.reason);\n      }\n\n      // 4. Build trace context headers\n      const incomingTraceparent = req.headers['traceparent'] as string | undefined;\n      const traceparent = incomingTraceparent ?? generateTraceparent();\n      const tracestate = req.headers['tracestate'] as string | undefined;\n\n      // 5. Proxy to control plane\n      const targetUrl = `${this.#controlPlaneBaseUrl}${path}`;\n      const proxyHeaders: Record<string, string> = {\n        'content-type': contentType ?? 'application/json',\n        'x-workspace-id': authResult.workspaceId,\n        'x-subject': authResult.subject,\n        'x-correlation-id': randomUUID(),\n        traceparent,\n        ...(tracestate ? { tracestate } : {}),\n      };\n\n      const upstream = await this.#fetchImpl(targetUrl, {\n        method,\n        headers: proxyHeaders,\n        ...(bodyBuffer.length > 0 ? { body: bodyBuffer } : {}),\n      });\n\n      // 6. Forward response\n      res.writeHead(upstream.status, {\n        'content-type': upstream.headers.get('content-type') ?? 'application/json',\n      });\n      const upstreamBody = await upstream.text();\n      res.end(upstreamBody);\n    } catch {\n      sendProblem(res, 502, 'Bad Gateway', 'Failed to proxy request to control plane.');\n    }\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\nfunction sendProblem(res: ServerResponse, status: number, title: string, detail: string): void {\n  const problem: ProblemDetails = {\n    type: `https://portarium.dev/problems/${toKebab(title)}`,\n    title,\n    status,\n    detail,\n  };\n  res.writeHead(status, { 'content-type': 'application/problem+json' });\n  res.end(JSON.stringify(problem));\n}\n\nfunction toKebab(value: string): string {\n  return value.toLowerCase().replace(/\\s+/g, '-');\n}\n\nfunction generateTraceparent(): string {\n  const version = '00';\n  const traceId = randomHex(16);\n  const spanId = randomHex(8);\n  const flags = '01';\n  return `${version}-${traceId}-${spanId}-${flags}`;\n}\n\nfunction randomHex(byteCount: number): string {\n  const bytes = new Uint8Array(byteCount);\n  crypto.getRandomValues(bytes);\n  return Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\credential-delegation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\credential-delegation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\rate-limiter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\rate-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\gateway\\request-validator.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Function 'validateRequest' has a complexity of 15. Maximum allowed is 10.","line":32,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":32,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lightweight request shape validator for the Agent Gateway.\n *\n * Validates that inbound requests have the minimum required structure before\n * proxying to the control plane. This is not a full OpenAPI schema validator --\n * the control plane performs authoritative validation. The gateway performs\n * \"fast-fail\" checks to reject obviously malformed requests early.\n */\n\nexport type RequestValidationResult =\n  | Readonly<{ valid: true }>\n  | Readonly<{ valid: false; reason: string }>;\n\nexport type ValidatableRequest = Readonly<{\n  method: string;\n  path: string;\n  contentType?: string;\n  bodySize?: number;\n  body?: unknown;\n}>;\n\nexport type RequestValidatorConfig = Readonly<{\n  /** Maximum request body size in bytes. Defaults to 1 MiB. */\n  maxBodyBytes?: number;\n  /** Allowed HTTP methods. Defaults to GET, POST, PUT, PATCH, DELETE. */\n  allowedMethods?: readonly string[];\n}>;\n\nconst DEFAULT_MAX_BODY_BYTES = 1_048_576; // 1 MiB\nconst DEFAULT_ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'] as const;\n\nexport function validateRequest(\n  request: ValidatableRequest,\n  config?: RequestValidatorConfig,\n): RequestValidationResult {\n  const maxBodyBytes = config?.maxBodyBytes ?? DEFAULT_MAX_BODY_BYTES;\n  const allowedMethods = config?.allowedMethods ?? DEFAULT_ALLOWED_METHODS;\n\n  const method = request.method.toUpperCase();\n  if (!allowedMethods.includes(method)) {\n    return { valid: false, reason: `Method ${method} is not allowed.` };\n  }\n\n  if (!request.path.startsWith('/')) {\n    return { valid: false, reason: 'Request path must start with /.' };\n  }\n\n  if (request.bodySize !== undefined && request.bodySize > maxBodyBytes) {\n    return {\n      valid: false,\n      reason: `Request body exceeds maximum size of ${maxBodyBytes} bytes.`,\n    };\n  }\n\n  const hasBody = method === 'POST' || method === 'PUT' || method === 'PATCH';\n  if (hasBody && request.contentType !== undefined) {\n    const ct = request.contentType.toLowerCase();\n    if (!ct.includes('application/json') && !ct.includes('application/cloudevents+json')) {\n      return {\n        valid: false,\n        reason: `Unsupported content type: ${request.contentType}. Expected application/json.`,\n      };\n    }\n  }\n\n  return { valid: true };\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\langflow\\langflow-agent-flow-action-runner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\langflow\\langflow-agent-flow-action-runner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\location\\localisation-ingestion-pipeline.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\location\\localisation-ingestion-pipeline.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\location\\map-data-services.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\location\\map-data-services.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\mcp\\mcp-tool-schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\mcp\\portarium-mcp-server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\mcp\\portarium-mcp-server.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Private async method #dispatch has a complexity of 15. Maximum allowed is 10.","line":166,"column":3,"nodeType":"FunctionExpression","messageId":"complex","endLine":166,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Portarium MCP (Model Context Protocol) server.\n *\n * Exposes Portarium control-plane operations as MCP tools using JSON-RPC 2.0\n * semantics. Each tool maps to a PortariumClient method.\n *\n * Transport-agnostic: callers pass JSON-RPC request objects and receive\n * JSON-RPC response objects. HTTP/SSE/stdio transport is wired externally.\n */\n\nimport { MCP_TOOLS, findToolSchema, type McpToolSchema } from './mcp-tool-schemas.js';\n\n// ---------------------------------------------------------------------------\n// JSON-RPC 2.0 types\n// ---------------------------------------------------------------------------\n\nexport type JsonRpcRequest = Readonly<{\n  jsonrpc: '2.0';\n  id: string | number;\n  method: string;\n  params?: unknown;\n}>;\n\nexport type JsonRpcResponse =\n  | Readonly<{ jsonrpc: '2.0'; id: string | number; result: unknown }>\n  | Readonly<{\n      jsonrpc: '2.0';\n      id: string | number | null;\n      error: JsonRpcError;\n    }>;\n\nexport type JsonRpcError = Readonly<{\n  code: number;\n  message: string;\n  data?: unknown;\n}>;\n\n// Standard JSON-RPC error codes\nconst PARSE_ERROR = -32700;\nconst INVALID_REQUEST = -32600;\nconst METHOD_NOT_FOUND = -32601;\nconst INVALID_PARAMS = -32602;\nconst INTERNAL_ERROR = -32603;\n\n// ---------------------------------------------------------------------------\n// PortariumClient interface (adapter boundary)\n// ---------------------------------------------------------------------------\n\nexport interface PortariumClient {\n  startRun(params: {\n    workspaceId: string;\n    workflowId: string;\n    input?: Record<string, unknown>;\n  }): Promise<unknown>;\n\n  getRun(params: { workspaceId: string; runId: string }): Promise<unknown>;\n\n  cancelRun(params: { workspaceId: string; runId: string; reason?: string }): Promise<unknown>;\n\n  listWorkItems(params: { workspaceId: string; runId?: string; status?: string }): Promise<unknown>;\n\n  submitApproval(params: {\n    workspaceId: string;\n    approvalId: string;\n    decision: string;\n    comment?: string;\n  }): Promise<unknown>;\n\n  registerAgent(params: {\n    workspaceId: string;\n    machineId: string;\n    agentId: string;\n    displayName: string;\n    capabilities?: readonly string[];\n  }): Promise<unknown>;\n\n  agentHeartbeat(params: {\n    workspaceId: string;\n    machineId: string;\n    agentId: string;\n    status?: string;\n  }): Promise<unknown>;\n}\n\n// ---------------------------------------------------------------------------\n// MCP Server\n// ---------------------------------------------------------------------------\n\nexport class PortariumMcpServer {\n  readonly #client: PortariumClient;\n  readonly #allowedTools: ReadonlySet<string> | undefined;\n\n  public constructor(client: PortariumClient, opts?: { allowedTools?: ReadonlySet<string> }) {\n    this.#client = client;\n    this.#allowedTools = opts?.allowedTools;\n  }\n\n  public async handleRequest(request: unknown): Promise<JsonRpcResponse> {\n    const parsed = parseJsonRpcRequest(request);\n    if (!parsed.ok) {\n      return {\n        jsonrpc: '2.0',\n        id: parsed.id ?? null,\n        error: parsed.error,\n      };\n    }\n\n    const { id, method, params } = parsed.request;\n\n    switch (method) {\n      case 'initialize':\n        return jsonRpcOk(id, {\n          protocolVersion: '2024-11-05',\n          capabilities: { tools: {} },\n          serverInfo: { name: 'portarium-mcp-server', version: '1.0.0' },\n        });\n\n      case 'tools/list':\n        return jsonRpcOk(id, { tools: this.#getVisibleTools() });\n\n      case 'tools/call':\n        return this.#handleToolCall(id, params);\n\n      default:\n        return jsonRpcError(id, METHOD_NOT_FOUND, `Unknown method: ${method}`);\n    }\n  }\n\n  #getVisibleTools(): readonly McpToolSchema[] {\n    if (!this.#allowedTools) return MCP_TOOLS;\n    return MCP_TOOLS.filter((t) => this.#allowedTools!.has(t.name));\n  }\n\n  async #handleToolCall(id: string | number, params: unknown): Promise<JsonRpcResponse> {\n    if (!isRecord(params)) {\n      return jsonRpcError(id, INVALID_PARAMS, 'params must be an object.');\n    }\n\n    const toolName = asString(params['name']);\n    if (!toolName) {\n      return jsonRpcError(id, INVALID_PARAMS, 'Missing tool name.');\n    }\n\n    const schema = findToolSchema(toolName);\n    if (!schema) {\n      return jsonRpcError(id, METHOD_NOT_FOUND, `Unknown tool: ${toolName}`);\n    }\n\n    if (this.#allowedTools && !this.#allowedTools.has(toolName)) {\n      return jsonRpcError(id, METHOD_NOT_FOUND, `Tool not available: ${toolName}`);\n    }\n\n    const toolArgs = isRecord(params['arguments']) ? params['arguments'] : {};\n\n    try {\n      const result = await this.#dispatch(toolName, toolArgs);\n      return jsonRpcOk(id, {\n        content: [{ type: 'text', text: JSON.stringify(result) }],\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Tool execution failed.';\n      return jsonRpcError(id, INTERNAL_ERROR, message);\n    }\n  }\n\n  async #dispatch(toolName: string, args: Record<string, unknown>): Promise<unknown> {\n    switch (toolName) {\n      case 'portarium_run_start': {\n        const input = asRecord(args['input']);\n        return this.#client.startRun({\n          workspaceId: requireString(args, 'workspaceId'),\n          workflowId: requireString(args, 'workflowId'),\n          ...(input !== undefined ? { input } : {}),\n        });\n      }\n\n      case 'portarium_run_get':\n        return this.#client.getRun({\n          workspaceId: requireString(args, 'workspaceId'),\n          runId: requireString(args, 'runId'),\n        });\n\n      case 'portarium_run_cancel': {\n        const reason = asString(args['reason']);\n        return this.#client.cancelRun({\n          workspaceId: requireString(args, 'workspaceId'),\n          runId: requireString(args, 'runId'),\n          ...(reason !== undefined ? { reason } : {}),\n        });\n      }\n\n      case 'portarium_work_items_list': {\n        const runId = asString(args['runId']);\n        const status = asString(args['status']);\n        return this.#client.listWorkItems({\n          workspaceId: requireString(args, 'workspaceId'),\n          ...(runId !== undefined ? { runId } : {}),\n          ...(status !== undefined ? { status } : {}),\n        });\n      }\n\n      case 'portarium_approval_submit': {\n        const comment = asString(args['comment']);\n        return this.#client.submitApproval({\n          workspaceId: requireString(args, 'workspaceId'),\n          approvalId: requireString(args, 'approvalId'),\n          decision: requireString(args, 'decision'),\n          ...(comment !== undefined ? { comment } : {}),\n        });\n      }\n\n      case 'portarium_agent_register': {\n        const capabilities = asStringArray(args['capabilities']);\n        return this.#client.registerAgent({\n          workspaceId: requireString(args, 'workspaceId'),\n          machineId: requireString(args, 'machineId'),\n          agentId: requireString(args, 'agentId'),\n          displayName: requireString(args, 'displayName'),\n          ...(capabilities !== undefined ? { capabilities } : {}),\n        });\n      }\n\n      case 'portarium_agent_heartbeat': {\n        const status = asString(args['status']);\n        return this.#client.agentHeartbeat({\n          workspaceId: requireString(args, 'workspaceId'),\n          machineId: requireString(args, 'machineId'),\n          agentId: requireString(args, 'agentId'),\n          ...(status !== undefined ? { status } : {}),\n        });\n      }\n\n      default:\n        throw new Error(`Unimplemented tool: ${toolName}`);\n    }\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Internal helpers\n// ---------------------------------------------------------------------------\n\ntype ParseOk = Readonly<{ ok: true; request: JsonRpcRequest }>;\ntype ParseFail = Readonly<{\n  ok: false;\n  id: string | number | null;\n  error: JsonRpcError;\n}>;\n\nfunction parseJsonRpcRequest(raw: unknown): ParseOk | ParseFail {\n  if (!isRecord(raw)) {\n    return {\n      ok: false,\n      id: null,\n      error: { code: PARSE_ERROR, message: 'Request must be a JSON object.' },\n    };\n  }\n\n  const id = raw['id'];\n  const resolvedId = typeof id === 'string' || typeof id === 'number' ? id : null;\n\n  if (raw['jsonrpc'] !== '2.0') {\n    return {\n      ok: false,\n      id: resolvedId,\n      error: { code: INVALID_REQUEST, message: 'jsonrpc must be \"2.0\".' },\n    };\n  }\n\n  const method = raw['method'];\n  if (typeof method !== 'string') {\n    return {\n      ok: false,\n      id: resolvedId,\n      error: { code: INVALID_REQUEST, message: 'method must be a string.' },\n    };\n  }\n\n  return {\n    ok: true,\n    request: {\n      jsonrpc: '2.0',\n      id: resolvedId ?? 0,\n      method,\n      params: raw['params'],\n    },\n  };\n}\n\nfunction jsonRpcOk(id: string | number, result: unknown): JsonRpcResponse {\n  return { jsonrpc: '2.0', id, result };\n}\n\nfunction jsonRpcError(id: string | number | null, code: number, message: string): JsonRpcResponse {\n  return { jsonrpc: '2.0', id: id ?? 0, error: { code, message } };\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction asString(value: unknown): string | undefined {\n  return typeof value === 'string' ? value : undefined;\n}\n\nfunction asRecord(value: unknown): Record<string, unknown> | undefined {\n  return isRecord(value) ? value : undefined;\n}\n\nfunction asStringArray(value: unknown): readonly string[] | undefined {\n  if (!Array.isArray(value)) return undefined;\n  return value.filter((v): v is string => typeof v === 'string');\n}\n\nfunction requireString(record: Record<string, unknown>, key: string): string {\n  const value = record[key];\n  if (typeof value !== 'string' || value.trim() === '') {\n    throw new Error(`Missing required string parameter: ${key}`);\n  }\n  return value;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\mcp\\tool-allowlist-filter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\migrations\\cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\migrations\\default-migrations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\migrations\\schema-migrator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\migrations\\schema-migrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\observability\\agent-side-effect-logger.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\observability\\agent-side-effect-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\observability\\metrics-hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\observability\\otel-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\observability\\structured-log.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\observability\\structured-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openapi\\openapi-contract.test-helpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openapi\\openapi-contract.test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openapi\\openapi-contract.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openapi\\openapi-operation-ids-golden.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openapi\\openapi-operation-ids-workflow.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openclaw\\openclaw-gateway-machine-invoker.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openclaw\\openclaw-gateway-machine-invoker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\openclaw\\openclaw-gateway-machine-invoker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\in-memory-sql-client.test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\node-postgres-sql-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\postgres-eventing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\postgres-json-document-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\postgres-store-adapters.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\postgres-store-adapters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\postgres-workforce-store-adapters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\query-builder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\postgresql\\sql-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sdk\\portarium-client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sdk\\portarium-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sidecar\\egress-proxy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sidecar\\egress-proxy.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Function 'checkEgressAllowed' has a complexity of 12. Maximum allowed is 10.","line":39,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":39,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Egress proxy for the Portarium sidecar.\n *\n * Enforces an allowlist of permitted egress destinations. All outbound\n * requests from the workload must pass through this proxy. Requests to\n * destinations not in the allowlist are rejected.\n *\n * Additionally injects W3C trace-context headers into all proxied requests.\n */\n\n// ---------------------------------------------------------------------------\n// Types\n// ---------------------------------------------------------------------------\n\nexport type EgressRule = Readonly<{\n  /** Host or host:port pattern. Supports trailing wildcard (e.g. *.github.com). */\n  hostPattern: string;\n  /** Allowed HTTP methods. Empty = all methods. */\n  allowedMethods?: readonly string[];\n  /** Optional port restriction. Undefined = any port. */\n  port?: number;\n}>;\n\nexport type EgressProxyConfig = Readonly<{\n  /** Ordered allowlist rules. First match wins. */\n  allowlist: readonly EgressRule[];\n  /** Whether to inject traceparent/tracestate into proxied requests. */\n  injectTraceContext?: boolean;\n}>;\n\nexport type EgressCheckResult =\n  | Readonly<{ allowed: true; matchedRule: EgressRule }>\n  | Readonly<{ allowed: false; reason: string }>;\n\n// ---------------------------------------------------------------------------\n// Evaluation\n// ---------------------------------------------------------------------------\n\nexport function checkEgressAllowed(\n  config: EgressProxyConfig,\n  request: { host: string; port?: number; method?: string },\n): EgressCheckResult {\n  const host = request.host.toLowerCase();\n  const method = request.method?.toUpperCase();\n\n  for (const rule of config.allowlist) {\n    if (!matchesHostPattern(rule.hostPattern, host)) continue;\n\n    if (rule.port !== undefined && request.port !== undefined && request.port !== rule.port) {\n      continue;\n    }\n\n    if (\n      rule.allowedMethods &&\n      rule.allowedMethods.length > 0 &&\n      method &&\n      !rule.allowedMethods.includes(method)\n    ) {\n      continue;\n    }\n\n    return { allowed: true, matchedRule: rule };\n  }\n\n  return {\n    allowed: false,\n    reason: `Egress to ${host}${request.port ? `:${request.port}` : ''} is not in the allowlist.`,\n  };\n}\n\n/**\n * Given a full list of requested destinations, return which ones are blocked.\n */\nexport function findBlockedDestinations(\n  config: EgressProxyConfig,\n  destinations: readonly { host: string; port?: number; method?: string }[],\n): readonly { host: string; reason: string }[] {\n  const blocked: { host: string; reason: string }[] = [];\n  for (const dest of destinations) {\n    const result = checkEgressAllowed(config, dest);\n    if (!result.allowed) {\n      blocked.push({ host: dest.host, reason: result.reason });\n    }\n  }\n  return blocked;\n}\n\n// ---------------------------------------------------------------------------\n// Pattern matching\n// ---------------------------------------------------------------------------\n\nfunction matchesHostPattern(pattern: string, host: string): boolean {\n  const normalizedPattern = pattern.toLowerCase();\n\n  if (normalizedPattern === '*') return true;\n\n  if (normalizedPattern.startsWith('*.')) {\n    const suffix = normalizedPattern.slice(1); // e.g. \".github.com\"\n    return host === normalizedPattern.slice(2) || host.endsWith(suffix);\n  }\n\n  return normalizedPattern === host;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sidecar\\portarium-sidecar.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sidecar\\sidecar-config-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sidecar\\sidecar-proxy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\sidecar\\sidecar-proxy.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async method 'proxy' has a complexity of 13. Maximum allowed is 10.","line":89,"column":3,"nodeType":"FunctionExpression","messageId":"complex","endLine":89,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SidecarConfigV1 } from './sidecar-config-v1.js';\n\n/**\n * Egress validation result.\n */\nexport type EgressCheckResult = Readonly<{\n  allowed: boolean;\n  host: string;\n  reason?: string;\n}>;\n\n/**\n * Proxied request descriptor.\n */\nexport type ProxiedRequest = Readonly<{\n  method: string;\n  url: string;\n  headers: Readonly<Record<string, string>>;\n  body?: string;\n}>;\n\n/**\n * Proxied response descriptor.\n */\nexport type ProxiedResponse = Readonly<{\n  status: number;\n  headers: Readonly<Record<string, string>>;\n  body: string;\n}>;\n\n/**\n * Portarium sidecar proxy logic.\n *\n * Responsibilities:\n * 1. Validate egress destinations against the allowlist\n * 2. Inject authentication headers (Bearer token)\n * 3. Inject W3C trace context headers (traceparent, tracestate)\n *\n * This module implements the proxy logic; the HTTP server binding is\n * handled by the sidecar entrypoint (sidecar main).\n */\nexport class SidecarProxy {\n  readonly #config: SidecarConfigV1;\n  readonly #fetchImpl: typeof fetch;\n  #currentToken: string | undefined;\n\n  public constructor(config: SidecarConfigV1, fetchImpl?: typeof fetch) {\n    this.#config = config;\n    this.#fetchImpl = fetchImpl ?? fetch;\n  }\n\n  /**\n   * Set the current bearer token for auth header injection.\n   */\n  public setToken(token: string): void {\n    this.#currentToken = token;\n  }\n\n  /**\n   * Validate that a target URL is permitted by the egress allowlist.\n   */\n  public checkEgress(targetUrl: string): EgressCheckResult {\n    let parsedUrl: URL;\n    try {\n      parsedUrl = new URL(targetUrl);\n    } catch {\n      return { allowed: false, host: targetUrl, reason: 'Invalid URL' };\n    }\n\n    const host = parsedUrl.hostname;\n\n    if (this.#config.egressAllowlist.length === 0) {\n      return { allowed: false, host, reason: 'Egress allowlist is empty' };\n    }\n\n    for (const pattern of this.#config.egressAllowlist) {\n      if (matchesHost(host, pattern)) {\n        return { allowed: true, host };\n      }\n    }\n\n    return { allowed: false, host, reason: `Host \"${host}\" not in egress allowlist` };\n  }\n\n  /**\n   * Proxy a request to the target URL with egress validation,\n   * auth header injection, and trace context propagation.\n   */\n  public async proxy(\n    request: ProxiedRequest,\n    traceContext?: Readonly<{ traceparent?: string; tracestate?: string }>,\n  ): Promise<ProxiedResponse> {\n    const egressCheck = this.checkEgress(request.url);\n    if (!egressCheck.allowed) {\n      return {\n        status: 403,\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({\n          error: 'EgressDenied',\n          message: egressCheck.reason,\n          host: egressCheck.host,\n        }),\n      };\n    }\n\n    const headers: Record<string, string> = { ...request.headers };\n\n    // Inject auth header if token is available and not already set.\n    if (this.#currentToken && !headers['authorization']) {\n      headers['authorization'] = `Bearer ${this.#currentToken}`;\n    }\n\n    // Inject W3C trace context headers.\n    if (traceContext?.traceparent && !headers['traceparent']) {\n      headers['traceparent'] = traceContext.traceparent;\n    }\n    if (traceContext?.tracestate && !headers['tracestate']) {\n      headers['tracestate'] = traceContext.tracestate;\n    }\n\n    try {\n      const response = await this.#fetchImpl(request.url, {\n        method: request.method,\n        headers,\n        ...(request.body !== undefined ? { body: request.body } : {}),\n      });\n\n      const responseBody = await response.text();\n      const responseHeaders: Record<string, string> = {};\n      response.headers.forEach((value, key) => {\n        responseHeaders[key] = value;\n      });\n\n      return {\n        status: response.status,\n        headers: responseHeaders,\n        body: responseBody,\n      };\n    } catch (error) {\n      return {\n        status: 502,\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({\n          error: 'UpstreamFailure',\n          message: error instanceof Error ? error.message : 'Unknown error',\n        }),\n      };\n    }\n  }\n}\n\n/**\n * Match a hostname against a pattern.\n * Supports exact match and wildcard prefix (e.g., *.example.com).\n */\nfunction matchesHost(host: string, pattern: string): boolean {\n  if (pattern === host) return true;\n\n  if (pattern.startsWith('*.')) {\n    const suffix = pattern.slice(1); // e.g., \".example.com\"\n    return host.endsWith(suffix) && host.length > suffix.length;\n  }\n\n  return false;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\activities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\activities.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'completeRunActivity' has too many lines (97). Maximum allowed is 80.","line":145,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":252,"endColumn":2},{"ruleId":"max-lines-per-function","severity":2,"message":"Async method 'run' has too many lines (81). Maximum allowed is 80.","line":160,"column":10,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":250,"endColumn":6},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (434). Maximum allowed is 350.","line":392,"column":1,"nodeType":null,"messageId":"exceed","endLine":490,"endColumn":1}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from 'node:crypto';\n\nimport { SpanStatusCode, trace } from '@opentelemetry/api';\n\nimport {\n  diffEffects,\n  type EffectDiffResultV1,\n  type VerifiedEffectV1,\n} from '../../domain/services/diff.js';\nimport { buildPlanFromWorkflow, validatePlanEffectIds } from '../../domain/services/planning.js';\nimport { assertValidRunStatusTransition } from '../../domain/services/run-status-transitions.js';\nimport type { RunStatus } from '../../domain/runs/run-v1.js';\nimport type { PlanV1, PlannedEffectV1 } from '../../domain/plan/plan-v1.js';\nimport type { WorkflowActionV1, WorkflowV1 } from '../../domain/workflows/workflow-v1.js';\nimport { NodeCryptoEvidenceHasher } from '../crypto/node-crypto-evidence-hasher.js';\nimport {\n  emitCounter,\n  emitHistogram,\n  type MetricAttributes,\n} from '../observability/metrics-hooks.js';\nimport {\n  appendEvidenceEntryV1,\n  verifyEvidenceChainV1,\n} from '../../domain/evidence/evidence-chain-v1.js';\nimport type { EvidenceEntryV1 } from '../../domain/evidence/evidence-entry-v1.js';\nimport {\n  CorrelationId,\n  EffectId,\n  EvidenceId,\n  PlanId,\n  RunId,\n  UserId,\n  WorkspaceId,\n} from '../../domain/primitives/index.js';\n\nexport type StartRunActivityInput = Readonly<{\n  runId: string;\n  tenantId: string;\n  workflowId: string;\n  workflow: WorkflowV1;\n  initiatedByUserId: string;\n  correlationId: string;\n  traceparent?: string;\n  tracestate?: string;\n  packId?: string;\n  packVersion?: string;\n  executionTier: 'Auto' | 'Assisted' | 'HumanApprove' | 'ManualOnly';\n}>;\n\nexport type CompleteRunActivityInput = Readonly<{\n  runId: string;\n  tenantId: string;\n  workflowId: string;\n  workflow: WorkflowV1;\n  initiatedByUserId: string;\n  correlationId: string;\n  traceparent?: string;\n  tracestate?: string;\n  packId?: string;\n  packVersion?: string;\n}>;\n\ntype TemporalTelemetryAttributes = Readonly<Record<string, string | number | boolean>>;\ntype TemporalSpanOutcome = 'ok' | 'error';\n\ninterface TemporalTelemetryHooks {\n  onSpanStart(spanName: string, attributes: TemporalTelemetryAttributes): void;\n  onSpanEnd(\n    spanName: string,\n    outcome: TemporalSpanOutcome,\n    durationMs: number,\n    attributes: TemporalTelemetryAttributes,\n  ): void;\n}\n\ntype PackTelemetryContext = Readonly<{\n  packId: string;\n  packVersion: string;\n}>;\n\ninterface RunExecutionState {\n  status: RunStatus;\n  evidence: EvidenceEntryV1[];\n  plan?: PlanV1;\n  diff?: EffectDiffResultV1;\n}\n\nconst tracer = trace.getTracer('portarium.infrastructure.temporal.activities');\nconst hasher = new NodeCryptoEvidenceHasher();\nconst runs = new Map<string, RunExecutionState>();\nconst DEFAULT_PACK_TELEMETRY_CONTEXT: PackTelemetryContext = {\n  packId: 'core.unscoped',\n  packVersion: '0.0.0',\n};\n\nconst NOOP_TEMPORAL_TELEMETRY_HOOKS: TemporalTelemetryHooks = {\n  onSpanStart() {\n    // no-op by default\n  },\n  onSpanEnd() {\n    // no-op by default\n  },\n};\n\nlet activeTemporalTelemetryHooks: TemporalTelemetryHooks = NOOP_TEMPORAL_TELEMETRY_HOOKS;\n\nexport async function startRunActivity(input: StartRunActivityInput): Promise<void> {\n  const packTelemetry = resolvePackTelemetryContext(\n    input.workflow,\n    input.packId,\n    input.packVersion,\n  );\n  const runMetrics = buildRunMetricAttributes(packTelemetry, input.executionTier);\n\n  await observeTemporalSpan({\n    spanName: 'workflow.run.start',\n    attributes: {\n      ...runMetrics,\n      'workflow.id': input.workflowId,\n    },\n    run: () => {\n      emitCounter('portarium.run.started', runMetrics);\n\n      ensureRunState(input.tenantId, input.runId, 'Pending');\n      transitionRun(input.tenantId, input.runId, 'Running');\n\n      appendEvidence(input.tenantId, {\n        schemaVersion: 1,\n        evidenceId: EvidenceId(randomUUID()),\n        workspaceId: WorkspaceId(input.tenantId),\n        correlationId: CorrelationId(input.correlationId),\n        occurredAtIso: new Date().toISOString(),\n        category: 'System',\n        summary: `Run started for workflow ${input.workflowId}.`,\n        actor: { kind: 'System' },\n        links: {\n          runId: RunId(input.runId),\n        },\n      });\n      return Promise.resolve();\n    },\n  });\n}\n\nexport async function completeRunActivity(input: CompleteRunActivityInput): Promise<void> {\n  const packTelemetry = resolvePackTelemetryContext(\n    input.workflow,\n    input.packId,\n    input.packVersion,\n  );\n  const runMetrics = buildRunMetricAttributes(packTelemetry, input.workflow.executionTier);\n  const runStartedAtMs = Date.now();\n\n  await observeTemporalSpan({\n    spanName: 'workflow.run.complete',\n    attributes: {\n      ...runMetrics,\n      'workflow.id': input.workflowId,\n    },\n    run: async () => {\n      try {\n        ensureRunState(input.tenantId, input.runId, 'Running');\n\n        const nowIso = new Date().toISOString();\n\n        const plan = buildPlanFromWorkflow({\n          workflow: input.workflow,\n          workspaceId: WorkspaceId(input.tenantId),\n          createdByUserId: UserId(input.initiatedByUserId),\n          planId: PlanId(randomUUID()),\n          createdAtIso: nowIso,\n          effectFactory: actionToPlannedEffect,\n        });\n\n        const validation = validatePlanEffectIds(plan);\n        if (!validation.ok) {\n          throw new Error(\n            `Duplicate effect IDs in plan: ${validation.duplicateEffectIds.join(', ')}`,\n          );\n        }\n\n        setRunPlan(input.tenantId, input.runId, plan);\n\n        appendEvidence(input.tenantId, {\n          schemaVersion: 1,\n          evidenceId: EvidenceId(randomUUID()),\n          workspaceId: WorkspaceId(input.tenantId),\n          correlationId: CorrelationId(input.correlationId),\n          occurredAtIso: nowIso,\n          category: 'Plan',\n          summary: `Plan built with ${plan.plannedEffects.length} effects.`,\n          actor: { kind: 'System' },\n          links: {\n            runId: RunId(input.runId),\n            planId: plan.planId,\n          },\n        });\n\n        const verified = await buildVerifiedEffectsWithTelemetry({\n          workflow: input.workflow,\n          plannedEffects: plan.plannedEffects,\n          workflowExecutionTier: input.workflow.executionTier,\n          packTelemetry,\n        });\n\n        const diff = diffEffects({ planned: plan.plannedEffects, verified });\n        setRunDiff(input.tenantId, input.runId, diff);\n\n        appendEvidence(input.tenantId, {\n          schemaVersion: 1,\n          evidenceId: EvidenceId(randomUUID()),\n          workspaceId: WorkspaceId(input.tenantId),\n          correlationId: CorrelationId(input.correlationId),\n          occurredAtIso: nowIso,\n          category: 'System',\n          summary: `Planned vs verified diff computed (clean=${diff.isClean}).`,\n          actor: { kind: 'System' },\n          links: {\n            runId: RunId(input.runId),\n            planId: plan.planId,\n          },\n          payloadRefs: [\n            {\n              kind: 'Diff',\n              uri: `memory://runs/${encodeURIComponent(input.runId)}/diff`,\n              contentType: 'application/json',\n            },\n          ],\n        });\n\n        transitionRun(input.tenantId, input.runId, 'Succeeded');\n        emitCounter('portarium.run.succeeded', runMetrics);\n        emitHistogram('portarium.run.duration.ms', Date.now() - runStartedAtMs, {\n          ...runMetrics,\n          'run.outcome': 'succeeded',\n        });\n\n        verifyEvidenceChainOrThrow(input.tenantId, input.runId);\n      } catch (error) {\n        emitCounter('portarium.run.failed', {\n          ...runMetrics,\n          errorKind: 'UnhandledException',\n        });\n        emitHistogram('portarium.run.duration.ms', Date.now() - runStartedAtMs, {\n          ...runMetrics,\n          'run.outcome': 'exception',\n        });\n        throw error;\n      }\n    },\n  });\n}\n\nasync function buildVerifiedEffectsWithTelemetry(params: {\n  workflow: WorkflowV1;\n  plannedEffects: readonly PlannedEffectV1[];\n  workflowExecutionTier: 'Auto' | 'Assisted' | 'HumanApprove' | 'ManualOnly';\n  packTelemetry: PackTelemetryContext;\n}): Promise<readonly VerifiedEffectV1[]> {\n  const plannedByActionId = new Map<string, PlannedEffectV1>(\n    params.plannedEffects.map((effect) => [String(effect.effectId), effect]),\n  );\n  const verified: VerifiedEffectV1[] = [];\n\n  for (const action of params.workflow.actions) {\n    const plannedEffect = plannedByActionId.get(String(action.actionId));\n    if (!plannedEffect) {\n      continue;\n    }\n\n    const actionMetrics = buildActionMetricAttributes(\n      params.packTelemetry,\n      params.workflowExecutionTier,\n      action,\n    );\n    const actionStartedAtMs = Date.now();\n\n    try {\n      const verifiedEffect = await observeTemporalSpan({\n        spanName: 'workflow.action.execute',\n        attributes: actionMetrics,\n        run: () =>\n          Promise.resolve({\n            effectId: plannedEffect.effectId,\n            operation: plannedEffect.operation,\n            target: plannedEffect.target,\n            summary: `Verified: ${plannedEffect.summary}`,\n            verifiedAtIso: new Date().toISOString(),\n          } satisfies VerifiedEffectV1),\n      });\n\n      emitCounter('portarium.action.succeeded', actionMetrics);\n      emitHistogram('portarium.action.duration.ms', Date.now() - actionStartedAtMs, {\n        ...actionMetrics,\n        'action.outcome': 'succeeded',\n      });\n      verified.push(verifiedEffect);\n    } catch (error) {\n      emitCounter('portarium.action.failed', {\n        ...actionMetrics,\n        errorKind: 'UnhandledException',\n      });\n      emitHistogram('portarium.action.duration.ms', Date.now() - actionStartedAtMs, {\n        ...actionMetrics,\n        'action.outcome': 'exception',\n      });\n      throw error;\n    }\n  }\n\n  return verified;\n}\n\nasync function observeTemporalSpan<T>(params: {\n  spanName: string;\n  attributes: TemporalTelemetryAttributes;\n  run: () => Promise<T>;\n}): Promise<T> {\n  return tracer.startActiveSpan(\n    params.spanName,\n    { attributes: params.attributes },\n    async (span) => {\n      activeTemporalTelemetryHooks.onSpanStart(params.spanName, params.attributes);\n      const startedAtMs = Date.now();\n\n      try {\n        const value = await params.run();\n        const durationMs = Date.now() - startedAtMs;\n        span.setStatus({ code: SpanStatusCode.OK });\n        activeTemporalTelemetryHooks.onSpanEnd(\n          params.spanName,\n          'ok',\n          durationMs,\n          params.attributes,\n        );\n        return value;\n      } catch (error) {\n        const durationMs = Date.now() - startedAtMs;\n        const message =\n          error instanceof Error ? error.message : 'Unhandled Temporal activity error.';\n        span.recordException(error instanceof Error ? error : new Error(message));\n        span.setStatus({ code: SpanStatusCode.ERROR, message });\n        activeTemporalTelemetryHooks.onSpanEnd(\n          params.spanName,\n          'error',\n          durationMs,\n          params.attributes,\n        );\n        throw error;\n      } finally {\n        span.end();\n      }\n    },\n  );\n}\n\nfunction resolvePackTelemetryContext(\n  _workflow: WorkflowV1,\n  packId: string | undefined,\n  packVersion: string | undefined,\n): PackTelemetryContext {\n  if (packId && packVersion) {\n    return { packId, packVersion };\n  }\n\n  return DEFAULT_PACK_TELEMETRY_CONTEXT;\n}\n\nfunction buildRunMetricAttributes(\n  packTelemetry: PackTelemetryContext,\n  executionTier: 'Auto' | 'Assisted' | 'HumanApprove' | 'ManualOnly',\n): MetricAttributes {\n  return {\n    'pack.id': packTelemetry.packId,\n    'pack.version': packTelemetry.packVersion,\n    'workflow.execution_tier': executionTier,\n    'telemetry.pii_safe': true,\n  };\n}\n\nfunction buildActionMetricAttributes(\n  packTelemetry: PackTelemetryContext,\n  executionTier: 'Auto' | 'Assisted' | 'HumanApprove' | 'ManualOnly',\n  action: WorkflowActionV1,\n): MetricAttributes {\n  return {\n    ...buildRunMetricAttributes(packTelemetry, executionTier),\n    'action.id': String(action.actionId),\n    'action.operation': action.operation,\n    'action.port_family': action.portFamily,\n  };\n}\n\nfunction runKey(tenantId: string, runId: string): string {\n  return `${tenantId}/${runId}`;\n}\n\nfunction ensureRunState(tenantId: string, runId: string, initial: RunStatus): RunExecutionState {\n  const key = runKey(tenantId, runId);\n  const existing = runs.get(key);\n  if (existing) return existing;\n  const created: RunExecutionState = { status: initial, evidence: [] };\n  runs.set(key, created);\n  return created;\n}\n\nfunction transitionRun(tenantId: string, runId: string, to: RunStatus): void {\n  const state = ensureRunState(tenantId, runId, 'Pending');\n  assertValidRunStatusTransition(state.status, to);\n  state.status = to;\n}\n\nfunction setRunPlan(tenantId: string, runId: string, plan: PlanV1): void {\n  const state = ensureRunState(tenantId, runId, 'Pending');\n  state.plan = plan;\n}\n\nfunction setRunDiff(tenantId: string, runId: string, diff: EffectDiffResultV1): void {\n  const state = ensureRunState(tenantId, runId, 'Pending');\n  state.diff = diff;\n}\n\nfunction appendEvidence(\n  tenantId: string,\n  next: Omit<EvidenceEntryV1, 'previousHash' | 'hashSha256' | 'signatureBase64'>,\n): EvidenceEntryV1 {\n  const state = ensureRunState(tenantId, String(next.links?.runId ?? 'unknown'), 'Pending');\n  const previous = state.evidence[state.evidence.length - 1];\n  const entry = appendEvidenceEntryV1({ previous, next, hasher });\n  state.evidence.push(entry);\n  return entry;\n}\n\nfunction getEvidenceChain(tenantId: string, runId: string): readonly EvidenceEntryV1[] {\n  const state = ensureRunState(tenantId, runId, 'Pending');\n  return state.evidence;\n}\n\nfunction verifyEvidenceChainOrThrow(tenantId: string, runId: string): void {\n  const verify = verifyEvidenceChainV1(getEvidenceChain(tenantId, runId), hasher);\n  if (!verify.ok) {\n    throw new Error(`Evidence chain invalid: ${verify.reason} (index=${verify.index})`);\n  }\n}\n\nfunction actionToPlannedEffect(action: WorkflowActionV1): PlannedEffectV1 {\n  // Current workflow schema does not yet encode a typed effect operation.\n  // Treat every action as an Upsert into an external system reference.\n  return {\n    effectId: EffectId(String(action.actionId)),\n    operation: 'Upsert',\n    target: {\n      sorName: 'execution-plane',\n      portFamily: action.portFamily,\n      externalId: String(action.actionId),\n      externalType: action.operation,\n      displayLabel: action.operation,\n    },\n    summary: `Action ${action.order}: ${action.operation}`,\n    idempotencyKey: String(action.actionId),\n  };\n}\n\nexport function setTemporalTelemetryHooksForTest(hooks: TemporalTelemetryHooks): void {\n  activeTemporalTelemetryHooks = hooks;\n}\n\nexport function resetTemporalTelemetryHooksForTest(): void {\n  activeTemporalTelemetryHooks = NOOP_TEMPORAL_TELEMETRY_HOOKS;\n}\n\nexport const __test = {\n  reset(): void {\n    runs.clear();\n    resetTemporalTelemetryHooksForTest();\n  },\n  getRunStatus(tenantId: string, runId: string): RunStatus | undefined {\n    return runs.get(runKey(tenantId, runId))?.status;\n  },\n  getEvidence(tenantId: string, runId: string): readonly EvidenceEntryV1[] {\n    return runs.get(runKey(tenantId, runId))?.evidence ?? [];\n  },\n  getPlan(tenantId: string, runId: string): PlanV1 | undefined {\n    return runs.get(runKey(tenantId, runId))?.plan;\n  },\n  getDiff(tenantId: string, runId: string): EffectDiffResultV1 | undefined {\n    return runs.get(runKey(tenantId, runId))?.diff;\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\temporal-worker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\temporal-worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\temporal-workflow-orchestrator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\temporal-workflow-orchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\workflows.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\temporal\\workflows.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\testing\\domain-coverage-matrix.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\testing\\tenant-isolated-port-fixtures-v1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\testing\\tenant-isolated-port-fixtures-v1.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\vault\\vault-credential-provider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\vault\\vault-credential-provider.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async method 'getCredential' has a complexity of 14. Maximum allowed is 10.","line":47,"column":3,"nodeType":"FunctionExpression","messageId":"complex","endLine":47,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vault-backed implementation of the CredentialProviderPort.\n *\n * Wraps the HashiCorp Vault KV v2 API to provide tenant-scoped credential\n * retrieval with version pinning support.\n *\n * @see .specify/specs/credential-vault-migration-v1.md\n */\n\nimport type { TenantId as TenantIdType } from '../../domain/primitives/index.js';\nimport type {\n  CredentialProviderPort,\n  CredentialReference,\n  CredentialValue,\n  CredentialProviderError,\n} from '../../application/ports/credential-provider.js';\nimport { err, ok, type Result } from '../../application/common/result.js';\n\nexport type VaultCredentialProviderConfig = Readonly<{\n  /** Vault base URL (e.g. http://127.0.0.1:8200). */\n  vaultAddr: string;\n  /** Vault authentication token. */\n  token: string;\n  /** KV v2 mount path. Defaults to \"secret\". */\n  kvMountPath?: string;\n  /** Optional fetch implementation for testing. */\n  fetchImpl?: typeof fetch;\n}>;\n\nfunction normalizeAddr(addr: string): string {\n  return addr.replace(/\\/+$/, '');\n}\n\nexport class VaultCredentialProvider implements CredentialProviderPort {\n  readonly #vaultAddr: string;\n  readonly #token: string;\n  readonly #kvMount: string;\n  readonly #fetchImpl: typeof fetch;\n\n  public constructor(config: VaultCredentialProviderConfig) {\n    this.#vaultAddr = normalizeAddr(config.vaultAddr);\n    this.#token = config.token;\n    this.#kvMount = config.kvMountPath ?? 'secret';\n    this.#fetchImpl = config.fetchImpl ?? fetch;\n  }\n\n  public async getCredential(\n    ref: CredentialReference,\n  ): Promise<Result<CredentialValue, CredentialProviderError>> {\n    const tenantId: TenantIdType = ref.tenantId;\n    const path = `${this.#kvMount}/data/${tenantId}/${ref.credentialName}`;\n    const versionQs = ref.version !== undefined ? `?version=${ref.version}` : '';\n    const url = `${this.#vaultAddr}/v1/${path}${versionQs}`;\n\n    try {\n      const response = await this.#fetchImpl(url, {\n        method: 'GET',\n        headers: {\n          'x-vault-token': this.#token,\n          'content-type': 'application/json',\n        },\n      });\n\n      if (response.status === 404) {\n        return err({\n          kind: 'CredentialNotFound',\n          message: `Credential '${ref.credentialName}' not found for tenant '${tenantId}'.`,\n        });\n      }\n\n      if (response.status === 403) {\n        return err({\n          kind: 'CredentialAccessDenied',\n          message: `Access denied to credential '${ref.credentialName}' for tenant '${tenantId}'.`,\n        });\n      }\n\n      if (!response.ok) {\n        return err({\n          kind: 'CredentialProviderUnavailable',\n          message: `Vault returned HTTP ${response.status}.`,\n        });\n      }\n\n      const body = (await response.json()) as {\n        data?: {\n          data?: Record<string, string>;\n          metadata?: { version?: number; created_time?: string };\n        };\n      };\n\n      const secretData = body.data?.data;\n      const secret = secretData?.['value'];\n      if (typeof secret !== 'string') {\n        return err({\n          kind: 'CredentialNotFound',\n          message: `Credential '${ref.credentialName}' has no 'value' key.`,\n        });\n      }\n\n      const metadata = body.data?.metadata;\n      return ok({\n        secret,\n        version: metadata?.version ?? 0,\n        createdAtIso: metadata?.created_time ?? new Date(0).toISOString(),\n      });\n    } catch {\n      return err({\n        kind: 'CredentialProviderUnavailable',\n        message: 'Vault connection failed.',\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\vault\\vault-credential-store.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\infrastructure\\vault\\vault-credential-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\http-client-auth.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\http-client.test.ts","messages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (390). Maximum allowed is 350.","line":421,"column":1,"nodeType":null,"messageId":"exceed","endLine":477,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, expect, it } from 'vitest';\n\nimport { ControlPlaneClient, ControlPlaneClientError } from './http-client.js';\nimport { ProblemDetailsError } from './problem-details.js';\n\n// ---------------------------------------------------------------------------\n// Test helpers\n// ---------------------------------------------------------------------------\n\ninterface RecordedCall {\n  input: string;\n  init: RequestInit;\n}\n\nfunction createJsonFetch(\n  body: unknown,\n  status = 200,\n): {\n  calls: RecordedCall[];\n  fetchImpl: typeof fetch;\n} {\n  const calls: RecordedCall[] = [];\n\n  const fetchImpl = (async (input: unknown, init: RequestInit = {}) => {\n    calls.push({ input: String(input), init });\n    return {\n      ok: status >= 200 && status < 300,\n      status,\n      headers: new Headers(),\n      text: async () => JSON.stringify(body),\n    } as Response;\n  }) as typeof fetch;\n\n  return { calls, fetchImpl };\n}\n\nfunction createErrorFetch(status: number, body: string): typeof fetch {\n  return (async () =>\n    ({\n      ok: false,\n      status,\n      headers: new Headers(),\n      text: async () => body,\n    }) as Response) as typeof fetch;\n}\n\nfunction createEmptyFetch(status = 204): typeof fetch {\n  return (async () =>\n    ({\n      ok: true,\n      status,\n      headers: new Headers(),\n      text: async () => '',\n    }) as Response) as typeof fetch;\n}\n\nfunction makeClient(fetchImpl: typeof fetch, extra: object = {}): ControlPlaneClient {\n  return new ControlPlaneClient({\n    baseUrl: 'https://api.portarium.test',\n    fetchImpl,\n    ...extra,\n  });\n}\n\n// ---------------------------------------------------------------------------\n// Route construction (contract-aligned)\n// ---------------------------------------------------------------------------\n\ndescribe('ControlPlaneClient contract-aligned route construction', () => {\n  it('builds listWorkItems with linkage filters and pagination params', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [], nextCursor: null });\n    const client = makeClient(fetchImpl);\n\n    await client.listWorkItems('workspace-1', {\n      status: 'Open',\n      ownerUserId: 'user-1',\n      runId: 'run-1',\n      workflowId: 'wf-1',\n      approvalId: 'approval-1',\n      evidenceId: 'evi-1',\n      limit: 120,\n      cursor: 'next:abc',\n    });\n\n    expect(calls).toHaveLength(1);\n    const call = calls[0]!;\n    const parsed = new URL(call.input);\n    expect(parsed.pathname).toBe('/v1/workspaces/workspace-1/work-items');\n    expect(parsed.searchParams.get('status')).toBe('Open');\n    expect(parsed.searchParams.get('ownerUserId')).toBe('user-1');\n    expect(parsed.searchParams.get('runId')).toBe('run-1');\n    expect(parsed.searchParams.get('workflowId')).toBe('wf-1');\n    expect(parsed.searchParams.get('approvalId')).toBe('approval-1');\n    expect(parsed.searchParams.get('evidenceId')).toBe('evi-1');\n    expect(parsed.searchParams.get('limit')).toBe('120');\n    expect(parsed.searchParams.get('cursor')).toBe('next:abc');\n    expect(call.init.method).toBe('GET');\n  });\n\n  it('builds approval decision endpoint against approvalId', async () => {\n    const { calls, fetchImpl } = createJsonFetch({\n      schemaVersion: 1,\n      approvalId: 'approval-1',\n      workspaceId: 'workspace-1',\n      runId: 'run-1',\n      planId: 'plan-1',\n      prompt: 'approve',\n      status: 'Pending',\n      requestedAtIso: '2026-01-01T00:00:00Z',\n      requestedByUserId: 'user-1',\n    });\n    const client = makeClient(fetchImpl);\n\n    await client.decideApproval('workspace-1', 'approval-1', {\n      decision: 'Approved',\n      rationale: 'Looks good',\n      idempotencyKey: 'idem-1',\n    });\n\n    expect(calls).toHaveLength(1);\n    const call = calls[0]!;\n    const parsed = new URL(call.input);\n    expect(parsed.pathname).toBe('/v1/workspaces/workspace-1/approvals/approval-1/decide');\n    expect(call.init.method).toBe('POST');\n    const headers = call.init.headers as Headers;\n    expect(headers.get('Idempotency-Key')).toBe('idem-1');\n    expect(JSON.parse(call.init.body as string)).toEqual({\n      decision: 'Approved',\n      rationale: 'Looks good',\n    });\n  });\n\n  it('builds run evidence endpoint with run path and cursor pagination', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [], nextCursor: 'next:1' });\n    const client = makeClient(fetchImpl);\n\n    await client.listRunEvidence('workspace-1', 'run-1', {\n      limit: 25,\n      cursor: 'prev:2',\n    });\n\n    expect(calls).toHaveLength(1);\n    const call = calls[0]!;\n    const parsed = new URL(call.input);\n    expect(parsed.pathname).toBe('/v1/workspaces/workspace-1/runs/run-1/evidence');\n    expect(parsed.searchParams.get('limit')).toBe('25');\n    expect(parsed.searchParams.get('cursor')).toBe('prev:2');\n  });\n\n  it('builds approval and plan resource paths correctly', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [] });\n    const client = makeClient(fetchImpl);\n\n    await client.listApprovals('workspace-1');\n    await client.getPlan('workspace-1', 'plan-1');\n\n    expect(calls).toHaveLength(2);\n    const approvalsCall = calls[0]!;\n    const planCall = calls[1]!;\n    expect(new URL(approvalsCall.input).pathname).toBe('/v1/workspaces/workspace-1/approvals');\n    expect(approvalsCall.init.method).toBe('GET');\n    expect(new URL(planCall.input).pathname).toBe('/v1/workspaces/workspace-1/plans/plan-1');\n    expect(planCall.init.method).toBe('GET');\n  });\n\n  it('builds workforce list/get/availability/queues routes with contract query params', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [] });\n    const client = makeClient(fetchImpl);\n\n    await client.listWorkforceMembers('workspace-1', {\n      capability: 'operations.approval',\n      queueId: 'queue-1',\n      availability: 'available',\n      limit: 30,\n      cursor: 'next:workforce',\n    });\n    await client.getWorkforceMember('workspace-1', 'wm-1');\n    await client.patchWorkforceMemberAvailability('workspace-1', 'wm-1', {\n      availabilityStatus: 'busy',\n    });\n    await client.listWorkforceQueues('workspace-1', {\n      capability: 'operations.approval',\n      limit: 10,\n    });\n\n    expect(calls).toHaveLength(4);\n    const listMembers = new URL(calls[0]!.input);\n    expect(listMembers.pathname).toBe('/v1/workspaces/workspace-1/workforce');\n    expect(listMembers.searchParams.get('capability')).toBe('operations.approval');\n    expect(listMembers.searchParams.get('queueId')).toBe('queue-1');\n    expect(listMembers.searchParams.get('availability')).toBe('available');\n    expect(listMembers.searchParams.get('limit')).toBe('30');\n    expect(listMembers.searchParams.get('cursor')).toBe('next:workforce');\n    expect(calls[0]!.init.method).toBe('GET');\n\n    expect(new URL(calls[1]!.input).pathname).toBe('/v1/workspaces/workspace-1/workforce/wm-1');\n    expect(calls[1]!.init.method).toBe('GET');\n\n    expect(new URL(calls[2]!.input).pathname).toBe(\n      '/v1/workspaces/workspace-1/workforce/wm-1/availability',\n    );\n    expect(calls[2]!.init.method).toBe('PATCH');\n    expect(JSON.parse(calls[2]!.init.body as string)).toEqual({ availabilityStatus: 'busy' });\n\n    const listQueues = new URL(calls[3]!.input);\n    expect(listQueues.pathname).toBe('/v1/workspaces/workspace-1/workforce/queues');\n    expect(listQueues.searchParams.get('capability')).toBe('operations.approval');\n    expect(listQueues.searchParams.get('limit')).toBe('10');\n    expect(calls[3]!.init.method).toBe('GET');\n  });\n\n  it('builds human-task list/get/assign/complete/escalate routes', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [] });\n    const client = makeClient(fetchImpl);\n\n    await client.listHumanTasks('workspace-1', {\n      assigneeId: 'wm-1',\n      status: 'assigned',\n      runId: 'run-1',\n      limit: 20,\n    });\n    await client.getHumanTask('workspace-1', 'ht-1');\n    await client.assignHumanTask(\n      'workspace-1',\n      'ht-1',\n      { workforceQueueId: 'queue-finance' },\n      'idem-assign',\n    );\n    await client.completeHumanTask(\n      'workspace-1',\n      'ht-1',\n      { completionNote: 'Completed from inbox' },\n      'idem-complete',\n    );\n    await client.escalateHumanTask(\n      'workspace-1',\n      'ht-1',\n      { workforceQueueId: 'queue-general', reason: 'Need escalation' },\n      'idem-escalate',\n    );\n\n    expect(calls).toHaveLength(5);\n    const list = new URL(calls[0]!.input);\n    expect(list.pathname).toBe('/v1/workspaces/workspace-1/human-tasks');\n    expect(list.searchParams.get('assigneeId')).toBe('wm-1');\n    expect(list.searchParams.get('status')).toBe('assigned');\n    expect(list.searchParams.get('runId')).toBe('run-1');\n    expect(list.searchParams.get('limit')).toBe('20');\n    expect(calls[0]!.init.method).toBe('GET');\n\n    expect(new URL(calls[1]!.input).pathname).toBe('/v1/workspaces/workspace-1/human-tasks/ht-1');\n    expect(calls[1]!.init.method).toBe('GET');\n\n    expect(new URL(calls[2]!.input).pathname).toBe(\n      '/v1/workspaces/workspace-1/human-tasks/ht-1/assign',\n    );\n    expect((calls[2]!.init.headers as Headers).get('Idempotency-Key')).toBe('idem-assign');\n    expect(calls[2]!.init.method).toBe('POST');\n\n    expect(new URL(calls[3]!.input).pathname).toBe(\n      '/v1/workspaces/workspace-1/human-tasks/ht-1/complete',\n    );\n    expect((calls[3]!.init.headers as Headers).get('Idempotency-Key')).toBe('idem-complete');\n    expect(calls[3]!.init.method).toBe('POST');\n\n    expect(new URL(calls[4]!.input).pathname).toBe(\n      '/v1/workspaces/workspace-1/human-tasks/ht-1/escalate',\n    );\n    expect((calls[4]!.init.headers as Headers).get('Idempotency-Key')).toBe('idem-escalate');\n    expect(calls[4]!.init.method).toBe('POST');\n  });\n\n  it('passes body for createApproval with idempotency key', async () => {\n    const { calls, fetchImpl } = createJsonFetch({\n      schemaVersion: 1,\n      approvalId: 'approval-2',\n      workspaceId: 'workspace-1',\n      runId: 'run-1',\n      planId: 'plan-1',\n      prompt: 'Need approval',\n      status: 'Pending',\n      requestedAtIso: '2026-01-01T00:00:00Z',\n      requestedByUserId: 'user-1',\n    });\n    const client = makeClient(fetchImpl);\n\n    await client.createApproval(\n      'workspace-1',\n      { runId: 'run-1', planId: 'plan-1', prompt: 'Need approval' },\n      'idempotency-create',\n    );\n\n    const call = calls[0]!;\n    expect(new URL(call.input).pathname).toBe('/v1/workspaces/workspace-1/approvals');\n    expect(call.init.method).toBe('POST');\n    expect((call.init.headers as Headers).get('Idempotency-Key')).toBe('idempotency-create');\n    expect(JSON.parse(call.init.body as string)).toEqual({\n      runId: 'run-1',\n      planId: 'plan-1',\n      prompt: 'Need approval',\n    });\n  });\n\n  it('builds getRun, cancelRun, getWorkItem, updateWorkItem, getApproval routes', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ id: 'any' });\n    const client = makeClient(fetchImpl);\n\n    await client.getRun('ws', 'run-42');\n    await client.cancelRun('ws', 'run-42');\n    await client.getWorkItem('ws', 'wi-7');\n    await client.updateWorkItem('ws', 'wi-7', { title: 'Updated' });\n    await client.getApproval('ws', 'appr-9');\n\n    const paths = calls.map((c) => new URL(c.input).pathname);\n    expect(paths[0]).toBe('/v1/workspaces/ws/runs/run-42');\n    expect(calls[0]!.init.method).toBe('GET');\n    expect(paths[1]).toBe('/v1/workspaces/ws/runs/run-42/cancel');\n    expect(calls[1]!.init.method).toBe('POST');\n    expect(paths[2]).toBe('/v1/workspaces/ws/work-items/wi-7');\n    expect(calls[2]!.init.method).toBe('GET');\n    expect(paths[3]).toBe('/v1/workspaces/ws/work-items/wi-7');\n    expect(calls[3]!.init.method).toBe('PATCH');\n    expect(paths[4]).toBe('/v1/workspaces/ws/approvals/appr-9');\n    expect(calls[4]!.init.method).toBe('GET');\n  });\n\n  it('builds listEvidence with all filter params', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [], nextCursor: null });\n    const client = makeClient(fetchImpl);\n\n    await client.listEvidence('ws', {\n      runId: 'run-1',\n      planId: 'plan-1',\n      workItemId: 'wi-1',\n      category: 'Approval',\n      limit: 50,\n    });\n\n    const search = new URL(calls[0]!.input).searchParams;\n    expect(search.get('runId')).toBe('run-1');\n    expect(search.get('planId')).toBe('plan-1');\n    expect(search.get('workItemId')).toBe('wi-1');\n    expect(search.get('category')).toBe('Approval');\n    expect(search.get('limit')).toBe('50');\n  });\n\n  it('percent-encodes workspace IDs and resource IDs with special characters', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ items: [] });\n    const client = makeClient(fetchImpl);\n\n    await client.listRuns('ws/with spaces');\n    await client.getRun('ws', 'run/with spaces');\n\n    expect(new URL(calls[0]!.input).pathname).toBe('/v1/workspaces/ws%2Fwith%20spaces/runs');\n    expect(new URL(calls[1]!.input).pathname).toBe('/v1/workspaces/ws/runs/run%2Fwith%20spaces');\n  });\n\n  it('startRun sends idempotency key when provided', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ runId: 'r-1' });\n    const client = makeClient(fetchImpl);\n\n    await client.startRun('ws', { workflowId: 'wf-1' }, 'idem-start');\n\n    const call = calls[0]!;\n    expect(new URL(call.input).pathname).toBe('/v1/workspaces/ws/runs');\n    expect(call.init.method).toBe('POST');\n    expect((call.init.headers as Headers).get('Idempotency-Key')).toBe('idem-start');\n  });\n\n  it('startRun omits idempotency key when not provided', async () => {\n    const { calls, fetchImpl } = createJsonFetch({ runId: 'r-1' });\n    const client = makeClient(fetchImpl);\n\n    await client.startRun('ws', { workflowId: 'wf-1' });\n\n    expect((calls[0]!.init.headers as Headers).get('Idempotency-Key')).toBeNull();\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Error response handling\n// ---------------------------------------------------------------------------\n\ndescribe('ControlPlaneClient error response handling', () => {\n  it('throws ProblemDetailsError when server returns RFC 9457 Problem Details', async () => {\n    const problem = {\n      type: 'https://portarium.dev/problems/approval-not-found',\n      title: 'Approval Not Found',\n      status: 404,\n      detail: 'No approval with id appr-99 found',\n      instance: '/v1/workspaces/ws/approvals/appr-99',\n    };\n    const client = makeClient(createErrorFetch(404, JSON.stringify(problem)));\n\n    const error = await client.getApproval('ws', 'appr-99').catch((e) => e);\n    expect(error).toBeInstanceOf(ProblemDetailsError);\n    expect((error as ProblemDetailsError).status).toBe(404);\n    expect((error as ProblemDetailsError).problem.type).toBe(\n      'https://portarium.dev/problems/approval-not-found',\n    );\n    expect((error as ProblemDetailsError).problem.detail).toBe('No approval with id appr-99 found');\n  });\n\n  it('throws ControlPlaneClientError for non-Problem Details 4xx responses', async () => {\n    const client = makeClient(createErrorFetch(422, 'Unprocessable Entity'));\n\n    const error = await client.listRuns('ws').catch((e) => e);\n    expect(error).toBeInstanceOf(ControlPlaneClientError);\n    expect((error as ControlPlaneClientError).status).toBe(422);\n    expect((error as ControlPlaneClientError).body).toBe('Unprocessable Entity');\n  });\n\n  it('throws ControlPlaneClientError for 500 server errors', async () => {\n    const client = makeClient(createErrorFetch(500, 'Internal Server Error'));\n\n    const error = await client.listApprovals('ws').catch((e) => e);\n    expect(error).toBeInstanceOf(ControlPlaneClientError);\n    expect((error as ControlPlaneClientError).status).toBe(500);\n  });\n\n  it('throws ControlPlaneClientError for empty 4xx body', async () => {\n    const client = makeClient(createErrorFetch(403, ''));\n\n    const error = await client.listRuns('ws').catch((e) => e);\n    expect(error).toBeInstanceOf(ControlPlaneClientError);\n    expect((error as ControlPlaneClientError).status).toBe(403);\n    expect((error as ControlPlaneClientError).body).toBe('');\n  });\n\n  it('throws ControlPlaneClientError when response body is not valid JSON', async () => {\n    // Use a fetch that returns malformed JSON (not parseable)\n    const badFetch = (async () =>\n      ({\n        ok: true,\n        status: 200,\n        headers: new Headers(),\n        text: async () => '{{bad json',\n      }) as Response) as typeof fetch;\n    const client = makeClient(badFetch);\n\n    const error = await client.listRuns('ws').catch((e) => e);\n    expect(error).toBeInstanceOf(ControlPlaneClientError);\n    expect((error as ControlPlaneClientError).body).toBe('Invalid JSON response');\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Response parsing edge cases\n// ---------------------------------------------------------------------------\n\ndescribe('ControlPlaneClient response parsing', () => {\n  it('returns undefined for 204 No Content responses', async () => {\n    const client = makeClient(createEmptyFetch(204));\n    const result = await client.cancelRun('ws', 'run-1');\n    expect(result).toBeUndefined();\n  });\n\n  it('returns undefined for empty 200 body', async () => {\n    const client = makeClient(createEmptyFetch(200));\n    const result = await client.cancelRun('ws', 'run-1');\n    expect(result).toBeUndefined();\n  });\n\n  it('passes response through parse function when provided', async () => {\n    // Access via internal request  test through a public method that uses parse indirectly\n    // Verify that valid JSON is correctly passed back as-is (default identity parse)\n    const payload = { items: [{ id: 'wi-1' }], nextCursor: 'next:xyz' };\n    const { fetchImpl } = createJsonFetch(payload);\n    const client = makeClient(fetchImpl);\n\n    const result = await client.listWorkItems('ws');\n    expect(result).toEqual(payload);\n  });\n});\n\n// Auth and timeout tests are in http-client-auth.test.ts (split for max-lines compliance)\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\http-client.ts","messages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (493). Maximum allowed is 350.","line":388,"column":1,"nodeType":null,"messageId":"exceed","endLine":552,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isProblemDetails, ProblemDetailsError } from './problem-details.js';\nimport { buildCursorQuery } from './pagination.js';\nimport type {\n  ApprovalDecisionRequest,\n  ApprovalSummary,\n  AssignHumanTaskRequest,\n  CompleteHumanTaskRequest,\n  CursorPage,\n  CursorPaginationRequest,\n  CreateApprovalRequest,\n  CreateWorkItemCommand,\n  EvidenceEntry,\n  EscalateHumanTaskRequest,\n  HumanTaskSummary,\n  ListApprovalsRequest,\n  ListEvidenceRequest,\n  ListHumanTasksRequest,\n  ListRunsRequest,\n  ListWorkItemsRequest,\n  Plan,\n  PatchWorkforceAvailabilityRequest,\n  RunDetail,\n  RunSummary,\n  StartRunCommand,\n  ListWorkforceMembersRequest,\n  ListWorkforceQueuesRequest,\n  UpdateWorkItemCommand,\n  WorkforceMemberSummary,\n  WorkforceQueueSummary,\n  WorkItemSummary,\n} from './types.js';\n\nconst DEFAULT_REQUEST_TIMEOUT_MS = 30_000;\n\nexport interface ControlPlaneClientConfig {\n  baseUrl: string;\n  getAuthToken?: () => string | Promise<string>;\n  fetchImpl?: typeof fetch;\n  defaultHeaders?: Record<string, string>;\n  requestTimeoutMs?: number;\n}\n\nexport class ControlPlaneClientError extends Error {\n  public readonly status: number;\n  public readonly body: string;\n\n  constructor(status: number, body: string) {\n    super(`Control Plane request failed with status ${status}.`);\n    this.name = 'ControlPlaneClientError';\n    this.status = status;\n    this.body = body;\n  }\n}\n\ntype HttpMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';\n\ntype ParseFn<T> = (value: unknown) => T;\n\ninterface ApiRequestOptions<T = never> {\n  query?: URLSearchParams;\n  body?: unknown;\n  idempotencyKey?: string;\n  parse?: ParseFn<T>;\n  signal?: AbortSignal;\n}\n\nexport class ControlPlaneClient {\n  private readonly baseUrl: string;\n  private readonly fetchImpl: typeof fetch;\n  private readonly requestTimeoutMs: number;\n  private readonly defaultHeaders: Record<string, string>;\n  private readonly getAuthToken: (() => string | Promise<string>) | undefined;\n\n  constructor(config: ControlPlaneClientConfig) {\n    this.baseUrl = config.baseUrl.endsWith('/') ? config.baseUrl : `${config.baseUrl}/`;\n    this.fetchImpl = config.fetchImpl ?? fetch;\n    this.requestTimeoutMs = config.requestTimeoutMs ?? DEFAULT_REQUEST_TIMEOUT_MS;\n    this.defaultHeaders = config.defaultHeaders ?? {};\n    this.getAuthToken = config.getAuthToken;\n  }\n\n  public async listRuns(\n    workspaceId: string,\n    request: ListRunsRequest = {},\n  ): Promise<CursorPage<RunSummary>> {\n    const query = this.buildListRunsQuery(request);\n    return this.request<CursorPage<RunSummary>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/runs`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async getRun(workspaceId: string, runId: string): Promise<RunDetail> {\n    return this.request<RunDetail>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/runs/${normalizeResourceId(runId)}`,\n      'GET',\n    );\n  }\n\n  public async startRun(\n    workspaceId: string,\n    command: StartRunCommand,\n    idempotencyKey?: string,\n  ): Promise<RunDetail> {\n    return this.request<RunDetail>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/runs`,\n      'POST',\n      { body: command, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  public async cancelRun(workspaceId: string, runId: string): Promise<RunDetail> {\n    return this.request<RunDetail>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/runs/${normalizeResourceId(runId)}/cancel`,\n      'POST',\n    );\n  }\n\n  public async listWorkItems(\n    workspaceId: string,\n    request: ListWorkItemsRequest = {},\n  ): Promise<CursorPage<WorkItemSummary>> {\n    const query = this.buildListWorkItemsQuery(request);\n    return this.request<CursorPage<WorkItemSummary>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/work-items`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async createWorkItem(\n    workspaceId: string,\n    command: CreateWorkItemCommand,\n    idempotencyKey?: string,\n  ): Promise<WorkItemSummary> {\n    return this.request<WorkItemSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/work-items`,\n      'POST',\n      { body: command, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  public async getWorkItem(workspaceId: string, workItemId: string): Promise<WorkItemSummary> {\n    return this.request<WorkItemSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/work-items/${normalizeResourceId(workItemId)}`,\n      'GET',\n    );\n  }\n\n  public async updateWorkItem(\n    workspaceId: string,\n    workItemId: string,\n    command: UpdateWorkItemCommand,\n  ): Promise<WorkItemSummary> {\n    return this.request<WorkItemSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/work-items/${normalizeResourceId(workItemId)}`,\n      'PATCH',\n      { body: command },\n    );\n  }\n\n  public async getPlan(workspaceId: string, planId: string): Promise<Plan> {\n    return this.request<Plan>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/plans/${normalizeResourceId(planId)}`,\n      'GET',\n    );\n  }\n\n  public async listEvidence(\n    workspaceId: string,\n    request: ListEvidenceRequest = {},\n  ): Promise<CursorPage<EvidenceEntry>> {\n    const query = this.buildListEvidenceQuery(request);\n    return this.request<CursorPage<EvidenceEntry>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/evidence`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async listRunEvidence(\n    workspaceId: string,\n    runId: string,\n    request: CursorPaginationRequest = {},\n  ): Promise<CursorPage<EvidenceEntry>> {\n    const query = this.buildCursorQuery(request);\n    return this.request<CursorPage<EvidenceEntry>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/runs/${normalizeResourceId(runId)}/evidence`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async listApprovals(\n    workspaceId: string,\n    request: ListApprovalsRequest = {},\n  ): Promise<CursorPage<ApprovalSummary>> {\n    const query = this.buildCursorQuery(request);\n    return this.request<CursorPage<ApprovalSummary>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/approvals`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async createApproval(\n    workspaceId: string,\n    request: CreateApprovalRequest,\n    idempotencyKey?: string,\n  ): Promise<ApprovalSummary> {\n    return this.request<ApprovalSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/approvals`,\n      'POST',\n      { body: request, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  public async getApproval(workspaceId: string, approvalId: string): Promise<ApprovalSummary> {\n    return this.request<ApprovalSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/approvals/${normalizeResourceId(approvalId)}`,\n      'GET',\n    );\n  }\n\n  public async decideApproval(\n    workspaceId: string,\n    approvalId: string,\n    request: ApprovalDecisionRequest & { idempotencyKey?: string },\n  ): Promise<ApprovalSummary> {\n    const { idempotencyKey, ...body } = request;\n\n    return this.request<ApprovalSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/approvals/${normalizeResourceId(approvalId)}/decide`,\n      'POST',\n      { body, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  public async listWorkforceMembers(\n    workspaceId: string,\n    request: ListWorkforceMembersRequest = {},\n  ): Promise<CursorPage<WorkforceMemberSummary>> {\n    const query = this.buildListWorkforceMembersQuery(request);\n    return this.request<CursorPage<WorkforceMemberSummary>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/workforce`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async getWorkforceMember(\n    workspaceId: string,\n    workforceMemberId: string,\n  ): Promise<WorkforceMemberSummary> {\n    return this.request<WorkforceMemberSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/workforce/${normalizeResourceId(workforceMemberId)}`,\n      'GET',\n    );\n  }\n\n  public async patchWorkforceMemberAvailability(\n    workspaceId: string,\n    workforceMemberId: string,\n    request: PatchWorkforceAvailabilityRequest,\n  ): Promise<WorkforceMemberSummary> {\n    return this.request<WorkforceMemberSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/workforce/${normalizeResourceId(workforceMemberId)}/availability`,\n      'PATCH',\n      { body: request },\n    );\n  }\n\n  public async listWorkforceQueues(\n    workspaceId: string,\n    request: ListWorkforceQueuesRequest = {},\n  ): Promise<CursorPage<WorkforceQueueSummary>> {\n    const query = this.buildListWorkforceQueuesQuery(request);\n    return this.request<CursorPage<WorkforceQueueSummary>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/workforce/queues`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async listHumanTasks(\n    workspaceId: string,\n    request: ListHumanTasksRequest = {},\n  ): Promise<CursorPage<HumanTaskSummary>> {\n    const query = this.buildListHumanTasksQuery(request);\n    return this.request<CursorPage<HumanTaskSummary>>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/human-tasks`,\n      'GET',\n      { query },\n    );\n  }\n\n  public async getHumanTask(workspaceId: string, humanTaskId: string): Promise<HumanTaskSummary> {\n    return this.request<HumanTaskSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/human-tasks/${normalizeResourceId(humanTaskId)}`,\n      'GET',\n    );\n  }\n\n  public async assignHumanTask(\n    workspaceId: string,\n    humanTaskId: string,\n    request: AssignHumanTaskRequest,\n    idempotencyKey?: string,\n  ): Promise<HumanTaskSummary> {\n    return this.request<HumanTaskSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/human-tasks/${normalizeResourceId(humanTaskId)}/assign`,\n      'POST',\n      { body: request, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  public async completeHumanTask(\n    workspaceId: string,\n    humanTaskId: string,\n    request: CompleteHumanTaskRequest = {},\n    idempotencyKey?: string,\n  ): Promise<HumanTaskSummary> {\n    return this.request<HumanTaskSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/human-tasks/${normalizeResourceId(humanTaskId)}/complete`,\n      'POST',\n      { body: request, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  public async escalateHumanTask(\n    workspaceId: string,\n    humanTaskId: string,\n    request: EscalateHumanTaskRequest,\n    idempotencyKey?: string,\n  ): Promise<HumanTaskSummary> {\n    return this.request<HumanTaskSummary>(\n      `/v1/workspaces/${normalizeWorkspaceId(workspaceId)}/human-tasks/${normalizeResourceId(humanTaskId)}/escalate`,\n      'POST',\n      { body: request, ...(idempotencyKey ? { idempotencyKey } : {}) },\n    );\n  }\n\n  private buildListRunsQuery(request: ListRunsRequest): URLSearchParams {\n    const query = buildCursorQuery(request).query;\n    if (request.status) query.set('status', request.status);\n    if (request.workflowId) query.set('workflowId', request.workflowId);\n    if (request.initiatedByUserId) query.set('initiatedByUserId', request.initiatedByUserId);\n    if (request.correlationId) query.set('correlationId', request.correlationId);\n    if (request.sort) query.set('sort', request.sort);\n    if (request.q) query.set('q', request.q);\n    return query;\n  }\n\n  private buildListWorkItemsQuery(request: ListWorkItemsRequest): URLSearchParams {\n    const query = buildCursorQuery(request).query;\n    if (request.status) {\n      query.set('status', request.status);\n    }\n    if (request.ownerUserId) {\n      query.set('ownerUserId', request.ownerUserId);\n    }\n    if (request.runId) {\n      query.set('runId', request.runId);\n    }\n    if (request.workflowId) {\n      query.set('workflowId', request.workflowId);\n    }\n    if (request.approvalId) {\n      query.set('approvalId', request.approvalId);\n    }\n    if (request.evidenceId) {\n      query.set('evidenceId', request.evidenceId);\n    }\n    return query;\n  }\n\n  private buildListEvidenceQuery(request: ListEvidenceRequest): URLSearchParams {\n    const query = buildCursorQuery(request).query;\n    if (request.runId) {\n      query.set('runId', request.runId);\n    }\n    if (request.planId) {\n      query.set('planId', request.planId);\n    }\n    if (request.workItemId) {\n      query.set('workItemId', request.workItemId);\n    }\n    if (request.category) {\n      query.set('category', request.category);\n    }\n    return query;\n  }\n\n  private buildListWorkforceMembersQuery(request: ListWorkforceMembersRequest): URLSearchParams {\n    const query = this.buildCursorQuery(request);\n    if (request.capability) {\n      query.set('capability', request.capability);\n    }\n    if (request.queueId) {\n      query.set('queueId', request.queueId);\n    }\n    if (request.availability) {\n      query.set('availability', request.availability);\n    }\n    return query;\n  }\n\n  private buildListWorkforceQueuesQuery(request: ListWorkforceQueuesRequest): URLSearchParams {\n    const query = this.buildCursorQuery(request);\n    if (request.capability) {\n      query.set('capability', request.capability);\n    }\n    return query;\n  }\n\n  private buildListHumanTasksQuery(request: ListHumanTasksRequest): URLSearchParams {\n    const query = this.buildCursorQuery(request);\n    if (request.assigneeId) {\n      query.set('assigneeId', request.assigneeId);\n    }\n    if (request.status) {\n      query.set('status', request.status);\n    }\n    if (request.runId) {\n      query.set('runId', request.runId);\n    }\n    return query;\n  }\n\n  protected buildCursorQuery(request: CursorPaginationRequest): URLSearchParams {\n    return buildCursorQuery(request).query;\n  }\n\n  protected async request<T>(\n    path: string,\n    method: HttpMethod,\n    options: ApiRequestOptions<T> = {},\n  ): Promise<T> {\n    const headers = await this.buildHeaders(Boolean(options.body), options.idempotencyKey);\n    const url = this.buildUrl(path, options.query);\n    const body = this.normalizeBody(options.body);\n    const controller = new AbortController();\n    const timeout = setTimeout(() => {\n      controller.abort();\n    }, this.requestTimeoutMs);\n\n    try {\n      const requestInit: RequestInit = {\n        method,\n        headers,\n        signal: options.signal ?? controller.signal,\n      };\n      if (body !== undefined) {\n        requestInit.body = body;\n      }\n      const response = await this.fetchImpl(url, requestInit);\n\n      if (!response.ok) {\n        await this.throwResponseError(response);\n      }\n\n      if (response.status === 204) {\n        return undefined as T;\n      }\n\n      const responseText = await response.text();\n      if (!responseText) {\n        return undefined as T;\n      }\n\n      const parsed = safeJsonParse(responseText);\n      if (!parsed) {\n        throw new ControlPlaneClientError(response.status, 'Invalid JSON response');\n      }\n\n      const parse = options.parse ?? ((value: unknown): T => value as T);\n      return parse(parsed);\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n\n  private async throwResponseError(response: Response): Promise<never> {\n    const bodyText = await response.text();\n    const parsed = safeJsonParse(bodyText);\n    if (parsed && isProblemDetails(parsed)) {\n      throw new ProblemDetailsError(parsed);\n    }\n    throw new ControlPlaneClientError(response.status, bodyText);\n  }\n\n  private async buildHeaders(hasJsonBody: boolean, idempotencyKey?: string): Promise<Headers> {\n    const headers = new Headers(this.defaultHeaders);\n    headers.set('Accept', 'application/json');\n    headers.set('X-Client', 'portarium-presentation');\n\n    if (hasJsonBody) {\n      headers.set('Content-Type', 'application/json');\n    }\n    if (hasValue(idempotencyKey)) {\n      headers.set('Idempotency-Key', idempotencyKey);\n    }\n    if (this.getAuthToken) {\n      const token = await this.getAuthToken();\n      if (hasValue(token)) {\n        headers.set('Authorization', `Bearer ${token}`);\n      }\n    }\n\n    return headers;\n  }\n\n  private buildUrl(path: string, query?: URLSearchParams): string {\n    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;\n    const url = new URL(normalizedPath, this.baseUrl);\n    if (query) {\n      query.forEach((value, key) => {\n        url.searchParams.set(key, value);\n      });\n    }\n    return url.toString();\n  }\n\n  private normalizeBody(body?: unknown): string | undefined {\n    if (body === undefined) return undefined;\n    if (typeof body === 'string') return body;\n    return JSON.stringify(body);\n  }\n}\n\nfunction safeJsonParse(input: string): unknown {\n  if (!input) return null;\n  try {\n    return JSON.parse(input);\n  } catch {\n    return null;\n  }\n}\n\nfunction normalizeWorkspaceId(workspaceId: string): string {\n  return encodeURIComponent(workspaceId);\n}\n\nfunction normalizeResourceId(resourceId: string): string {\n  return encodeURIComponent(resourceId);\n}\n\nfunction hasValue(input: string | undefined): input is string {\n  return typeof input === 'string' && input.length > 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\machine-agent-client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\machine-agent-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\pagination.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\pagination.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\problem-details.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\problem-details.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\ops-cockpit\\types.ts","messages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (443). Maximum allowed is 350.","line":410,"column":1,"nodeType":null,"messageId":"exceed","endLine":539,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type CursorToken = string;\n\nexport type EffectOperation = 'Create' | 'Update' | 'Delete' | 'Upsert';\n\nexport interface ExternalObjectRef {\n  sorName: string;\n  portFamily: string;\n  externalId: string;\n  externalType: string;\n  displayLabel?: string;\n  deepLinkUrl?: string;\n}\n\nexport interface PlanEffect {\n  effectId: string;\n  operation: EffectOperation;\n  target: ExternalObjectRef;\n  summary: string;\n  idempotencyKey?: string;\n}\n\nexport interface PredictedPlanEffect extends PlanEffect {\n  confidence?: number;\n}\n\nexport interface Plan {\n  schemaVersion: number;\n  planId: string;\n  workspaceId: string;\n  createdAtIso: string;\n  createdByUserId: string;\n  plannedEffects: PlanEffect[];\n  predictedEffects?: PredictedPlanEffect[];\n}\n\nexport interface PlanSection {\n  title: string;\n  guidance: string;\n  effects: PlanEffect[];\n}\n\nexport type RunStatus =\n  | 'Pending'\n  | 'Running'\n  | 'WaitingForApproval'\n  | 'Paused'\n  | 'Succeeded'\n  | 'Failed'\n  | 'Cancelled';\n\nexport interface RunSummary {\n  schemaVersion: number;\n  runId: string;\n  workspaceId: string;\n  workflowId: string;\n  correlationId: string;\n  executionTier: 'Auto' | 'Assisted' | 'HumanApprove' | 'ManualOnly';\n  initiatedByUserId: string;\n  status: RunStatus;\n  createdAtIso: string;\n  startedAtIso?: string;\n  endedAtIso?: string;\n  agentIds?: string[];\n  robotIds?: string[];\n  workforceMemberIds?: string[];\n}\n\nexport type RunDetail = RunSummary;\n\nexport type WorkflowTriggerKind = 'Manual' | 'Cron' | 'Webhook' | 'DomainEvent';\n\nexport interface WorkflowActionSummary {\n  actionId: string;\n  order: number;\n  portFamily: string;\n  operation: string;\n  executionTierOverride?: RunSummary['executionTier'];\n}\n\nexport interface WorkflowRetryPolicy {\n  maxAttempts: number;\n  initialBackoffMs: number;\n  maxBackoffMs: number;\n  backoffMultiplier: number;\n}\n\nexport interface WorkflowSummary {\n  schemaVersion: number;\n  workflowId: string;\n  workspaceId: string;\n  name: string;\n  description?: string;\n  version: number;\n  active: boolean;\n  executionTier: RunSummary['executionTier'];\n  actions: WorkflowActionSummary[];\n  triggerKind?: WorkflowTriggerKind;\n  timeoutMs?: number;\n  retryPolicy?: WorkflowRetryPolicy;\n  compensationMode?: 'best-effort' | 'strict' | 'none';\n}\n\nexport type WorkflowDetail = WorkflowSummary;\n\nexport interface WorkItemSla {\n  dueAtIso?: string;\n}\n\nexport interface WorkItemLinks {\n  externalRefs?: ExternalObjectRef[];\n  runIds?: string[];\n  workflowIds?: string[];\n  approvalIds?: string[];\n  evidenceIds?: string[];\n}\n\nexport interface WorkItemSummary {\n  schemaVersion: number;\n  workItemId: string;\n  workspaceId: string;\n  createdAtIso: string;\n  createdByUserId: string;\n  title: string;\n  status: 'Open' | 'Closed';\n  ownerUserId?: string;\n  sla?: WorkItemSla;\n  links?: WorkItemLinks;\n}\n\nexport type EvidenceCategory = 'Plan' | 'Action' | 'Approval' | 'Policy' | 'System';\n\nexport interface EvidenceLinks {\n  runId?: string;\n  planId?: string;\n  workItemId?: string;\n  externalRefs?: ExternalObjectRef[];\n}\n\nexport interface EvidencePayloadRef {\n  kind: 'Artifact' | 'Snapshot' | 'Diff' | 'Log';\n  uri: string;\n  contentType?: string;\n  sha256?: string;\n}\n\nexport interface EvidenceActorUser {\n  kind: 'User';\n  userId: string;\n}\n\nexport interface EvidenceActorMachine {\n  kind: 'Machine';\n  machineId: string;\n}\n\nexport interface EvidenceActorAdapter {\n  kind: 'Adapter';\n  adapterId: string;\n}\n\nexport interface EvidenceActorSystem {\n  kind: 'System';\n}\n\nexport type EvidenceActor =\n  | EvidenceActorUser\n  | EvidenceActorMachine\n  | EvidenceActorAdapter\n  | EvidenceActorSystem;\n\nexport interface EvidenceEntry {\n  schemaVersion: number;\n  evidenceId: string;\n  workspaceId: string;\n  occurredAtIso: string;\n  category: EvidenceCategory;\n  summary: string;\n  actor: EvidenceActor;\n  links?: EvidenceLinks;\n  payloadRefs?: EvidencePayloadRef[];\n  previousHash?: string;\n  hashSha256: string;\n}\n\nexport type ApprovalStatus = 'Pending' | 'Approved' | 'Denied' | 'RequestChanges';\n\nexport type SodState = 'eligible' | 'blocked-self' | 'blocked-role' | 'n-of-m';\n\nexport interface SodEvaluation {\n  state: SodState;\n  requestorId: string;\n  ruleId: string;\n  rolesRequired: string[];\n  nRequired?: number;\n  nTotal?: number;\n  nSoFar?: number;\n}\n\nexport interface PolicyRule {\n  ruleId: string;\n  trigger: string;\n  tier: string;\n  blastRadius: string[];\n  irreversibility: 'full' | 'partial' | 'none';\n}\n\nexport interface DecisionHistoryEntry {\n  timestamp: string;\n  type: 'requested' | 'changes_requested' | 'resubmitted';\n  actor: string;\n  message: string;\n}\n\nexport interface ApprovalSummary {\n  schemaVersion: number;\n  approvalId: string;\n  workspaceId: string;\n  runId: string;\n  planId: string;\n  workItemId?: string;\n  prompt: string;\n  status: ApprovalStatus;\n  requestedAtIso: string;\n  requestedByUserId: string;\n  assigneeUserId?: string;\n  dueAtIso?: string;\n  decidedAtIso?: string;\n  decidedByUserId?: string;\n  rationale?: string;\n  sodEvaluation?: SodEvaluation;\n  policyRule?: PolicyRule;\n  decisionHistory?: DecisionHistoryEntry[];\n}\n\nexport interface CredentialGrantV1 {\n  schemaVersion: 1;\n  credentialGrantId: string;\n  workspaceId: string;\n  adapterId: string;\n  credentialsRef: string;\n  scope: string;\n  issuedAtIso: string;\n  expiresAtIso?: string;\n  lastRotatedAtIso?: string;\n  revokedAtIso?: string;\n}\n\nexport interface CreateCredentialGrantRequest {\n  adapterId: string;\n  credentialsRef: string;\n  scope: string;\n  expiresAtIso?: string;\n}\n\nexport type WorkforceAvailabilityStatus = 'available' | 'busy' | 'offline';\n\nexport type WorkforceCapability =\n  | 'operations.dispatch'\n  | 'operations.approval'\n  | 'operations.escalation'\n  | 'robotics.supervision'\n  | 'robotics.safety.override';\n\nexport interface WorkforceMemberSummary {\n  schemaVersion: 1;\n  workforceMemberId: string;\n  linkedUserId: string;\n  displayName: string;\n  capabilities: WorkforceCapability[];\n  availabilityStatus: WorkforceAvailabilityStatus;\n  queueMemberships: string[];\n  tenantId: string;\n  createdAtIso: string;\n  updatedAtIso?: string;\n}\n\nexport interface WorkforceQueueSummary {\n  schemaVersion: 1;\n  workforceQueueId: string;\n  name: string;\n  requiredCapabilities: WorkforceCapability[];\n  memberIds: string[];\n  routingStrategy: 'round-robin' | 'least-busy' | 'manual';\n  tenantId: string;\n}\n\nexport type HumanTaskStatus = 'pending' | 'assigned' | 'in-progress' | 'completed' | 'escalated';\n\nexport interface HumanTaskSummary {\n  schemaVersion: 1;\n  humanTaskId: string;\n  workItemId: string;\n  runId: string;\n  stepId: string;\n  assigneeId?: string;\n  groupId?: string;\n  description: string;\n  requiredCapabilities: WorkforceCapability[];\n  status: HumanTaskStatus;\n  dueAt?: string;\n  completedAt?: string;\n  completedById?: string;\n  evidenceAnchorId?: string;\n}\n\nexport interface CursorPage<T> {\n  items: T[];\n  nextCursor?: CursorToken;\n}\n\nexport interface CursorPaginationRequest {\n  limit?: number;\n  cursor?: CursorToken;\n}\n\nexport interface ListRunsRequest extends CursorPaginationRequest {\n  status?: RunStatus;\n  workflowId?: string;\n  initiatedByUserId?: string;\n  correlationId?: string;\n  sort?: string;\n  q?: string;\n}\n\nexport interface ListWorkItemsRequest extends CursorPaginationRequest {\n  status?: WorkItemSummary['status'];\n  ownerUserId?: string;\n  runId?: string;\n  workflowId?: string;\n  approvalId?: string;\n  evidenceId?: string;\n}\n\nexport type ListApprovalsRequest = CursorPaginationRequest;\n\nexport interface ListEvidenceRequest extends CursorPaginationRequest {\n  runId?: string;\n  planId?: string;\n  workItemId?: string;\n  category?: EvidenceCategory;\n}\n\nexport interface ListWorkforceMembersRequest extends CursorPaginationRequest {\n  capability?: WorkforceCapability;\n  queueId?: string;\n  availability?: WorkforceAvailabilityStatus;\n}\n\nexport interface ListWorkforceQueuesRequest extends CursorPaginationRequest {\n  capability?: WorkforceCapability;\n}\n\nexport interface PatchWorkforceAvailabilityRequest {\n  availabilityStatus: WorkforceAvailabilityStatus;\n}\n\nexport interface ListHumanTasksRequest extends CursorPaginationRequest {\n  assigneeId?: string;\n  status?: HumanTaskStatus;\n  runId?: string;\n}\n\nexport interface AssignHumanTaskRequest {\n  workforceMemberId?: string;\n  workforceQueueId?: string;\n}\n\nexport interface CompleteHumanTaskRequest {\n  completionNote?: string;\n}\n\nexport interface EscalateHumanTaskRequest {\n  workforceQueueId: string;\n  reason?: string;\n}\n\nexport type ApprovalDecision = 'Approved' | 'Denied' | 'RequestChanges';\n\nexport interface ApprovalDecisionRequest {\n  decision: ApprovalDecision;\n  rationale: string;\n}\n\nexport interface CreateWorkItemCommand {\n  title: string;\n  ownerUserId?: string;\n  sla?: WorkItemSla;\n  externalRefs?: ExternalObjectRef[];\n}\n\nexport interface UpdateWorkItemCommand {\n  title?: string;\n  status?: WorkItemSummary['status'];\n  ownerUserId?: string;\n  sla?: WorkItemSla;\n  externalRefs?: ExternalObjectRef[];\n}\n\nexport interface CreateApprovalRequest {\n  runId: string;\n  planId: string;\n  workItemId?: string;\n  prompt: string;\n  assigneeUserId?: string;\n  dueAtIso?: string;\n}\n\nexport interface StartRunCommand {\n  workflowId: string;\n  parameters?: Record<string, unknown>;\n}\n\n// ---------------------------------------------------------------------------\n// Machines (bead-0438)\n// ---------------------------------------------------------------------------\n\nexport type AgentCapability =\n  | 'read:external'\n  | 'write:external'\n  | 'classify'\n  | 'generate'\n  | 'analyze'\n  | 'execute-code'\n  | 'notify'\n  | 'machine:invoke';\n\nexport type ConnectionTestStatus = 'ok' | 'slow' | 'unreachable';\n\nexport interface ConnectionTestResult {\n  status: ConnectionTestStatus;\n  latencyMs: number;\n  errorMessage?: string;\n}\n\nexport type MachineStatus = 'Online' | 'Degraded' | 'Offline';\n\nexport interface MachineV1 {\n  schemaVersion: 1;\n  machineId: string;\n  workspaceId: string;\n  hostname: string;\n  osImage?: string;\n  registeredAtIso: string;\n  lastHeartbeatAtIso?: string;\n  status: MachineStatus;\n  activeRunCount?: number;\n  allowedCapabilities?: AgentCapability[];\n}\n\nexport interface RegisterMachineRequest {\n  hostname: string;\n  osImage?: string;\n  allowedCapabilities?: AgentCapability[];\n}\n\nexport type ListMachinesRequest = CursorPaginationRequest;\n\n// ---------------------------------------------------------------------------\n// Agents (bead-0439)\n// ---------------------------------------------------------------------------\n\nexport interface AgentV1 {\n  schemaVersion: 1;\n  agentId: string;\n  workspaceId: string;\n  name: string;\n  modelId?: string;\n  endpoint: string;\n  allowedCapabilities: AgentCapability[];\n  usedByWorkflowIds?: string[];\n}\n\nexport interface RegisterAgentRequest {\n  name: string;\n  modelId?: string;\n  endpoint: string;\n  allowedCapabilities?: AgentCapability[];\n}\n\nexport interface UpdateAgentRequest {\n  name?: string;\n  endpoint?: string;\n  allowedCapabilities?: AgentCapability[];\n}\n\nexport type ListAgentsRequest = CursorPaginationRequest;\n\n// ---------------------------------------------------------------------------\n// Policies & SoD Constraints\n// ---------------------------------------------------------------------------\n\nexport interface PolicyCondition {\n  field: string;\n  operator: 'eq' | 'neq' | 'in' | 'gt' | 'lt';\n  value: string;\n}\n\nexport interface PolicySummary {\n  policyId: string;\n  name: string;\n  description: string;\n  status: 'Active' | 'Draft' | 'Archived';\n  ruleText: string;\n  conditions: PolicyCondition[];\n}\n\nexport interface SodConstraint {\n  constraintId: string;\n  name: string;\n  description: string;\n  status: 'Active' | 'Inactive';\n  relatedPolicyIds: string[];\n}\n\n// ---------------------------------------------------------------------------\n// Adapters\n// ---------------------------------------------------------------------------\n\nexport interface AdapterSummary {\n  adapterId: string;\n  name: string;\n  sorFamily: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  lastSyncIso: string;\n}\n\n// ---------------------------------------------------------------------------\n// Robotics Gateways\n// ---------------------------------------------------------------------------\n\nexport interface GatewaySummary {\n  gatewayId: string;\n  url: string;\n  status: 'Online' | 'Offline' | 'Degraded';\n  connectedRobots: number;\n  lastHeartbeatIso: string;\n  region: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.agents.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Function 'parseHeartbeatBody' has a complexity of 11. Maximum allowed is 10.","line":51,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":51,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Machine/agent heartbeat and agent work-item HTTP handlers for the control-plane runtime.\n */\n\nimport type { IncomingMessage, ServerResponse } from 'node:http';\n\nimport type { TraceContext } from '../../application/common/trace-context.js';\nimport {\n  type ControlPlaneDeps,\n  authenticate,\n  assertReadAccess,\n  assertWorkspaceScope,\n  problemFromError,\n  readJsonBody,\n  respondJson,\n  respondProblem,\n} from './control-plane-handler.shared.js';\n\n// ---------------------------------------------------------------------------\n// Body parser\n// ---------------------------------------------------------------------------\n\ntype HeartbeatBody =\n  | {\n      ok: true;\n      status: string;\n      metrics?: Record<string, number>;\n      location?: { lat: number; lon: number };\n    }\n  | { ok: false; message: string };\n\nfunction checkMetrics(metrics: unknown): HeartbeatBody | null {\n  if (metrics !== undefined && metrics !== null) {\n    if (typeof metrics !== 'object' || Array.isArray(metrics))\n      return { ok: false, message: 'metrics must be a record of numbers.' };\n  }\n  return null;\n}\n\nfunction checkLocation(location: unknown): HeartbeatBody | null {\n  if (location !== undefined && location !== null) {\n    if (typeof location !== 'object' || Array.isArray(location))\n      return { ok: false, message: 'location must have lat and lon.' };\n    const loc = location as Record<string, unknown>;\n    if (typeof loc['lat'] !== 'number' || typeof loc['lon'] !== 'number')\n      return { ok: false, message: 'location must have numeric lat and lon.' };\n  }\n  return null;\n}\n\nfunction parseHeartbeatBody(body: unknown): HeartbeatBody {\n  if (typeof body !== 'object' || body === null)\n    return { ok: false, message: 'Request body must be a JSON object.' };\n  const record = body as Record<string, unknown>;\n  const status = record['status'];\n  if (status !== 'ok' && status !== 'degraded')\n    return { ok: false, message: 'status must be \"ok\" or \"degraded\".' };\n  const metricsCheck = checkMetrics(record['metrics']);\n  if (metricsCheck) return metricsCheck;\n  const locationCheck = checkLocation(record['location']);\n  if (locationCheck) return locationCheck;\n  const metrics = record['metrics'];\n  const location = record['location'];\n  return {\n    ok: true,\n    status: status as string,\n    ...(metrics !== undefined && metrics !== null\n      ? { metrics: metrics as Record<string, number> }\n      : {}),\n    ...(location !== undefined && location !== null\n      ? { location: location as { lat: number; lon: number } }\n      : {}),\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Handler arg types\n// ---------------------------------------------------------------------------\n\ntype MachineHeartbeatArgs = Readonly<{\n  deps: ControlPlaneDeps;\n  req: IncomingMessage;\n  res: ServerResponse;\n  correlationId: string;\n  pathname: string;\n  workspaceId: string;\n  machineId: string;\n  traceContext: TraceContext;\n}>;\n\ntype AgentArgs = Readonly<{\n  deps: ControlPlaneDeps;\n  req: IncomingMessage;\n  res: ServerResponse;\n  correlationId: string;\n  pathname: string;\n  workspaceId: string;\n  agentId: string;\n  traceContext: TraceContext;\n}>;\n\n// ---------------------------------------------------------------------------\n// Handlers\n// ---------------------------------------------------------------------------\n\nexport async function handleMachineHeartbeat(args: MachineHeartbeatArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, machineId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const scopeCheck = assertWorkspaceScope(auth.ctx, workspaceId);\n  if (!scopeCheck.ok) {\n    respondProblem(res, problemFromError(scopeCheck.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const parsed = parseHeartbeatBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: parsed.message,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const nowIso = new Date().toISOString();\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: {\n      machineId,\n      lastHeartbeatAtIso: nowIso,\n      status: parsed.status,\n      ...(parsed.metrics ? { metrics: parsed.metrics } : {}),\n      ...(parsed.location ? { location: parsed.location } : {}),\n    },\n  });\n}\n\nexport async function handleAgentHeartbeat(args: AgentArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, agentId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const scopeCheck = assertWorkspaceScope(auth.ctx, workspaceId);\n  if (!scopeCheck.ok) {\n    respondProblem(res, problemFromError(scopeCheck.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const parsed = parseHeartbeatBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: parsed.message,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const nowIso = new Date().toISOString();\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: {\n      agentId,\n      lastHeartbeatAtIso: nowIso,\n      status: parsed.status,\n      ...(parsed.metrics ? { metrics: parsed.metrics } : {}),\n      ...(parsed.location ? { location: parsed.location } : {}),\n    },\n  });\n}\n\nexport async function handleGetAgentWorkItems(args: AgentArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, agentId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const scopeCheck = assertWorkspaceScope(auth.ctx, workspaceId);\n  if (!scopeCheck.ok) {\n    respondProblem(res, problemFromError(scopeCheck.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: { items: [], agentId } });\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.location.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'ensureRuntimeLocationDataSeeded' has too many lines (91). Maximum allowed is 80.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":137,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Async function 'handleListLocationEvents' has a complexity of 22. Maximum allowed is 10.","line":223,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":223,"endColumn":47},{"ruleId":"complexity","severity":2,"message":"Async function 'handleListMapLayers' has a complexity of 15. Maximum allowed is 10.","line":304,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":304,"endColumn":42}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Location-events and map-layer HTTP handlers for the control-plane runtime.\n */\n\nimport type { IncomingMessage, ServerResponse } from 'node:http';\n\nimport type { TraceContext } from '../../application/common/trace-context.js';\nimport {\n  InMemoryLocationHistoryStore,\n  InMemoryLocationLatestStateCache,\n} from '../../infrastructure/location/localisation-ingestion-pipeline.js';\nimport {\n  InMemoryLocationMapLayerStore,\n  MapDataServices,\n  parseAndStoreMapLayer,\n} from '../../infrastructure/location/map-data-services.js';\nimport { parseLocationEventV1 } from '../../domain/location/location-event-v1.js';\nimport { enforceLocationTelemetryBoundary } from './location-telemetry-boundary.js';\nimport {\n  type ControlPlaneDeps,\n  authenticate,\n  assertReadAccess,\n  paginate,\n  problemFromError,\n  respondJson,\n  respondProblem,\n} from './control-plane-handler.shared.js';\n\n// ---------------------------------------------------------------------------\n// Runtime singletons\n// ---------------------------------------------------------------------------\n\nconst runtimeLocationHistoryStore = new InMemoryLocationHistoryStore();\nconst runtimeLocationLatestStateCache = new InMemoryLocationLatestStateCache();\nconst runtimeLocationMapLayerStore = new InMemoryLocationMapLayerStore();\nexport const runtimeMapDataServices = new MapDataServices({\n  latestStateCache: runtimeLocationLatestStateCache,\n  historyStore: runtimeLocationHistoryStore,\n  mapLayerStore: runtimeLocationMapLayerStore,\n});\nlet runtimeLocationSeeded = false;\n\nexport async function ensureRuntimeLocationDataSeeded(): Promise<void> {\n  if (runtimeLocationSeeded) return;\n  runtimeLocationSeeded = true;\n\n  await parseAndStoreMapLayer(runtimeLocationMapLayerStore, {\n    schemaVersion: 1,\n    mapLayerId: 'ml-ws1-floor1',\n    tenantId: 'workspace-1',\n    siteId: 'site-a',\n    floorId: 'floor-1',\n    layerType: 'Floorplan',\n    coordinateFrame: 'floor-1',\n    origin: { x: 0, y: 0, z: 0 },\n    version: 1,\n    validFromIso: '2026-02-20T00:00:00.000Z',\n    provenance: {\n      sourceType: 'CadImport',\n      sourceRef: 'floor-1-v1',\n      registeredAtIso: '2026-02-20T00:00:00.000Z',\n      registeredBy: 'ops-admin',\n    },\n  });\n\n  await parseAndStoreMapLayer(runtimeLocationMapLayerStore, {\n    schemaVersion: 1,\n    mapLayerId: 'ml-ws2-floor1',\n    tenantId: 'workspace-2',\n    siteId: 'site-z',\n    floorId: 'floor-1',\n    layerType: 'Floorplan',\n    coordinateFrame: 'floor-1',\n    origin: { x: 0, y: 0, z: 0 },\n    version: 1,\n    validFromIso: '2026-02-20T00:00:00.000Z',\n    provenance: {\n      sourceType: 'CadImport',\n      sourceRef: 'floor-1-v1',\n      registeredAtIso: '2026-02-20T00:00:00.000Z',\n      registeredBy: 'ops-admin',\n    },\n  });\n\n  const locationEvents = [\n    parseLocationEventV1({\n      schemaVersion: 1,\n      locationEventId: 'loc-evt-1',\n      tenantId: 'workspace-1',\n      assetId: 'asset-1',\n      robotId: 'robot-1',\n      sourceStreamId: 'stream-1',\n      sourceType: 'SLAM',\n      coordinateFrame: 'floor-1',\n      observedAtIso: '2026-02-20T10:00:00.000Z',\n      ingestedAtIso: '2026-02-20T10:00:00.100Z',\n      pose: { x: 1, y: 2, z: 0, yawRadians: 0.2 },\n      quality: { status: 'Known', horizontalStdDevMeters: 0.2 },\n      correlationId: 'corr-location-1',\n    }),\n    parseLocationEventV1({\n      schemaVersion: 1,\n      locationEventId: 'loc-evt-2',\n      tenantId: 'workspace-1',\n      assetId: 'asset-1',\n      robotId: 'robot-1',\n      sourceStreamId: 'stream-2',\n      sourceType: 'RTLS',\n      coordinateFrame: 'floor-1',\n      observedAtIso: '2026-02-20T10:05:00.000Z',\n      ingestedAtIso: '2026-02-20T10:05:00.100Z',\n      pose: { x: 2, y: 3, z: 0, yawRadians: 0.3 },\n      quality: { status: 'Known', horizontalStdDevMeters: 0.3 },\n      correlationId: 'corr-location-2',\n    }),\n    parseLocationEventV1({\n      schemaVersion: 1,\n      locationEventId: 'loc-evt-3',\n      tenantId: 'workspace-2',\n      assetId: 'asset-2',\n      robotId: 'robot-2',\n      sourceStreamId: 'stream-3',\n      sourceType: 'SLAM',\n      coordinateFrame: 'floor-1',\n      observedAtIso: '2026-02-20T10:02:00.000Z',\n      ingestedAtIso: '2026-02-20T10:02:00.100Z',\n      pose: { x: 3, y: 4, z: 0, yawRadians: 0.4 },\n      quality: { status: 'Known', horizontalStdDevMeters: 0.25 },\n      correlationId: 'corr-location-3',\n    }),\n  ];\n\n  for (const event of locationEvents) {\n    await runtimeLocationHistoryStore.append(event);\n    await runtimeLocationLatestStateCache.put(event);\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\nfunction parseLocationTelemetryPurpose(\n  value: string | null,\n): 'operations' | 'incident-response' | 'compliance-audit' {\n  if (value === 'operations' || value === 'incident-response' || value === 'compliance-audit')\n    return value;\n  return 'incident-response';\n}\n\nfunction parsePositiveIntegerQueryParam(value: string | null): number | undefined {\n  if (value === null) return undefined;\n  const parsed = Number.parseInt(value, 10);\n  return Number.isInteger(parsed) && parsed > 0 ? parsed : undefined;\n}\n\n// ---------------------------------------------------------------------------\n// Handler arg types\n// ---------------------------------------------------------------------------\n\ntype HandlerArgs = Readonly<{\n  deps: ControlPlaneDeps;\n  req: IncomingMessage;\n  res: ServerResponse;\n  correlationId: string;\n  pathname: string;\n  workspaceId: string;\n  traceContext: TraceContext;\n}>;\n\n// ---------------------------------------------------------------------------\n// Handlers\n// ---------------------------------------------------------------------------\n\nexport async function handleLocationEventsStream(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const purpose = parseLocationTelemetryPurpose(url.searchParams.get('purpose'));\n  const boundary = enforceLocationTelemetryBoundary(\n    auth.ctx,\n    { mode: 'live', purpose },\n    undefined,\n    new Date(),\n  );\n  if (!boundary.ok) {\n    respondProblem(res, problemFromError(boundary.error, pathname), correlationId, traceContext);\n    return;\n  }\n  await ensureRuntimeLocationDataSeeded();\n  const assetId = url.searchParams.get('assetId') ?? 'asset-1';\n  const latest = await runtimeMapDataServices.getLatestPose(workspaceId, assetId);\n  const staleAfterSeconds = 30;\n  const stale = !latest || Date.now() - Date.parse(latest.observedAtIso) > staleAfterSeconds * 1000;\n  res.statusCode = 200;\n  res.setHeader('content-type', 'text/event-stream');\n  res.setHeader('cache-control', 'no-cache');\n  res.setHeader('connection', 'keep-alive');\n  res.setHeader('x-correlation-id', correlationId);\n  res.setHeader('traceparent', traceContext.traceparent);\n  if (traceContext.tracestate) res.setHeader('tracestate', traceContext.tracestate);\n  res.write(\n    `event: stream-metadata\\ndata: ${JSON.stringify({ staleAfterSeconds, stale, lastObservedAtIso: latest?.observedAtIso ?? null })}\\n\\n`,\n  );\n  res.write(`event: location\\ndata: ${JSON.stringify(latest)}\\n\\n`);\n  res.end();\n}\n\nexport async function handleListLocationEvents(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const fromIso = url.searchParams.get('fromIso') ?? undefined;\n  const toIso = url.searchParams.get('toIso') ?? undefined;\n  const purpose = parseLocationTelemetryPurpose(url.searchParams.get('purpose'));\n  const boundaryRequest =\n    fromIso && toIso\n      ? { mode: 'history' as const, purpose, fromIso, toIso }\n      : { mode: 'history' as const, purpose };\n  const boundary = enforceLocationTelemetryBoundary(\n    auth.ctx,\n    boundaryRequest,\n    undefined,\n    new Date(),\n  );\n  if (!boundary.ok) {\n    respondProblem(res, problemFromError(boundary.error, pathname), correlationId, traceContext);\n    return;\n  }\n  await ensureRuntimeLocationDataSeeded();\n  try {\n    const sourceTypeRaw = url.searchParams.get('sourceType');\n    const sourceType =\n      sourceTypeRaw === 'GPS' ||\n      sourceTypeRaw === 'RTLS' ||\n      sourceTypeRaw === 'SLAM' ||\n      sourceTypeRaw === 'odometry' ||\n      sourceTypeRaw === 'fusion'\n        ? sourceTypeRaw\n        : undefined;\n    const historyQuery: Parameters<typeof runtimeMapDataServices.queryHistory>[0] = {\n      tenantId: workspaceId,\n      fromIso: fromIso!,\n      toIso: toIso!,\n      ...(url.searchParams.get('assetId') ? { assetId: url.searchParams.get('assetId')! } : {}),\n      ...(url.searchParams.get('siteId') ? { siteId: url.searchParams.get('siteId')! } : {}),\n      ...(url.searchParams.get('floorId') ? { floorId: url.searchParams.get('floorId')! } : {}),\n      ...(sourceType ? { sourceType } : {}),\n      ...(parsePositiveIntegerQueryParam(url.searchParams.get('limit'))\n        ? { limit: parsePositiveIntegerQueryParam(url.searchParams.get('limit'))! }\n        : {}),\n    };\n    const items = await runtimeMapDataServices.queryHistory(historyQuery);\n    respondJson(res, {\n      statusCode: 200,\n      correlationId,\n      traceContext,\n      body: paginate(items, req.url ?? '/'),\n    });\n  } catch (error) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: error instanceof Error ? error.message : 'Invalid location-events query.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n  }\n}\n\nexport async function handleListMapLayers(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  await ensureRuntimeLocationDataSeeded();\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const layerTypeRaw = url.searchParams.get('layerType');\n  const layerType =\n    layerTypeRaw === 'Floorplan' ||\n    layerTypeRaw === 'OccupancyGrid' ||\n    layerTypeRaw === 'Geofence' ||\n    layerTypeRaw === 'SemanticZone'\n      ? layerTypeRaw\n      : undefined;\n  const versionRaw = url.searchParams.get('version');\n  const version = versionRaw ? Number.parseInt(versionRaw, 10) : undefined;\n  const mapLayerQuery: Parameters<typeof runtimeMapDataServices.listMapLayers>[0] = {\n    tenantId: workspaceId,\n    ...(url.searchParams.get('siteId') ? { siteId: url.searchParams.get('siteId')! } : {}),\n    ...(url.searchParams.get('floorId') ? { floorId: url.searchParams.get('floorId')! } : {}),\n    ...(layerType ? { layerType } : {}),\n    ...(version && !Number.isNaN(version) ? { version } : {}),\n  };\n  const items = await runtimeMapDataServices.listMapLayers(mapLayerQuery);\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: paginate(items, req.url ?? '/'),\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.machine-agent.contract.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.openapi.routes.review.test.ts","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.","line":101,"column":16,"nodeType":null,"messageId":"refactorFunction","endLine":101,"endColumn":37},{"ruleId":"complexity","severity":2,"message":"Function 'readParameters' has a complexity of 11. Maximum allowed is 10.","line":206,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":206,"endColumn":24},{"ruleId":"complexity","severity":2,"message":"Function 'resolveMaybeRef' has a complexity of 12. Maximum allowed is 10.","line":241,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":241,"endColumn":25},{"ruleId":"complexity","severity":2,"message":"Function 'sampleParameterValue' has a complexity of 15. Maximum allowed is 10.","line":274,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":274,"endColumn":30}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFile } from 'node:fs/promises';\nimport path from 'node:path';\n\nimport { parse as parseYaml } from 'yaml';\nimport { afterAll, beforeAll, describe, expect, it } from 'vitest';\n\nimport type { HealthServerHandle } from './health-server.js';\nimport { startHealthServer } from './health-server.js';\nimport { createControlPlaneHandler } from './control-plane-handler.js';\nimport { ok } from '../../application/common/result.js';\nimport { toAppContext } from '../../application/common/context.js';\n\ntype OpenApiParameter = Readonly<{\n  name: string;\n  in: 'path' | 'query' | 'header' | 'cookie';\n  required: boolean;\n  schema?: Record<string, unknown>;\n}>;\n\ntype OpenApiOperation = Readonly<{\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  pathTemplate: string;\n  operationId: string;\n  allowedStatuses: ReadonlySet<number>;\n  hasDefaultResponse: boolean;\n  parameters: readonly OpenApiParameter[];\n  hasJsonRequestBody: boolean;\n}>;\n\nconst OPENAPI_SPEC_RELATIVE_PATH = 'docs/spec/openapi/portarium-control-plane.v1.yaml';\nconst HTTP_METHODS = ['get', 'post', 'put', 'patch', 'delete'] as const;\n\nlet handle: HealthServerHandle | undefined;\n\nbeforeAll(async () => {\n  const ctx = toAppContext({\n    tenantId: 'workspace-1',\n    principalId: 'user-1',\n    roles: ['admin', 'operator', 'approver', 'auditor'],\n    correlationId: 'corr-openapi-routes-review',\n  });\n\n  handle = await startHealthServer({\n    role: 'control-plane',\n    host: '127.0.0.1',\n    port: 0,\n    handler: createControlPlaneHandler({\n      authentication: {\n        authenticateBearerToken: async () => ok(ctx),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    }),\n  });\n});\n\nafterAll(async () => {\n  await handle?.close();\n  handle = undefined;\n});\n\ndescribe('control-plane handler OpenAPI route review coverage', () => {\n  it('every OpenAPI operation resolves to a documented status and uses problem+json on errors', async () => {\n    if (!handle) throw new Error('Expected test server handle to be initialized.');\n\n    const operations = await loadOpenApiOperations();\n    expect(operations.length).toBeGreaterThan(0);\n\n    for (const operation of operations) {\n      const { urlPath, requestInit } = buildRequest(operation);\n      const res = await fetch(`http://${handle.host}:${handle.port}${urlPath}`, requestInit);\n\n      const statusIsDocumented =\n        operation.allowedStatuses.has(res.status) || operation.hasDefaultResponse;\n      if (!statusIsDocumented) {\n        throw new Error(\n          `${operation.operationId} (${operation.method} ${operation.pathTemplate}) returned undocumented status ${res.status}.`,\n        );\n      }\n\n      if (res.status >= 400) {\n        const contentType = res.headers.get('content-type') ?? '';\n        expect(contentType).toMatch(/application\\/problem\\+json/i);\n      }\n\n      await res.arrayBuffer();\n    }\n  });\n});\n\nasync function loadOpenApiOperations(): Promise<readonly OpenApiOperation[]> {\n  const specPath = path.join(process.cwd(), OPENAPI_SPEC_RELATIVE_PATH);\n  const raw = await readFile(specPath, 'utf8');\n  const doc = toRecord(parseYaml(raw), 'OpenAPI document');\n  const paths = toRecord(doc['paths'], 'OpenAPI.paths');\n  const components = toRecord(doc['components'], 'OpenAPI.components');\n  const componentParameters = toRecord(\n    components['parameters'] ?? {},\n    'OpenAPI.components.parameters',\n  );\n\n  const operations: OpenApiOperation[] = [];\n  for (const [pathTemplate, pathItemUnknown] of Object.entries(paths)) {\n    const pathItem = toRecord(pathItemUnknown, `OpenAPI.paths.${pathTemplate}`);\n    const pathParameters = readParameters(pathItem['parameters'], doc, componentParameters);\n\n    for (const method of HTTP_METHODS) {\n      const operationUnknown = pathItem[method];\n      if (!operationUnknown) continue;\n\n      const operation = toRecord(operationUnknown, `${pathTemplate}.${method}`);\n      const operationParameters = readParameters(operation['parameters'], doc, componentParameters);\n      const responses = toRecord(operation['responses'], `${pathTemplate}.${method}.responses`);\n\n      const allowedStatuses = new Set<number>();\n      let hasDefaultResponse = false;\n      for (const key of Object.keys(responses)) {\n        if (/^\\d{3}$/.test(key)) {\n          allowedStatuses.add(Number.parseInt(key, 10));\n        } else if (key === 'default') {\n          hasDefaultResponse = true;\n        }\n      }\n\n      const operationId =\n        typeof operation['operationId'] === 'string'\n          ? operation['operationId']\n          : `${method.toUpperCase()} ${pathTemplate}`;\n\n      operations.push({\n        method: method.toUpperCase() as OpenApiOperation['method'],\n        pathTemplate,\n        operationId,\n        allowedStatuses,\n        hasDefaultResponse,\n        parameters: [...pathParameters, ...operationParameters],\n        hasJsonRequestBody: hasJsonRequestBody(operation, doc),\n      });\n    }\n  }\n\n  return operations;\n}\n\nfunction buildRequest(operation: OpenApiOperation): {\n  urlPath: string;\n  requestInit: RequestInit;\n} {\n  let resolvedPath = operation.pathTemplate;\n  const query = new URLSearchParams();\n  const headers = new Headers();\n\n  for (const param of operation.parameters) {\n    const value = sampleParameterValue(param);\n    if (param.in === 'path') {\n      resolvedPath = resolvedPath.replace(`{${param.name}}`, encodeURIComponent(value));\n      continue;\n    }\n    if (param.in === 'query' && param.required) {\n      query.set(param.name, value);\n      continue;\n    }\n    if (param.in === 'header' && param.required) {\n      headers.set(param.name, value);\n    }\n  }\n\n  let body: string | undefined;\n  if (operation.hasJsonRequestBody) {\n    headers.set('content-type', 'application/json');\n    body = '{}';\n  }\n\n  const queryText = query.toString();\n  const urlPath = queryText === '' ? resolvedPath : `${resolvedPath}?${queryText}`;\n  return {\n    urlPath,\n    requestInit: {\n      method: operation.method,\n      headers,\n      ...(body ? { body } : {}),\n    },\n  };\n}\n\nfunction hasJsonRequestBody(\n  operation: Record<string, unknown>,\n  rootDoc: Record<string, unknown>,\n): boolean {\n  const requestBody = resolveMaybeRef(operation['requestBody'], rootDoc);\n  if (!requestBody) return false;\n  const content = toRecord(requestBody['content'] ?? {}, 'requestBody.content');\n  return Object.prototype.hasOwnProperty.call(content, 'application/json');\n}\n\nfunction readParameters(\n  value: unknown,\n  rootDoc: Record<string, unknown>,\n  componentParameters: Record<string, unknown>,\n): readonly OpenApiParameter[] {\n  if (!Array.isArray(value)) return [];\n\n  const parameters: OpenApiParameter[] = [];\n  for (const item of value) {\n    const resolved = resolveMaybeRef(item, rootDoc, componentParameters);\n    if (!resolved) continue;\n\n    const name = typeof resolved['name'] === 'string' ? resolved['name'] : undefined;\n    const location = resolved['in'];\n    if (\n      !name ||\n      (location !== 'path' &&\n        location !== 'query' &&\n        location !== 'header' &&\n        location !== 'cookie')\n    ) {\n      continue;\n    }\n\n    parameters.push({\n      name,\n      in: location,\n      required: resolved['required'] === true,\n      ...(isRecord(resolved['schema']) ? { schema: resolved['schema'] } : {}),\n    });\n  }\n\n  return parameters;\n}\n\nfunction resolveMaybeRef(\n  value: unknown,\n  rootDoc: Record<string, unknown>,\n  componentParameters?: Record<string, unknown>,\n): Record<string, unknown> | null {\n  if (!isRecord(value)) return null;\n\n  const ref = value['$ref'];\n  if (typeof ref !== 'string') return value;\n  if (!ref.startsWith('#/')) return null;\n\n  if (componentParameters && ref.startsWith('#/components/parameters/')) {\n    const key = ref.split('/').at(-1);\n    if (typeof key !== 'string') return null;\n    const candidate = componentParameters[key];\n    return isRecord(candidate) ? candidate : null;\n  }\n\n  const pointerTokens = ref\n    .slice(2)\n    .split('/')\n    .map((token) => token.replace(/~1/g, '/').replace(/~0/g, '~'));\n\n  let current: unknown = rootDoc;\n  for (const token of pointerTokens) {\n    if (!isRecord(current) || !Object.prototype.hasOwnProperty.call(current, token)) {\n      return null;\n    }\n    current = current[token];\n  }\n  return isRecord(current) ? current : null;\n}\n\nfunction sampleParameterValue(parameter: OpenApiParameter): string {\n  const byName: Record<string, string> = {\n    workspaceId: 'workspace-1',\n    userId: 'user-1',\n    workItemId: 'work-item-1',\n    workflowId: 'workflow-1',\n    runId: 'run-1',\n    approvalId: 'approval-1',\n    evidenceId: 'evidence-1',\n    adapterId: 'adapter-1',\n    credentialGrantId: 'credential-grant-1',\n    policyId: 'policy-1',\n    planId: 'plan-1',\n    workforceMemberId: 'wm-1',\n    queueId: 'queue-1',\n    humanTaskId: 'ht-1',\n    machineId: 'machine-1',\n    agentId: 'agent-1',\n    mapLayerId: 'map-layer-1',\n    locationEventId: 'loc-1',\n  };\n  if (Object.prototype.hasOwnProperty.call(byName, parameter.name)) {\n    return byName[parameter.name]!;\n  }\n\n  const schema = parameter.schema ?? {};\n  const enumValues = schema['enum'];\n  if (Array.isArray(enumValues) && enumValues.length > 0) {\n    const first = enumValues[0];\n    if (typeof first === 'string' || typeof first === 'number' || typeof first === 'boolean') {\n      return String(first);\n    }\n  }\n\n  if (schema['type'] === 'integer' || schema['type'] === 'number') return '1';\n  if (schema['type'] === 'boolean') return 'true';\n\n  if (parameter.name.toLowerCase().includes('iso')) {\n    return '2026-02-20T10:00:00.000Z';\n  }\n  if (parameter.name.toLowerCase().includes('from')) {\n    return '2026-02-20T10:00:00.000Z';\n  }\n  if (parameter.name.toLowerCase().includes('to')) {\n    return '2026-02-20T10:10:00.000Z';\n  }\n  if (parameter.name.toLowerCase().includes('limit')) {\n    return '1';\n  }\n\n  return `${parameter.name}-1`;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction toRecord(value: unknown, label: string): Record<string, unknown> {\n  if (!isRecord(value)) {\n    throw new Error(`${label} must be an object.`);\n  }\n  return value;\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.shared.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.test.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Arrow function has too many lines (487). Maximum allowed is 300.","line":25,"column":39,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":552,"endColumn":2},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (506). Maximum allowed is 350.","line":384,"column":1,"nodeType":null,"messageId":"exceed","endLine":553,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { afterEach, describe, expect, it } from 'vitest';\n\nimport type { HealthServerHandle } from './health-server.js';\nimport { startHealthServer } from './health-server.js';\nimport { createControlPlaneHandler } from './control-plane-handler.js';\nimport { ok, err } from '../../application/common/result.js';\nimport { toAppContext } from '../../application/common/context.js';\n\nlet handle: HealthServerHandle | undefined;\n\nafterEach(async () => {\n  await handle?.close();\n  handle = undefined;\n});\n\nfunction makeCtx(roles: readonly ('admin' | 'operator' | 'approver' | 'auditor')[] = ['admin']) {\n  return toAppContext({\n    tenantId: 'tenant-1',\n    principalId: 'user-1',\n    roles,\n    correlationId: 'corr-1',\n  });\n}\n\ndescribe('createControlPlaneHandler', () => {\n  it('routes GET workspace to application query and returns Problem Details on not found', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx()),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(`http://${handle.host}:${handle.port}/v1/workspaces/ws-1`);\n    expect(res.status).toBe(404);\n    expect(res.headers.get('content-type')).toMatch(/application\\/problem\\+json/i);\n    expect(res.headers.get('traceparent')).toMatch(/^00-[0-9a-f]{32}-[0-9a-f]{16}-[0-9a-f]{2}$/i);\n    const body = (await res.json()) as { type: string; status: number };\n    expect(body.type).toMatch(/not-found/);\n    expect(body.status).toBe(404);\n  });\n\n  it('routes GET run to application query and returns Problem Details on unauthorized', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () =>\n          err({ kind: 'Unauthorized' as const, message: 'Missing token.' }),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(`http://${handle.host}:${handle.port}/v1/workspaces/ws-1/runs/run-1`);\n    expect(res.status).toBe(401);\n    const body = (await res.json()) as { type: string; status: number; title: string };\n    expect(body.type).toMatch(/unauthorized/);\n    expect(body.status).toBe(401);\n    expect(body.title).toBe('Unauthorized');\n  });\n\n  it('returns Problem Details not-found for unknown routes', async () => {\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler({\n        authentication: {\n          authenticateBearerToken: async () => ok(makeCtx()),\n        },\n        authorization: {\n          isAllowed: async () => true,\n        },\n        workspaceStore: {\n          getWorkspaceById: async () => null,\n          getWorkspaceByName: async () => null,\n          saveWorkspace: async () => undefined,\n        },\n        runStore: {\n          getRunById: async () => null,\n          saveRun: async () => undefined,\n        },\n      }),\n    });\n\n    const res = await fetch(`http://${handle.host}:${handle.port}/v1/nope`);\n    expect(res.status).toBe(404);\n    const body = (await res.json()) as { detail: string };\n    expect(body.detail).toBe('Route not found.');\n  });\n\n  it('maps ValidationFailed to 400 and preserves x-correlation-id when provided', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx()),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(`http://${handle.host}:${handle.port}/v1/workspaces/%20`, {\n      headers: {\n        'x-correlation-id': 'corr-fixed',\n        traceparent: '00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01',\n        tracestate: 'vendor=value',\n      },\n    });\n    expect(res.status).toBe(422);\n    expect(res.headers.get('x-correlation-id')).toBe('corr-fixed');\n    expect(res.headers.get('traceparent')).toBe(\n      '00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01',\n    );\n    expect(res.headers.get('tracestate')).toBe('vendor=value');\n    const body = (await res.json()) as { type: string; status: number };\n    expect(body.type).toMatch(/validation-failed/);\n    expect(body.status).toBe(422);\n  });\n\n  it('maps Forbidden to 403', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx()),\n      },\n      authorization: {\n        isAllowed: async () => false,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(`http://${handle.host}:${handle.port}/v1/workspaces/ws-1`);\n    expect(res.status).toBe(403);\n    const body = (await res.json()) as { type: string; status: number };\n    expect(body.type).toMatch(/forbidden/);\n    expect(body.status).toBe(403);\n  });\n\n  it('returns 500 Problem Details when a dependency throws', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => {\n          throw new Error('boom');\n        },\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(`http://${handle.host}:${handle.port}/v1/workspaces/ws-1`);\n    expect(res.status).toBe(500);\n    const body = (await res.json()) as { type: string; status: number };\n    expect(body.type).toMatch(/internal/);\n    expect(body.status).toBe(500);\n  });\n\n  it('lists workforce members with contract query filters', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/workforce?capability=operations.approval&availability=available`,\n    );\n    expect(res.status).toBe(200);\n    const body = (await res.json()) as { items: { workforceMemberId: string }[] };\n    expect(body.items).toHaveLength(1);\n    expect(body.items[0]!.workforceMemberId).toBe('wm-1');\n  });\n\n  it('enforces admin-only update for workforce availability patch', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/workforce/wm-1/availability`,\n      {\n        method: 'PATCH',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({ availabilityStatus: 'offline' }),\n      },\n    );\n    expect(res.status).toBe(403);\n    const body = (await res.json()) as { title: string };\n    expect(body.title).toBe('Forbidden');\n  });\n\n  it('allows admin to patch workforce availability', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['admin'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/workforce/wm-1/availability`,\n      {\n        method: 'PATCH',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({ availabilityStatus: 'offline' }),\n      },\n    );\n    expect(res.status).toBe(200);\n    const body = (await res.json()) as { availabilityStatus: string; workforceMemberId: string };\n    expect(body.workforceMemberId).toBe('wm-1');\n    expect(body.availabilityStatus).toBe('offline');\n  });\n\n  it('lists human tasks with assignee/status filters', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/human-tasks?assigneeId=wm-1&status=assigned`,\n    );\n    expect(res.status).toBe(200);\n    const body = (await res.json()) as { items: { humanTaskId: string }[] };\n    expect(body.items).toHaveLength(1);\n    expect(body.items[0]!.humanTaskId).toBe('ht-1');\n  });\n\n  it('completes human task and emits evidence visible in evidence list', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const completeRes = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/human-tasks/ht-1/complete`,\n      {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({ completionNote: 'Done' }),\n      },\n    );\n    expect(completeRes.status).toBe(200);\n    const completed = (await completeRes.json()) as { status: string; evidenceAnchorId?: string };\n    expect(completed.status).toBe('completed');\n    expect(typeof completed.evidenceAnchorId).toBe('string');\n\n    const evidenceRes = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/evidence?category=Action`,\n    );\n    expect(evidenceRes.status).toBe(200);\n    const evidenceBody = (await evidenceRes.json()) as {\n      items: { evidenceId: string; summary: string }[];\n    };\n    expect(\n      evidenceBody.items.some((entry) => entry.evidenceId === completed.evidenceAnchorId),\n    ).toBe(true);\n  });\n\n  it('lists location events in a bounded playback window with filters', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/location-events?fromIso=2026-02-20T10:00:00.000Z&toIso=2026-02-20T10:10:00.000Z&sourceType=SLAM&siteId=site-a&floorId=floor-1&limit=1`,\n    );\n    expect(res.status).toBe(200);\n    const body = (await res.json()) as {\n      items: { locationEventId: string; tenantId: string; sourceType: string }[];\n      nextCursor?: string;\n    };\n    expect(body.items).toHaveLength(1);\n    expect(body.items[0]!.locationEventId).toBe('loc-evt-1');\n    expect(body.items[0]!.sourceType).toBe('SLAM');\n  });\n\n  it('serves location stream endpoint as text/event-stream with stale semantics metadata', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-1/location-events:stream?assetId=asset-1&purpose=operations`,\n    );\n    expect(res.status).toBe(200);\n    expect(res.headers.get('content-type')).toMatch(/text\\/event-stream/i);\n    const text = await res.text();\n    expect(text).toContain('event: stream-metadata');\n    expect(text).toContain('event: location');\n    expect(text).toContain('staleAfterSeconds');\n  });\n\n  it('lists map layers and enforces tenant isolation by workspace route', async () => {\n    const deps = {\n      authentication: {\n        authenticateBearerToken: async () => ok(makeCtx(['operator'])),\n      },\n      authorization: {\n        isAllowed: async () => true,\n      },\n      workspaceStore: {\n        getWorkspaceById: async () => null,\n        getWorkspaceByName: async () => null,\n        saveWorkspace: async () => undefined,\n      },\n      runStore: {\n        getRunById: async () => null,\n        saveRun: async () => undefined,\n      },\n    };\n\n    handle = await startHealthServer({\n      role: 'control-plane',\n      host: '127.0.0.1',\n      port: 0,\n      handler: createControlPlaneHandler(deps),\n    });\n\n    const res = await fetch(\n      `http://${handle.host}:${handle.port}/v1/workspaces/workspace-2/map-layers?version=1`,\n    );\n    expect(res.status).toBe(200);\n    const body = (await res.json()) as {\n      items: { tenantId: string; mapLayerId: string; version: number }[];\n    };\n    expect(body.items).toHaveLength(1);\n    expect(body.items[0]!.tenantId).toBe('workspace-2');\n    expect(body.items[0]!.mapLayerId).toBe('ml-ws2-floor1');\n    expect(body.items[0]!.version).toBe(1);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'ensureRuntimeLocationDataSeeded' has too many lines (93). Maximum allowed is 80.","line":231,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":327,"endColumn":2},{"ruleId":"max-params","severity":2,"message":"Function 'respondJson' has too many parameters (5). Maximum allowed is 4.","line":367,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":367,"endColumn":21},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (1987). Maximum allowed is 350.","line":379,"column":1,"nodeType":null,"messageId":"exceed","endLine":2151,"endColumn":1},{"ruleId":"max-params","severity":2,"message":"Async function 'authenticate' has too many parameters (5). Maximum allowed is 4.","line":540,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":540,"endColumn":28},{"ruleId":"complexity","severity":2,"message":"Function 'parseAssignHumanTaskBody' has a complexity of 11. Maximum allowed is 10.","line":682,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":682,"endColumn":34},{"ruleId":"complexity","severity":2,"message":"Async function 'handleListHumanTasks' has a complexity of 12. Maximum allowed is 10.","line":1039,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1039,"endColumn":36},{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'handleListLocationEvents' has too many lines (81). Maximum allowed is 80.","line":1198,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":1282,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Async function 'handleListLocationEvents' has a complexity of 22. Maximum allowed is 10.","line":1198,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1198,"endColumn":40},{"ruleId":"complexity","severity":2,"message":"Async function 'handleListMapLayers' has a complexity of 15. Maximum allowed is 10.","line":1284,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1284,"endColumn":35},{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'handleAssignHumanTask' has too many lines (84). Maximum allowed is 80.","line":1332,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":1416,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Async function 'handleAssignHumanTask' has a complexity of 11. Maximum allowed is 10.","line":1332,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1332,"endColumn":37},{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'handleCompleteHumanTask' has too many lines (93). Maximum allowed is 80.","line":1418,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":1512,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Async function 'handleListEvidence' has a complexity of 13. Maximum allowed is 10.","line":1592,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1592,"endColumn":34},{"ruleId":"complexity","severity":2,"message":"Function 'parseHeartbeatBody' has a complexity of 19. Maximum allowed is 10.","line":1645,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1645,"endColumn":28},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.","line":1645,"column":10,"nodeType":null,"messageId":"refactorFunction","endLine":1645,"endColumn":28},{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'handleRequest' has too many lines (283). Maximum allowed is 80.","line":1828,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":2129,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Async function 'handleRequest' has a complexity of 51. Maximum allowed is 10.","line":1828,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":1828,"endColumn":29},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 39 to the 15 allowed.","line":1828,"column":16,"nodeType":null,"messageId":"refactorFunction","endLine":1828,"endColumn":29}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { IncomingMessage, ServerResponse } from 'node:http';\nimport { createHash, randomBytes, randomUUID } from 'node:crypto';\n\nimport { WorkspaceRbacAuthorization } from '../../application/iam/rbac/workspace-rbac-authorization.js';\nimport { APP_ACTIONS } from '../../application/common/actions.js';\nimport type {\n  AuthenticationPort,\n  AuthorizationPort,\n  RunStore,\n  WorkspaceStore,\n} from '../../application/ports/index.js';\nimport type { AppContext } from '../../application/common/context.js';\nimport {\n  normalizeTraceparent,\n  normalizeTracestate,\n  type TraceContext,\n} from '../../application/common/trace-context.js';\nimport type {\n  Forbidden,\n  NotFound,\n  PreconditionFailed,\n  Unauthorized,\n  ValidationFailed,\n} from '../../application/common/errors.js';\nimport { err } from '../../application/common/result.js';\nimport { getRun } from '../../application/queries/get-run.js';\nimport { getWorkspace } from '../../application/queries/get-workspace.js';\nimport { JoseJwtAuthentication } from '../../infrastructure/auth/jose-jwt-authentication.js';\nimport { OpenFgaAuthorization } from '../../infrastructure/auth/openfga-authorization.js';\nimport { parseLocationEventV1 } from '../../domain/location/location-event-v1.js';\nimport {\n  InMemoryLocationHistoryStore,\n  InMemoryLocationLatestStateCache,\n} from '../../infrastructure/location/localisation-ingestion-pipeline.js';\nimport { NodePostgresSqlClient } from '../../infrastructure/postgresql/node-postgres-sql-client.js';\nimport {\n  PostgresRunStore,\n  PostgresWorkspaceStore,\n} from '../../infrastructure/postgresql/postgres-store-adapters.js';\nimport {\n  InMemoryLocationMapLayerStore,\n  MapDataServices,\n  parseAndStoreMapLayer,\n} from '../../infrastructure/location/map-data-services.js';\nimport { enforceLocationTelemetryBoundary } from './location-telemetry-boundary.js';\nimport type { RequestHandler } from './health-server.js';\n\ntype ProblemDetails = Readonly<{\n  type: string;\n  title: string;\n  status: number;\n  detail?: string;\n  instance?: string;\n}>;\n\ntype QueryError = Unauthorized | Forbidden | NotFound | ValidationFailed | PreconditionFailed;\n\ntype ControlPlaneDeps = Readonly<{\n  authentication: AuthenticationPort;\n  authorization: AuthorizationPort;\n  workspaceStore: WorkspaceStore;\n  runStore: RunStore;\n}>;\n\ntype WorkforceAvailabilityStatus = 'available' | 'busy' | 'offline';\n\ntype WorkforceCapability =\n  | 'operations.dispatch'\n  | 'operations.approval'\n  | 'operations.escalation'\n  | 'robotics.supervision'\n  | 'robotics.safety.override';\n\ntype WorkforceMemberRecord = Readonly<{\n  schemaVersion: 1;\n  workforceMemberId: string;\n  linkedUserId: string;\n  displayName: string;\n  capabilities: readonly WorkforceCapability[];\n  availabilityStatus: WorkforceAvailabilityStatus;\n  queueMemberships: readonly string[];\n  tenantId: string;\n  createdAtIso: string;\n  updatedAtIso?: string;\n}>;\n\ntype WorkforceQueueRecord = Readonly<{\n  schemaVersion: 1;\n  workforceQueueId: string;\n  name: string;\n  requiredCapabilities: readonly WorkforceCapability[];\n  memberIds: readonly string[];\n  routingStrategy: 'round-robin' | 'least-busy' | 'manual';\n  tenantId: string;\n}>;\n\ntype HumanTaskStatus = 'pending' | 'assigned' | 'in-progress' | 'completed' | 'escalated';\n\ntype HumanTaskRecord = Readonly<{\n  schemaVersion: 1;\n  humanTaskId: string;\n  workItemId: string;\n  runId: string;\n  stepId: string;\n  assigneeId?: string;\n  groupId?: string;\n  description: string;\n  requiredCapabilities: readonly WorkforceCapability[];\n  status: HumanTaskStatus;\n  dueAt?: string;\n  completedAt?: string;\n  completedById?: string;\n  evidenceAnchorId?: string;\n  tenantId: string;\n}>;\n\ntype EvidenceRecord = Readonly<{\n  schemaVersion: number;\n  evidenceId: string;\n  workspaceId: string;\n  occurredAtIso: string;\n  category: 'Plan' | 'Action' | 'Approval' | 'Policy' | 'System';\n  summary: string;\n  actor:\n    | Readonly<{ kind: 'User'; userId: string }>\n    | Readonly<{ kind: 'System' }>\n    | Readonly<{ kind: 'Machine'; machineId: string }>\n    | Readonly<{ kind: 'Adapter'; adapterId: string }>;\n  links?: Readonly<{\n    runId?: string;\n    planId?: string;\n    workItemId?: string;\n  }>;\n  hashSha256: string;\n}>;\n\nconst WORKFORCE_FIXTURE: Readonly<{\n  members: readonly WorkforceMemberRecord[];\n  queues: readonly WorkforceQueueRecord[];\n}> = {\n  members: [\n    {\n      schemaVersion: 1,\n      workforceMemberId: 'wm-1',\n      linkedUserId: 'user-1',\n      displayName: 'Alice Martinez',\n      capabilities: ['operations.approval', 'operations.escalation'],\n      availabilityStatus: 'available',\n      queueMemberships: ['queue-finance', 'queue-general'],\n      tenantId: 'workspace-1',\n      createdAtIso: '2026-02-19T00:00:00.000Z',\n      updatedAtIso: '2026-02-19T00:00:00.000Z',\n    },\n    {\n      schemaVersion: 1,\n      workforceMemberId: 'wm-2',\n      linkedUserId: 'user-2',\n      displayName: 'Bob Chen',\n      capabilities: ['operations.dispatch'],\n      availabilityStatus: 'busy',\n      queueMemberships: ['queue-general'],\n      tenantId: 'workspace-1',\n      createdAtIso: '2026-02-19T00:00:00.000Z',\n      updatedAtIso: '2026-02-19T00:00:00.000Z',\n    },\n  ],\n  queues: [\n    {\n      schemaVersion: 1,\n      workforceQueueId: 'queue-finance',\n      name: 'Finance Queue',\n      requiredCapabilities: ['operations.approval'],\n      memberIds: ['wm-1'],\n      routingStrategy: 'least-busy',\n      tenantId: 'workspace-1',\n    },\n    {\n      schemaVersion: 1,\n      workforceQueueId: 'queue-general',\n      name: 'General Queue',\n      requiredCapabilities: ['operations.dispatch'],\n      memberIds: ['wm-1', 'wm-2'],\n      routingStrategy: 'round-robin',\n      tenantId: 'workspace-1',\n    },\n  ],\n};\n\nconst HUMAN_TASK_FIXTURE: readonly HumanTaskRecord[] = [\n  {\n    schemaVersion: 1,\n    humanTaskId: 'ht-1',\n    workItemId: 'wi-101',\n    runId: 'run-101',\n    stepId: 'step-approve',\n    assigneeId: 'wm-1',\n    groupId: 'queue-finance',\n    description: 'Approve invoice correction',\n    requiredCapabilities: ['operations.approval'],\n    status: 'assigned',\n    dueAt: '2026-02-20T12:00:00.000Z',\n    tenantId: 'workspace-1',\n  },\n  {\n    schemaVersion: 1,\n    humanTaskId: 'ht-2',\n    workItemId: 'wi-102',\n    runId: 'run-102',\n    stepId: 'step-review',\n    groupId: 'queue-general',\n    description: 'Quality-check export batch',\n    requiredCapabilities: ['operations.dispatch'],\n    status: 'pending',\n    dueAt: '2026-02-21T12:00:00.000Z',\n    tenantId: 'workspace-1',\n  },\n];\n\nlet runtimeHumanTasks: HumanTaskRecord[] = [...HUMAN_TASK_FIXTURE];\nlet runtimeEvidence: EvidenceRecord[] = [];\nconst runtimeLocationHistoryStore = new InMemoryLocationHistoryStore();\nconst runtimeLocationLatestStateCache = new InMemoryLocationLatestStateCache();\nconst runtimeLocationMapLayerStore = new InMemoryLocationMapLayerStore();\nconst runtimeMapDataServices = new MapDataServices({\n  latestStateCache: runtimeLocationLatestStateCache,\n  historyStore: runtimeLocationHistoryStore,\n  mapLayerStore: runtimeLocationMapLayerStore,\n});\nlet runtimeLocationSeeded = false;\n\nasync function ensureRuntimeLocationDataSeeded(): Promise<void> {\n  if (runtimeLocationSeeded) {\n    return;\n  }\n  runtimeLocationSeeded = true;\n\n  await parseAndStoreMapLayer(runtimeLocationMapLayerStore, {\n    schemaVersion: 1,\n    mapLayerId: 'ml-ws1-floor1',\n    tenantId: 'workspace-1',\n    siteId: 'site-a',\n    floorId: 'floor-1',\n    layerType: 'Floorplan',\n    coordinateFrame: 'floor-1',\n    origin: { x: 0, y: 0, z: 0 },\n    version: 1,\n    validFromIso: '2026-02-20T00:00:00.000Z',\n    provenance: {\n      sourceType: 'CadImport',\n      sourceRef: 'floor-1-v1',\n      registeredAtIso: '2026-02-20T00:00:00.000Z',\n      registeredBy: 'ops-admin',\n    },\n  });\n\n  await parseAndStoreMapLayer(runtimeLocationMapLayerStore, {\n    schemaVersion: 1,\n    mapLayerId: 'ml-ws2-floor1',\n    tenantId: 'workspace-2',\n    siteId: 'site-z',\n    floorId: 'floor-1',\n    layerType: 'Floorplan',\n    coordinateFrame: 'floor-1',\n    origin: { x: 0, y: 0, z: 0 },\n    version: 1,\n    validFromIso: '2026-02-20T00:00:00.000Z',\n    provenance: {\n      sourceType: 'CadImport',\n      sourceRef: 'floor-1-v1',\n      registeredAtIso: '2026-02-20T00:00:00.000Z',\n      registeredBy: 'ops-admin',\n    },\n  });\n\n  const locationEvents = [\n    parseLocationEventV1({\n      schemaVersion: 1,\n      locationEventId: 'loc-evt-1',\n      tenantId: 'workspace-1',\n      assetId: 'asset-1',\n      robotId: 'robot-1',\n      sourceStreamId: 'stream-1',\n      sourceType: 'SLAM',\n      coordinateFrame: 'floor-1',\n      observedAtIso: '2026-02-20T10:00:00.000Z',\n      ingestedAtIso: '2026-02-20T10:00:00.100Z',\n      pose: { x: 1, y: 2, z: 0, yawRadians: 0.2 },\n      quality: { status: 'Known', horizontalStdDevMeters: 0.2 },\n      correlationId: 'corr-location-1',\n    }),\n    parseLocationEventV1({\n      schemaVersion: 1,\n      locationEventId: 'loc-evt-2',\n      tenantId: 'workspace-1',\n      assetId: 'asset-1',\n      robotId: 'robot-1',\n      sourceStreamId: 'stream-2',\n      sourceType: 'RTLS',\n      coordinateFrame: 'floor-1',\n      observedAtIso: '2026-02-20T10:05:00.000Z',\n      ingestedAtIso: '2026-02-20T10:05:00.100Z',\n      pose: { x: 2, y: 3, z: 0, yawRadians: 0.3 },\n      quality: { status: 'Known', horizontalStdDevMeters: 0.3 },\n      correlationId: 'corr-location-2',\n    }),\n    parseLocationEventV1({\n      schemaVersion: 1,\n      locationEventId: 'loc-evt-3',\n      tenantId: 'workspace-2',\n      assetId: 'asset-2',\n      robotId: 'robot-2',\n      sourceStreamId: 'stream-3',\n      sourceType: 'SLAM',\n      coordinateFrame: 'floor-1',\n      observedAtIso: '2026-02-20T10:02:00.000Z',\n      ingestedAtIso: '2026-02-20T10:02:00.100Z',\n      pose: { x: 3, y: 4, z: 0, yawRadians: 0.4 },\n      quality: { status: 'Known', horizontalStdDevMeters: 0.25 },\n      correlationId: 'corr-location-3',\n    }),\n  ];\n\n  for (const event of locationEvents) {\n    await runtimeLocationHistoryStore.append(event);\n    await runtimeLocationLatestStateCache.put(event);\n  }\n}\n\nfunction normalizeHeader(value: string | string[] | undefined): string | undefined {\n  if (typeof value === 'string') return value;\n  if (Array.isArray(value) && typeof value[0] === 'string') return value[0];\n  return undefined;\n}\n\nfunction readAuthorizationHeader(req: IncomingMessage): string | undefined {\n  const value = normalizeHeader(req.headers.authorization);\n  if (!value) return undefined;\n  const trimmed = value.trim();\n  return trimmed === '' ? undefined : trimmed;\n}\n\nfunction normalizeCorrelationId(req: IncomingMessage): string {\n  const value = normalizeHeader(req.headers['x-correlation-id']);\n  if (value && value.trim() !== '') return value.trim();\n  return randomUUID();\n}\n\nfunction randomHex(byteLength: number): string {\n  return randomBytes(byteLength).toString('hex');\n}\n\nfunction createTraceparent(): string {\n  // W3C Trace Context v00: version-traceid-spanid-flags\n  return `00-${randomHex(16)}-${randomHex(8)}-01`;\n}\n\nfunction normalizeTraceContext(req: IncomingMessage): TraceContext {\n  const inboundTraceparent = normalizeTraceparent(normalizeHeader(req.headers['traceparent']));\n  const inboundTracestate = normalizeTracestate(normalizeHeader(req.headers['tracestate']));\n\n  return {\n    traceparent: inboundTraceparent ?? createTraceparent(),\n    ...(inboundTracestate ? { tracestate: inboundTracestate } : {}),\n  };\n}\n\nfunction respondJson(\n  res: ServerResponse,\n  statusCode: number,\n  correlationId: string,\n  traceContext: TraceContext,\n  body: unknown,\n): void {\n  res.statusCode = statusCode;\n  res.setHeader('content-type', 'application/json');\n  res.setHeader('x-correlation-id', correlationId);\n  res.setHeader('traceparent', traceContext.traceparent);\n  if (traceContext.tracestate) {\n    res.setHeader('tracestate', traceContext.tracestate);\n  }\n  res.end(JSON.stringify(body));\n}\n\nfunction respondProblem(\n  res: ServerResponse,\n  problem: ProblemDetails,\n  correlationId: string,\n  traceContext: TraceContext,\n): void {\n  res.statusCode = problem.status;\n  res.setHeader('content-type', 'application/problem+json');\n  res.setHeader('x-correlation-id', correlationId);\n  res.setHeader('traceparent', traceContext.traceparent);\n  if (traceContext.tracestate) {\n    res.setHeader('tracestate', traceContext.tracestate);\n  }\n  res.end(JSON.stringify(problem));\n}\n\nfunction problemFromError(error: QueryError, instance: string): ProblemDetails {\n  switch (error.kind) {\n    case 'Unauthorized':\n      return {\n        type: 'https://portarium.dev/problems/unauthorized',\n        title: 'Unauthorized',\n        status: 401,\n        detail: error.message,\n        instance,\n      };\n    case 'Forbidden':\n      return {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: error.message,\n        instance,\n      };\n    case 'NotFound':\n      return {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: error.message,\n        instance,\n      };\n    case 'ValidationFailed':\n      return {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 422,\n        detail: error.message,\n        instance,\n      };\n    case 'PreconditionFailed':\n      return {\n        type: 'https://portarium.dev/problems/precondition-failed',\n        title: 'Precondition Failed',\n        status: 412,\n        detail: error.message,\n        instance,\n      };\n  }\n}\n\n/**\n * Compute a quoted weak ETag from arbitrary resource content.\n * Uses a short SHA-256 prefix (12 hex chars)  unique enough for cache/precondition use.\n */\nfunction computeETag(content: unknown): string {\n  const hash = createHash('sha256').update(JSON.stringify(content)).digest('hex').slice(0, 12);\n  return `\"${hash}\"`;\n}\n\n/**\n * Enforce an `If-Match` precondition.\n * Returns `{ ok: false, error: PreconditionFailed }` when the header is present\n * but does not match the current resource ETag.\n */\nfunction checkIfMatch(\n  req: IncomingMessage,\n  currentETag: string,\n): { ok: true } | { ok: false; error: PreconditionFailed } {\n  const ifMatch = req.headers['if-match'];\n  if (!ifMatch) return { ok: true };\n  // RFC 9110 13.1.1  treat '*' as always-matching\n  if (ifMatch === '*') return { ok: true };\n  if (ifMatch === currentETag) return { ok: true };\n  return {\n    ok: false,\n    error: { kind: 'PreconditionFailed', message: 'ETag does not match.', ifMatch },\n  };\n}\n\nfunction buildAuthentication(): AuthenticationPort {\n  const jwksUri = process.env['PORTARIUM_JWKS_URI']?.trim();\n  const issuer = process.env['PORTARIUM_JWT_ISSUER']?.trim();\n  const audience = process.env['PORTARIUM_JWT_AUDIENCE']?.trim();\n\n  if (jwksUri) {\n    return new JoseJwtAuthentication({\n      jwksUri,\n      ...(issuer && issuer !== '' ? { issuer } : {}),\n      ...(audience && audience !== '' ? { audience } : {}),\n    });\n  }\n\n  // Keep the container runnable without auth config; protected routes return 401.\n  return {\n    authenticateBearerToken: ({ correlationId }) =>\n      Promise.resolve(\n        err({ kind: 'Unauthorized', message: `Authentication not configured. (${correlationId})` }),\n      ),\n  };\n}\n\nfunction buildAuthorization(): AuthorizationPort {\n  const apiUrl = process.env['PORTARIUM_OPENFGA_API_URL']?.trim();\n  const storeId = process.env['PORTARIUM_OPENFGA_STORE_ID']?.trim();\n  const authorizationModelId = process.env['PORTARIUM_OPENFGA_AUTHORIZATION_MODEL_ID']?.trim();\n  const apiToken = process.env['PORTARIUM_OPENFGA_API_TOKEN']?.trim();\n\n  if (apiUrl && storeId) {\n    return new OpenFgaAuthorization({\n      apiUrl,\n      storeId,\n      ...(authorizationModelId ? { authorizationModelId } : {}),\n      ...(apiToken ? { apiToken } : {}),\n    });\n  }\n\n  return new WorkspaceRbacAuthorization();\n}\n\nfunction buildDeps(): ControlPlaneDeps {\n  const authentication = buildAuthentication();\n  const authorization = buildAuthorization();\n\n  const usePostgresStores = process.env['PORTARIUM_USE_POSTGRES_STORES']?.trim() === 'true';\n  const connectionString = process.env['PORTARIUM_DATABASE_URL']?.trim();\n  if (usePostgresStores && connectionString) {\n    const sqlClient = new NodePostgresSqlClient({ connectionString });\n    const workspaceStore: WorkspaceStore = new PostgresWorkspaceStore(sqlClient);\n    const runStore: RunStore = new PostgresRunStore(sqlClient);\n    return { authentication, authorization, workspaceStore, runStore };\n  }\n\n  const workspaceStore: WorkspaceStore = {\n    getWorkspaceById: () => Promise.resolve(null),\n    getWorkspaceByName: () => Promise.resolve(null),\n    saveWorkspace: () => Promise.resolve(),\n  };\n  const runStore: RunStore = {\n    getRunById: () => Promise.resolve(null),\n    saveRun: () => Promise.resolve(),\n  };\n\n  return { authentication, authorization, workspaceStore, runStore };\n}\n\nasync function authenticate(\n  deps: ControlPlaneDeps,\n  req: IncomingMessage,\n  correlationId: string,\n  traceContext: TraceContext,\n  expectedWorkspaceId: string | undefined,\n): Promise<{ ok: true; ctx: AppContext } | { ok: false; error: Unauthorized }> {\n  const auth = await deps.authentication.authenticateBearerToken({\n    authorizationHeader: readAuthorizationHeader(req),\n    correlationId,\n    traceparent: traceContext.traceparent,\n    ...(traceContext.tracestate ? { tracestate: traceContext.tracestate } : {}),\n    ...(expectedWorkspaceId ? { expectedWorkspaceId } : {}),\n  });\n\n  if (auth.ok) return { ok: true, ctx: auth.value };\n  return { ok: false, error: auth.error };\n}\n\nfunction assertWorkspaceScope(\n  ctx: AppContext,\n  workspaceId: string,\n): { ok: true } | { ok: false; error: Forbidden } {\n  if (String(ctx.tenantId) !== workspaceId) {\n    return {\n      ok: false,\n      error: {\n        kind: 'Forbidden',\n        action: APP_ACTIONS.workspaceRead,\n        message: `Token workspace does not match requested workspace: ${workspaceId}`,\n      },\n    };\n  }\n  return { ok: true };\n}\n\nasync function readJsonBody(req: IncomingMessage): Promise<unknown> {\n  const chunks: Buffer[] = [];\n  for await (const chunk of req) {\n    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk)));\n  }\n  if (chunks.length === 0) return null;\n  const raw = Buffer.concat(chunks).toString('utf8').trim();\n  if (raw === '') return null;\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}\n\nfunction hasRole(ctx: AppContext, role: 'admin' | 'operator' | 'approver' | 'auditor'): boolean {\n  return ctx.roles.includes(role);\n}\n\nfunction isWorkforceReadable(ctx: AppContext): boolean {\n  return (\n    hasRole(ctx, 'admin') ||\n    hasRole(ctx, 'operator') ||\n    hasRole(ctx, 'approver') ||\n    hasRole(ctx, 'auditor')\n  );\n}\n\nasync function assertReadAccess(\n  deps: ControlPlaneDeps,\n  ctx: AppContext,\n): Promise<{ ok: true } | { ok: false; error: Forbidden }> {\n  if (!isWorkforceReadable(ctx)) {\n    return {\n      ok: false,\n      error: {\n        kind: 'Forbidden',\n        action: APP_ACTIONS.workspaceRead,\n        message: 'Read access denied.',\n      },\n    };\n  }\n\n  const allowed = await deps.authorization.isAllowed(ctx, APP_ACTIONS.workspaceRead);\n  if (allowed) return { ok: true };\n  return {\n    ok: false,\n    error: { kind: 'Forbidden', action: APP_ACTIONS.workspaceRead, message: 'Read access denied.' },\n  };\n}\n\nfunction listFixtureMembers(workspaceId: string): WorkforceMemberRecord[] {\n  return WORKFORCE_FIXTURE.members.filter((m) => m.tenantId === workspaceId);\n}\n\nfunction listFixtureQueues(workspaceId: string): WorkforceQueueRecord[] {\n  return WORKFORCE_FIXTURE.queues.filter((q) => q.tenantId === workspaceId);\n}\n\nfunction paginate<T extends Readonly<Record<string, unknown>>>(\n  items: readonly T[],\n  reqUrl: string,\n): { items: readonly T[]; nextCursor?: string } {\n  const url = new URL(reqUrl, 'http://localhost');\n  const limitRaw = url.searchParams.get('limit');\n  const limit = limitRaw ? Math.max(1, Number.parseInt(limitRaw, 10)) : undefined;\n  if (!limit || Number.isNaN(limit) || items.length <= limit) {\n    return { items: [...items] };\n  }\n  const sliced = items.slice(0, limit);\n  return { items: sliced, nextCursor: String(limit) };\n}\n\nfunction parseLocationTelemetryPurpose(\n  value: string | null,\n): 'operations' | 'incident-response' | 'compliance-audit' {\n  if (value === 'operations' || value === 'incident-response' || value === 'compliance-audit') {\n    return value;\n  }\n  return 'incident-response';\n}\n\nfunction parsePositiveIntegerQueryParam(value: string | null): number | undefined {\n  if (value === null) return undefined;\n  const parsed = Number.parseInt(value, 10);\n  if (!Number.isInteger(parsed) || parsed <= 0) {\n    return undefined;\n  }\n  return parsed;\n}\n\nfunction parseAvailabilityPatchBody(\n  value: unknown,\n): { ok: true; availabilityStatus: WorkforceAvailabilityStatus } | { ok: false } {\n  if (typeof value !== 'object' || value === null) return { ok: false };\n  const record = value as { availabilityStatus?: unknown };\n  if (\n    record.availabilityStatus === 'available' ||\n    record.availabilityStatus === 'busy' ||\n    record.availabilityStatus === 'offline'\n  ) {\n    return { ok: true, availabilityStatus: record.availabilityStatus };\n  }\n  return { ok: false };\n}\n\nfunction parseAssignHumanTaskBody(\n  value: unknown,\n): { ok: true; workforceMemberId?: string; workforceQueueId?: string } | { ok: false } {\n  if (typeof value !== 'object' || value === null) return { ok: false };\n  const record = value as { workforceMemberId?: unknown; workforceQueueId?: unknown };\n  const workforceMemberId =\n    typeof record.workforceMemberId === 'string' && record.workforceMemberId.trim() !== ''\n      ? record.workforceMemberId.trim()\n      : undefined;\n  const workforceQueueId =\n    typeof record.workforceQueueId === 'string' && record.workforceQueueId.trim() !== ''\n      ? record.workforceQueueId.trim()\n      : undefined;\n  if (!workforceMemberId && !workforceQueueId) return { ok: false };\n  return {\n    ok: true,\n    ...(workforceMemberId ? { workforceMemberId } : {}),\n    ...(workforceQueueId ? { workforceQueueId } : {}),\n  };\n}\n\nfunction parseCompleteHumanTaskBody(\n  value: unknown,\n): { ok: true; completionNote?: string } | { ok: false } {\n  if (value === null) return { ok: true };\n  if (typeof value !== 'object') return { ok: false };\n  const record = value as { completionNote?: unknown };\n  const completionNote =\n    typeof record.completionNote === 'string' && record.completionNote.trim() !== ''\n      ? record.completionNote.trim()\n      : undefined;\n  return { ok: true, ...(completionNote ? { completionNote } : {}) };\n}\n\nfunction parseEscalateHumanTaskBody(\n  value: unknown,\n): { ok: true; workforceQueueId: string; reason?: string } | { ok: false } {\n  if (typeof value !== 'object' || value === null) return { ok: false };\n  const record = value as { workforceQueueId?: unknown; reason?: unknown };\n  if (typeof record.workforceQueueId !== 'string' || record.workforceQueueId.trim() === '') {\n    return { ok: false };\n  }\n  const reason =\n    typeof record.reason === 'string' && record.reason.trim() !== ''\n      ? record.reason.trim()\n      : undefined;\n  return {\n    ok: true,\n    workforceQueueId: record.workforceQueueId.trim(),\n    ...(reason ? { reason } : {}),\n  };\n}\n\nfunction listRuntimeHumanTasks(workspaceId: string): HumanTaskRecord[] {\n  return runtimeHumanTasks.filter((task) => task.tenantId === workspaceId);\n}\n\nfunction updateRuntimeHumanTask(nextTask: HumanTaskRecord): void {\n  runtimeHumanTasks = runtimeHumanTasks.map((task) =>\n    task.humanTaskId === nextTask.humanTaskId && task.tenantId === nextTask.tenantId\n      ? nextTask\n      : task,\n  );\n}\n\nfunction listRuntimeEvidence(workspaceId: string): EvidenceRecord[] {\n  return runtimeEvidence.filter((entry) => entry.workspaceId === workspaceId);\n}\n\nasync function handleGetWorkspace(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const result = await getWorkspace(\n    { authorization: deps.authorization, workspaceStore: deps.workspaceStore },\n    auth.ctx,\n    { workspaceId },\n  );\n\n  if (result.ok) {\n    const etag = computeETag(result.value);\n    res.setHeader('ETag', etag);\n    respondJson(res, 200, correlationId, traceContext, result.value);\n    return;\n  }\n\n  respondProblem(res, problemFromError(result.error, pathname), correlationId, traceContext);\n}\n\nasync function handleGetRun(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    runId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, runId, traceContext } = args;\n\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const result = await getRun(\n    { authorization: deps.authorization, runStore: deps.runStore },\n    auth.ctx,\n    { workspaceId, runId },\n  );\n\n  if (result.ok) {\n    const etag = computeETag(result.value);\n    res.setHeader('ETag', etag);\n\n    // Honour If-Match for optimistic-concurrency clients on the run resource.\n    const precondition = checkIfMatch(req, etag);\n    if (!precondition.ok) {\n      respondProblem(\n        res,\n        problemFromError(precondition.error, pathname),\n        correlationId,\n        traceContext,\n      );\n      return;\n    }\n\n    respondJson(res, 200, correlationId, traceContext, result.value);\n    return;\n  }\n\n  respondProblem(res, problemFromError(result.error, pathname), correlationId, traceContext);\n}\n\nasync function handleListWorkforceMembers(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const capability = url.searchParams.get('capability');\n  const queueId = url.searchParams.get('queueId');\n  const availability = url.searchParams.get('availability');\n\n  let items = listFixtureMembers(workspaceId);\n  if (capability) {\n    items = items.filter((m) => m.capabilities.includes(capability as WorkforceCapability));\n  }\n  if (queueId) {\n    items = items.filter((m) => m.queueMemberships.includes(queueId));\n  }\n  if (availability === 'available' || availability === 'busy' || availability === 'offline') {\n    items = items.filter((m) => m.availabilityStatus === availability);\n  }\n\n  const body = paginate(items, req.url ?? '/');\n  respondJson(res, 200, correlationId, traceContext, body);\n}\n\nasync function handleGetWorkforceMember(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    workforceMemberId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, workforceMemberId, traceContext } =\n    args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const member = listFixtureMembers(workspaceId).find(\n    (m) => m.workforceMemberId === workforceMemberId,\n  );\n  if (!member) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Workforce member ${workforceMemberId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  respondJson(res, 200, correlationId, traceContext, member);\n}\n\nasync function handlePatchWorkforceAvailability(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    workforceMemberId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, workforceMemberId, traceContext } =\n    args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admins can update workforce availability in this runtime.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const member = listFixtureMembers(workspaceId).find(\n    (m) => m.workforceMemberId === workforceMemberId,\n  );\n  if (!member) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Workforce member ${workforceMemberId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const body = parseAvailabilityPatchBody(await readJsonBody(req));\n  if (!body.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'availabilityStatus must be one of: available, busy, offline.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const updated: WorkforceMemberRecord = {\n    ...member,\n    availabilityStatus: body.availabilityStatus,\n    updatedAtIso: new Date().toISOString(),\n  };\n  respondJson(res, 200, correlationId, traceContext, updated);\n}\n\nasync function handleListWorkforceQueues(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const capability = url.searchParams.get('capability');\n  let items = listFixtureQueues(workspaceId);\n  if (capability) {\n    items = items.filter((queue) =>\n      queue.requiredCapabilities.includes(capability as WorkforceCapability),\n    );\n  }\n  const body = paginate(items, req.url ?? '/');\n  respondJson(res, 200, correlationId, traceContext, body);\n}\n\nasync function handleListHumanTasks(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const assigneeId = url.searchParams.get('assigneeId');\n  const status = url.searchParams.get('status');\n  const runId = url.searchParams.get('runId');\n\n  let items = listRuntimeHumanTasks(workspaceId);\n  if (assigneeId) {\n    items = items.filter((task) => task.assigneeId === assigneeId);\n  }\n  if (\n    status === 'pending' ||\n    status === 'assigned' ||\n    status === 'in-progress' ||\n    status === 'completed' ||\n    status === 'escalated'\n  ) {\n    items = items.filter((task) => task.status === status);\n  }\n  if (runId) {\n    items = items.filter((task) => task.runId === runId);\n  }\n\n  const body = paginate(items, req.url ?? '/');\n  respondJson(res, 200, correlationId, traceContext, body);\n}\n\nasync function handleGetHumanTask(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    humanTaskId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  respondJson(res, 200, correlationId, traceContext, task);\n}\n\nasync function handleLocationEventsStream(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const purpose = parseLocationTelemetryPurpose(url.searchParams.get('purpose'));\n  const boundary = enforceLocationTelemetryBoundary(\n    auth.ctx,\n    {\n      mode: 'live',\n      purpose,\n    },\n    undefined,\n    new Date(),\n  );\n  if (!boundary.ok) {\n    respondProblem(res, problemFromError(boundary.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  await ensureRuntimeLocationDataSeeded();\n  const assetId = url.searchParams.get('assetId') ?? 'asset-1';\n  const latest = await runtimeMapDataServices.getLatestPose(workspaceId, assetId);\n  const staleAfterSeconds = 30;\n  const stale = !latest || Date.now() - Date.parse(latest.observedAtIso) > staleAfterSeconds * 1000;\n\n  res.statusCode = 200;\n  res.setHeader('content-type', 'text/event-stream');\n  res.setHeader('cache-control', 'no-cache');\n  res.setHeader('connection', 'keep-alive');\n  res.setHeader('x-correlation-id', correlationId);\n  res.setHeader('traceparent', traceContext.traceparent);\n  if (traceContext.tracestate) {\n    res.setHeader('tracestate', traceContext.tracestate);\n  }\n\n  res.write(\n    `event: stream-metadata\\ndata: ${JSON.stringify({\n      staleAfterSeconds,\n      stale,\n      lastObservedAtIso: latest?.observedAtIso ?? null,\n    })}\\n\\n`,\n  );\n  res.write(`event: location\\ndata: ${JSON.stringify(latest)}\\n\\n`);\n  res.end();\n}\n\nasync function handleListLocationEvents(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const fromIso = url.searchParams.get('fromIso') ?? undefined;\n  const toIso = url.searchParams.get('toIso') ?? undefined;\n  const purpose = parseLocationTelemetryPurpose(url.searchParams.get('purpose'));\n  const boundaryRequest =\n    fromIso && toIso\n      ? { mode: 'history' as const, purpose, fromIso, toIso }\n      : { mode: 'history' as const, purpose };\n  const boundary = enforceLocationTelemetryBoundary(\n    auth.ctx,\n    boundaryRequest,\n    undefined,\n    new Date(),\n  );\n  if (!boundary.ok) {\n    respondProblem(res, problemFromError(boundary.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  await ensureRuntimeLocationDataSeeded();\n  try {\n    const sourceTypeRaw = url.searchParams.get('sourceType');\n    const sourceType =\n      sourceTypeRaw === 'GPS' ||\n      sourceTypeRaw === 'RTLS' ||\n      sourceTypeRaw === 'SLAM' ||\n      sourceTypeRaw === 'odometry' ||\n      sourceTypeRaw === 'fusion'\n        ? sourceTypeRaw\n        : undefined;\n\n    const historyQuery: Parameters<typeof runtimeMapDataServices.queryHistory>[0] = {\n      tenantId: workspaceId,\n      fromIso: fromIso!,\n      toIso: toIso!,\n      ...(url.searchParams.get('assetId') ? { assetId: url.searchParams.get('assetId')! } : {}),\n      ...(url.searchParams.get('siteId') ? { siteId: url.searchParams.get('siteId')! } : {}),\n      ...(url.searchParams.get('floorId') ? { floorId: url.searchParams.get('floorId')! } : {}),\n      ...(sourceType ? { sourceType } : {}),\n      ...(parsePositiveIntegerQueryParam(url.searchParams.get('limit'))\n        ? { limit: parsePositiveIntegerQueryParam(url.searchParams.get('limit'))! }\n        : {}),\n    };\n\n    const items = await runtimeMapDataServices.queryHistory(historyQuery);\n    const body = paginate(items, req.url ?? '/');\n    respondJson(res, 200, correlationId, traceContext, body);\n  } catch (error) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: error instanceof Error ? error.message : 'Invalid location-events query.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n  }\n}\n\nasync function handleListMapLayers(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  await ensureRuntimeLocationDataSeeded();\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const layerTypeRaw = url.searchParams.get('layerType');\n  const layerType =\n    layerTypeRaw === 'Floorplan' ||\n    layerTypeRaw === 'OccupancyGrid' ||\n    layerTypeRaw === 'Geofence' ||\n    layerTypeRaw === 'SemanticZone'\n      ? layerTypeRaw\n      : undefined;\n  const versionRaw = url.searchParams.get('version');\n  const version = versionRaw ? Number.parseInt(versionRaw, 10) : undefined;\n\n  const mapLayerQuery: Parameters<typeof runtimeMapDataServices.listMapLayers>[0] = {\n    tenantId: workspaceId,\n    ...(url.searchParams.get('siteId') ? { siteId: url.searchParams.get('siteId')! } : {}),\n    ...(url.searchParams.get('floorId') ? { floorId: url.searchParams.get('floorId')! } : {}),\n    ...(layerType ? { layerType } : {}),\n    ...(version && !Number.isNaN(version) ? { version } : {}),\n  };\n  const items = await runtimeMapDataServices.listMapLayers(mapLayerQuery);\n  const body = paginate(items, req.url ?? '/');\n  respondJson(res, 200, correlationId, traceContext, body);\n}\n\nasync function handleAssignHumanTask(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    humanTaskId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin') && !hasRole(auth.ctx, 'operator')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admin/operator can assign human tasks.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const body = parseAssignHumanTaskBody(await readJsonBody(req));\n  if (!body.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'workforceMemberId or workforceQueueId is required.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const updated: HumanTaskRecord = {\n    ...task,\n    status: body.workforceMemberId ? 'assigned' : task.status,\n    ...(body.workforceMemberId\n      ? { assigneeId: body.workforceMemberId }\n      : task.assigneeId\n        ? { assigneeId: task.assigneeId }\n        : {}),\n    ...(body.workforceQueueId\n      ? { groupId: body.workforceQueueId }\n      : task.groupId\n        ? { groupId: task.groupId }\n        : {}),\n  };\n  updateRuntimeHumanTask(updated);\n  respondJson(res, 200, correlationId, traceContext, updated);\n}\n\nasync function handleCompleteHumanTask(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    humanTaskId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin') && !hasRole(auth.ctx, 'operator')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admin/operator can complete human tasks.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const parsed = parseCompleteHumanTaskBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'completionNote must be a string when provided.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const evidenceId = `evi-${randomUUID()}`;\n  const nowIso = new Date().toISOString();\n  const evidence: EvidenceRecord = {\n    schemaVersion: 1,\n    evidenceId,\n    workspaceId,\n    occurredAtIso: nowIso,\n    category: 'Action',\n    summary: parsed.completionNote\n      ? `Human task ${humanTaskId} completed: ${parsed.completionNote}`\n      : `Human task ${humanTaskId} completed.`,\n    actor: { kind: 'User', userId: auth.ctx.principalId },\n    links: { runId: task.runId, workItemId: task.workItemId },\n    hashSha256: randomBytes(32).toString('hex'),\n  };\n  runtimeEvidence = [...runtimeEvidence, evidence];\n\n  const updated: HumanTaskRecord = {\n    ...task,\n    status: 'completed',\n    completedAt: nowIso,\n    completedById: task.assigneeId ?? 'wm-1',\n    evidenceAnchorId: evidenceId,\n  };\n  updateRuntimeHumanTask(updated);\n  respondJson(res, 200, correlationId, traceContext, updated);\n}\n\nasync function handleEscalateHumanTask(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    humanTaskId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin') && !hasRole(auth.ctx, 'operator')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admin/operator can escalate human tasks.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const parsed = parseEscalateHumanTaskBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'workforceQueueId is required.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const { assigneeId: _dropAssigneeId, ...taskWithoutAssignee } = task;\n  const updated: HumanTaskRecord = {\n    ...taskWithoutAssignee,\n    status: 'escalated',\n    groupId: parsed.workforceQueueId,\n  };\n  updateRuntimeHumanTask(updated);\n  respondJson(res, 200, correlationId, traceContext, updated);\n}\n\nasync function handleListEvidence(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const runId = url.searchParams.get('runId');\n  const planId = url.searchParams.get('planId');\n  const workItemId = url.searchParams.get('workItemId');\n  const category = url.searchParams.get('category');\n\n  let items = listRuntimeEvidence(workspaceId);\n  if (runId) {\n    items = items.filter((entry) => entry.links?.runId === runId);\n  }\n  if (planId) {\n    items = items.filter((entry) => entry.links?.planId === planId);\n  }\n  if (workItemId) {\n    items = items.filter((entry) => entry.links?.workItemId === workItemId);\n  }\n  if (\n    category === 'Plan' ||\n    category === 'Action' ||\n    category === 'Approval' ||\n    category === 'Policy' ||\n    category === 'System'\n  ) {\n    items = items.filter((entry) => entry.category === category);\n  }\n\n  const body = paginate(items, req.url ?? '/');\n  respondJson(res, 200, correlationId, traceContext, body);\n}\n\nfunction parseHeartbeatBody(body: unknown):\n  | {\n      ok: true;\n      status: string;\n      metrics?: Record<string, number>;\n      location?: { lat: number; lon: number };\n    }\n  | { ok: false; message: string } {\n  if (typeof body !== 'object' || body === null) {\n    return { ok: false, message: 'Request body must be a JSON object.' };\n  }\n  const record = body as Record<string, unknown>;\n  const status = record['status'];\n  if (status !== 'ok' && status !== 'degraded') {\n    return { ok: false, message: 'status must be \"ok\" or \"degraded\".' };\n  }\n  const metrics = record['metrics'];\n  if (metrics !== undefined && metrics !== null) {\n    if (typeof metrics !== 'object' || Array.isArray(metrics)) {\n      return { ok: false, message: 'metrics must be a record of numbers.' };\n    }\n  }\n  const location = record['location'];\n  if (location !== undefined && location !== null) {\n    if (typeof location !== 'object' || Array.isArray(location)) {\n      return { ok: false, message: 'location must have lat and lon.' };\n    }\n    const loc = location as Record<string, unknown>;\n    if (typeof loc['lat'] !== 'number' || typeof loc['lon'] !== 'number') {\n      return { ok: false, message: 'location must have numeric lat and lon.' };\n    }\n  }\n  return {\n    ok: true,\n    status: status as string,\n    ...(metrics !== undefined && metrics !== null\n      ? { metrics: metrics as Record<string, number> }\n      : {}),\n    ...(location !== undefined && location !== null\n      ? { location: location as { lat: number; lon: number } }\n      : {}),\n  };\n}\n\nasync function handleMachineHeartbeat(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    machineId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, machineId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const scopeCheck = assertWorkspaceScope(auth.ctx, workspaceId);\n  if (!scopeCheck.ok) {\n    respondProblem(res, problemFromError(scopeCheck.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const parsed = parseHeartbeatBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: parsed.message,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const nowIso = new Date().toISOString();\n  respondJson(res, 200, correlationId, traceContext, {\n    machineId,\n    lastHeartbeatAtIso: nowIso,\n    status: parsed.status,\n    ...(parsed.metrics ? { metrics: parsed.metrics } : {}),\n    ...(parsed.location ? { location: parsed.location } : {}),\n  });\n}\n\nasync function handleAgentHeartbeat(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    agentId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, agentId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const scopeCheck = assertWorkspaceScope(auth.ctx, workspaceId);\n  if (!scopeCheck.ok) {\n    respondProblem(res, problemFromError(scopeCheck.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const parsed = parseHeartbeatBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: parsed.message,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n\n  const nowIso = new Date().toISOString();\n  respondJson(res, 200, correlationId, traceContext, {\n    agentId,\n    lastHeartbeatAtIso: nowIso,\n    status: parsed.status,\n    ...(parsed.metrics ? { metrics: parsed.metrics } : {}),\n    ...(parsed.location ? { location: parsed.location } : {}),\n  });\n}\n\nasync function handleGetAgentWorkItems(\n  args: Readonly<{\n    deps: ControlPlaneDeps;\n    req: IncomingMessage;\n    res: ServerResponse;\n    correlationId: string;\n    pathname: string;\n    workspaceId: string;\n    agentId: string;\n    traceContext: TraceContext;\n  }>,\n): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, agentId, traceContext } = args;\n  const auth = await authenticate(deps, req, correlationId, traceContext, workspaceId);\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const scopeCheck = assertWorkspaceScope(auth.ctx, workspaceId);\n  if (!scopeCheck.ok) {\n    respondProblem(res, problemFromError(scopeCheck.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n\n  // Return an empty page for now; real store wiring happens with infrastructure adapter\n  respondJson(res, 200, correlationId, traceContext, { items: [], agentId });\n}\n\nasync function handleRequest(\n  deps: ControlPlaneDeps,\n  req: IncomingMessage,\n  res: ServerResponse,\n): Promise<void> {\n  const correlationId = normalizeCorrelationId(req);\n  const traceContext = normalizeTraceContext(req);\n  const pathname = new URL(req.url ?? '/', 'http://localhost').pathname;\n\n  if (req.method === 'GET') {\n    const mWorkspace = /^\\/v1\\/workspaces\\/([^/]+)$/.exec(pathname);\n    if (mWorkspace) {\n      await handleGetWorkspace({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mWorkspace[1] ?? ''),\n      });\n      return;\n    }\n\n    const mRun = /^\\/v1\\/workspaces\\/([^/]+)\\/runs\\/([^/]+)$/.exec(pathname);\n    if (mRun) {\n      await handleGetRun({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mRun[1] ?? ''),\n        runId: decodeURIComponent(mRun[2] ?? ''),\n      });\n      return;\n    }\n\n    const mLocationStream = /^\\/v1\\/workspaces\\/([^/]+)\\/location-events:stream$/.exec(pathname);\n    if (mLocationStream) {\n      await handleLocationEventsStream({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mLocationStream[1] ?? ''),\n      });\n      return;\n    }\n\n    const mLocationEvents = /^\\/v1\\/workspaces\\/([^/]+)\\/location-events$/.exec(pathname);\n    if (mLocationEvents) {\n      await handleListLocationEvents({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mLocationEvents[1] ?? ''),\n      });\n      return;\n    }\n\n    const mMapLayers = /^\\/v1\\/workspaces\\/([^/]+)\\/map-layers$/.exec(pathname);\n    if (mMapLayers) {\n      await handleListMapLayers({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mMapLayers[1] ?? ''),\n      });\n      return;\n    }\n\n    const mWorkforceList = /^\\/v1\\/workspaces\\/([^/]+)\\/workforce$/.exec(pathname);\n    if (mWorkforceList) {\n      await handleListWorkforceMembers({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mWorkforceList[1] ?? ''),\n      });\n      return;\n    }\n\n    const mQueueList = /^\\/v1\\/workspaces\\/([^/]+)\\/workforce\\/queues$/.exec(pathname);\n    if (mQueueList) {\n      await handleListWorkforceQueues({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mQueueList[1] ?? ''),\n      });\n      return;\n    }\n\n    const mHumanTaskList = /^\\/v1\\/workspaces\\/([^/]+)\\/human-tasks$/.exec(pathname);\n    if (mHumanTaskList) {\n      await handleListHumanTasks({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mHumanTaskList[1] ?? ''),\n      });\n      return;\n    }\n\n    const mEvidenceList = /^\\/v1\\/workspaces\\/([^/]+)\\/evidence$/.exec(pathname);\n    if (mEvidenceList) {\n      await handleListEvidence({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mEvidenceList[1] ?? ''),\n      });\n      return;\n    }\n\n    const mWorkforceMember = /^\\/v1\\/workspaces\\/([^/]+)\\/workforce\\/([^/]+)$/.exec(pathname);\n    if (mWorkforceMember) {\n      await handleGetWorkforceMember({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mWorkforceMember[1] ?? ''),\n        workforceMemberId: decodeURIComponent(mWorkforceMember[2] ?? ''),\n      });\n      return;\n    }\n\n    const mHumanTask = /^\\/v1\\/workspaces\\/([^/]+)\\/human-tasks\\/([^/]+)$/.exec(pathname);\n    if (mHumanTask) {\n      await handleGetHumanTask({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mHumanTask[1] ?? ''),\n        humanTaskId: decodeURIComponent(mHumanTask[2] ?? ''),\n      });\n      return;\n    }\n\n    const mAgentWorkItems = /^\\/v1\\/workspaces\\/([^/]+)\\/agents\\/([^/]+)\\/work-items$/.exec(\n      pathname,\n    );\n    if (mAgentWorkItems) {\n      await handleGetAgentWorkItems({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mAgentWorkItems[1] ?? ''),\n        agentId: decodeURIComponent(mAgentWorkItems[2] ?? ''),\n      });\n      return;\n    }\n  }\n\n  if (req.method === 'PATCH') {\n    const mPatchAvailability = /^\\/v1\\/workspaces\\/([^/]+)\\/workforce\\/([^/]+)\\/availability$/.exec(\n      pathname,\n    );\n    if (mPatchAvailability) {\n      await handlePatchWorkforceAvailability({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mPatchAvailability[1] ?? ''),\n        workforceMemberId: decodeURIComponent(mPatchAvailability[2] ?? ''),\n      });\n      return;\n    }\n  }\n\n  if (req.method === 'POST') {\n    const mMachineHeartbeat = /^\\/v1\\/workspaces\\/([^/]+)\\/machines\\/([^/]+)\\/heartbeat$/.exec(\n      pathname,\n    );\n    if (mMachineHeartbeat) {\n      await handleMachineHeartbeat({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mMachineHeartbeat[1] ?? ''),\n        machineId: decodeURIComponent(mMachineHeartbeat[2] ?? ''),\n      });\n      return;\n    }\n\n    const mAgentHeartbeat = /^\\/v1\\/workspaces\\/([^/]+)\\/agents\\/([^/]+)\\/heartbeat$/.exec(\n      pathname,\n    );\n    if (mAgentHeartbeat) {\n      await handleAgentHeartbeat({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mAgentHeartbeat[1] ?? ''),\n        agentId: decodeURIComponent(mAgentHeartbeat[2] ?? ''),\n      });\n      return;\n    }\n\n    const mAssignTask = /^\\/v1\\/workspaces\\/([^/]+)\\/human-tasks\\/([^/]+)\\/assign$/.exec(pathname);\n    if (mAssignTask) {\n      await handleAssignHumanTask({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mAssignTask[1] ?? ''),\n        humanTaskId: decodeURIComponent(mAssignTask[2] ?? ''),\n      });\n      return;\n    }\n\n    const mCompleteTask = /^\\/v1\\/workspaces\\/([^/]+)\\/human-tasks\\/([^/]+)\\/complete$/.exec(\n      pathname,\n    );\n    if (mCompleteTask) {\n      await handleCompleteHumanTask({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mCompleteTask[1] ?? ''),\n        humanTaskId: decodeURIComponent(mCompleteTask[2] ?? ''),\n      });\n      return;\n    }\n\n    const mEscalateTask = /^\\/v1\\/workspaces\\/([^/]+)\\/human-tasks\\/([^/]+)\\/escalate$/.exec(\n      pathname,\n    );\n    if (mEscalateTask) {\n      await handleEscalateHumanTask({\n        deps,\n        req,\n        res,\n        correlationId,\n        traceContext,\n        pathname,\n        workspaceId: decodeURIComponent(mEscalateTask[1] ?? ''),\n        humanTaskId: decodeURIComponent(mEscalateTask[2] ?? ''),\n      });\n      return;\n    }\n  }\n\n  respondProblem(\n    res,\n    {\n      type: 'https://portarium.dev/problems/not-found',\n      title: 'Not Found',\n      status: 404,\n      detail: 'Route not found.',\n      instance: pathname,\n    },\n    correlationId,\n    traceContext,\n  );\n}\n\nexport function createControlPlaneHandler(deps: ControlPlaneDeps = buildDeps()): RequestHandler {\n  return (req, res) => {\n    void handleRequest(deps, req, res).catch((error) => {\n      const correlationId = randomUUID();\n      const traceContext = normalizeTraceContext(req);\n      respondProblem(\n        res,\n        {\n          type: 'https://portarium.dev/problems/internal',\n          title: 'Internal Server Error',\n          status: 500,\n          detail: error instanceof Error ? error.message : 'Unhandled error.',\n          instance: req.url ?? '/',\n        },\n        correlationId,\n        traceContext,\n      );\n    });\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane-handler.workforce.ts","messages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (712). Maximum allowed is 350.","line":396,"column":1,"nodeType":null,"messageId":"exceed","endLine":774,"endColumn":1},{"ruleId":"complexity","severity":2,"message":"Async function 'handleAssignHumanTask' has a complexity of 11. Maximum allowed is 10.","line":501,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":501,"endColumn":44},{"ruleId":"max-lines-per-function","severity":2,"message":"Async function 'handleCompleteHumanTask' has too many lines (87). Maximum allowed is 80.","line":574,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":660,"endColumn":2}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Workforce and human-task HTTP handlers for the control-plane runtime.\n */\n\nimport type { IncomingMessage, ServerResponse } from 'node:http';\nimport { randomBytes, randomUUID } from 'node:crypto';\n\nimport type { TraceContext } from '../../application/common/trace-context.js';\nimport {\n  type ControlPlaneDeps,\n  type HumanTaskRecord,\n  type EvidenceRecord,\n  type WorkforceAvailabilityStatus,\n  type WorkforceCapability,\n  type WorkforceMemberRecord,\n  type WorkforceQueueRecord,\n  authenticate,\n  assertReadAccess,\n  hasRole,\n  paginate,\n  problemFromError,\n  readJsonBody,\n  respondJson,\n  respondProblem,\n} from './control-plane-handler.shared.js';\n\n// ---------------------------------------------------------------------------\n// Fixtures\n// ---------------------------------------------------------------------------\n\nconst WORKFORCE_FIXTURE: Readonly<{\n  members: readonly WorkforceMemberRecord[];\n  queues: readonly WorkforceQueueRecord[];\n}> = {\n  members: [\n    {\n      schemaVersion: 1,\n      workforceMemberId: 'wm-1',\n      linkedUserId: 'user-1',\n      displayName: 'Alice Martinez',\n      capabilities: ['operations.approval', 'operations.escalation'],\n      availabilityStatus: 'available',\n      queueMemberships: ['queue-finance', 'queue-general'],\n      tenantId: 'workspace-1',\n      createdAtIso: '2026-02-19T00:00:00.000Z',\n      updatedAtIso: '2026-02-19T00:00:00.000Z',\n    },\n    {\n      schemaVersion: 1,\n      workforceMemberId: 'wm-2',\n      linkedUserId: 'user-2',\n      displayName: 'Bob Chen',\n      capabilities: ['operations.dispatch'],\n      availabilityStatus: 'busy',\n      queueMemberships: ['queue-general'],\n      tenantId: 'workspace-1',\n      createdAtIso: '2026-02-19T00:00:00.000Z',\n      updatedAtIso: '2026-02-19T00:00:00.000Z',\n    },\n  ],\n  queues: [\n    {\n      schemaVersion: 1,\n      workforceQueueId: 'queue-finance',\n      name: 'Finance Queue',\n      requiredCapabilities: ['operations.approval'],\n      memberIds: ['wm-1'],\n      routingStrategy: 'least-busy',\n      tenantId: 'workspace-1',\n    },\n    {\n      schemaVersion: 1,\n      workforceQueueId: 'queue-general',\n      name: 'General Queue',\n      requiredCapabilities: ['operations.dispatch'],\n      memberIds: ['wm-1', 'wm-2'],\n      routingStrategy: 'round-robin',\n      tenantId: 'workspace-1',\n    },\n  ],\n};\n\nconst HUMAN_TASK_FIXTURE: readonly HumanTaskRecord[] = [\n  {\n    schemaVersion: 1,\n    humanTaskId: 'ht-1',\n    workItemId: 'wi-101',\n    runId: 'run-101',\n    stepId: 'step-approve',\n    assigneeId: 'wm-1',\n    groupId: 'queue-finance',\n    description: 'Approve invoice correction',\n    requiredCapabilities: ['operations.approval'],\n    status: 'assigned',\n    dueAt: '2026-02-20T12:00:00.000Z',\n    tenantId: 'workspace-1',\n  },\n  {\n    schemaVersion: 1,\n    humanTaskId: 'ht-2',\n    workItemId: 'wi-102',\n    runId: 'run-102',\n    stepId: 'step-review',\n    groupId: 'queue-general',\n    description: 'Quality-check export batch',\n    requiredCapabilities: ['operations.dispatch'],\n    status: 'pending',\n    dueAt: '2026-02-21T12:00:00.000Z',\n    tenantId: 'workspace-1',\n  },\n];\n\n// ---------------------------------------------------------------------------\n// Mutable runtime state (module-level singletons)\n// ---------------------------------------------------------------------------\n\nlet runtimeHumanTasks: HumanTaskRecord[] = [...HUMAN_TASK_FIXTURE];\nexport let runtimeEvidence: EvidenceRecord[] = [];\n\nexport function listFixtureMembers(workspaceId: string): WorkforceMemberRecord[] {\n  return WORKFORCE_FIXTURE.members.filter((m) => m.tenantId === workspaceId);\n}\n\nexport function listFixtureQueues(workspaceId: string): WorkforceQueueRecord[] {\n  return WORKFORCE_FIXTURE.queues.filter((q) => q.tenantId === workspaceId);\n}\n\nexport function listRuntimeHumanTasks(workspaceId: string): HumanTaskRecord[] {\n  return runtimeHumanTasks.filter((task) => task.tenantId === workspaceId);\n}\n\nexport function updateRuntimeHumanTask(nextTask: HumanTaskRecord): void {\n  runtimeHumanTasks = runtimeHumanTasks.map((task) =>\n    task.humanTaskId === nextTask.humanTaskId && task.tenantId === nextTask.tenantId\n      ? nextTask\n      : task,\n  );\n}\n\nexport function listRuntimeEvidence(workspaceId: string): EvidenceRecord[] {\n  return runtimeEvidence.filter((entry) => entry.workspaceId === workspaceId);\n}\n\nexport function appendRuntimeEvidence(entry: EvidenceRecord): void {\n  runtimeEvidence = [...runtimeEvidence, entry];\n}\n\n// ---------------------------------------------------------------------------\n// Body parsers\n// ---------------------------------------------------------------------------\n\nfunction parseAvailabilityPatchBody(\n  value: unknown,\n): { ok: true; availabilityStatus: WorkforceAvailabilityStatus } | { ok: false } {\n  if (typeof value !== 'object' || value === null) return { ok: false };\n  const record = value as { availabilityStatus?: unknown };\n  if (\n    record.availabilityStatus === 'available' ||\n    record.availabilityStatus === 'busy' ||\n    record.availabilityStatus === 'offline'\n  ) {\n    return { ok: true, availabilityStatus: record.availabilityStatus };\n  }\n  return { ok: false };\n}\n\nfunction readOptionalString(value: unknown): string | undefined {\n  if (typeof value !== 'string') return undefined;\n  const trimmed = value.trim();\n  return trimmed !== '' ? trimmed : undefined;\n}\n\nfunction parseAssignHumanTaskBody(\n  value: unknown,\n): { ok: true; workforceMemberId?: string; workforceQueueId?: string } | { ok: false } {\n  if (typeof value !== 'object' || value === null) return { ok: false };\n  const record = value as { workforceMemberId?: unknown; workforceQueueId?: unknown };\n  const workforceMemberId = readOptionalString(record.workforceMemberId);\n  const workforceQueueId = readOptionalString(record.workforceQueueId);\n  if (!workforceMemberId && !workforceQueueId) return { ok: false };\n  return {\n    ok: true,\n    ...(workforceMemberId ? { workforceMemberId } : {}),\n    ...(workforceQueueId ? { workforceQueueId } : {}),\n  };\n}\n\nfunction parseCompleteHumanTaskBody(\n  value: unknown,\n): { ok: true; completionNote?: string } | { ok: false } {\n  if (value === null) return { ok: true };\n  if (typeof value !== 'object') return { ok: false };\n  const record = value as { completionNote?: unknown };\n  const completionNote =\n    typeof record.completionNote === 'string' && record.completionNote.trim() !== ''\n      ? record.completionNote.trim()\n      : undefined;\n  return { ok: true, ...(completionNote ? { completionNote } : {}) };\n}\n\nfunction parseEscalateHumanTaskBody(\n  value: unknown,\n): { ok: true; workforceQueueId: string; reason?: string } | { ok: false } {\n  if (typeof value !== 'object' || value === null) return { ok: false };\n  const record = value as { workforceQueueId?: unknown; reason?: unknown };\n  if (typeof record.workforceQueueId !== 'string' || record.workforceQueueId.trim() === '')\n    return { ok: false };\n  const reason =\n    typeof record.reason === 'string' && record.reason.trim() !== ''\n      ? record.reason.trim()\n      : undefined;\n  return {\n    ok: true,\n    workforceQueueId: record.workforceQueueId.trim(),\n    ...(reason ? { reason } : {}),\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Handler args type alias\n// ---------------------------------------------------------------------------\n\ntype HandlerArgs = Readonly<{\n  deps: ControlPlaneDeps;\n  req: IncomingMessage;\n  res: ServerResponse;\n  correlationId: string;\n  pathname: string;\n  workspaceId: string;\n  traceContext: TraceContext;\n}>;\n\ntype HandlerArgsWithMember = HandlerArgs & Readonly<{ workforceMemberId: string }>;\ntype HandlerArgsWithHumanTask = HandlerArgs & Readonly<{ humanTaskId: string }>;\n\n// ---------------------------------------------------------------------------\n// Workforce handlers\n// ---------------------------------------------------------------------------\n\nexport async function handleListWorkforceMembers(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const capability = url.searchParams.get('capability');\n  const queueId = url.searchParams.get('queueId');\n  const availability = url.searchParams.get('availability');\n  let items = listFixtureMembers(workspaceId);\n  if (capability)\n    items = items.filter((m) => m.capabilities.includes(capability as WorkforceCapability));\n  if (queueId) items = items.filter((m) => m.queueMemberships.includes(queueId));\n  if (availability === 'available' || availability === 'busy' || availability === 'offline') {\n    items = items.filter((m) => m.availabilityStatus === availability);\n  }\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: paginate(items, req.url ?? '/'),\n  });\n}\n\nexport async function handleGetWorkforceMember(args: HandlerArgsWithMember): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, workforceMemberId, traceContext } =\n    args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const member = listFixtureMembers(workspaceId).find(\n    (m) => m.workforceMemberId === workforceMemberId,\n  );\n  if (!member) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Workforce member ${workforceMemberId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: member });\n}\n\nexport async function handlePatchWorkforceAvailability(args: HandlerArgsWithMember): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, workforceMemberId, traceContext } =\n    args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admins can update workforce availability in this runtime.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const member = listFixtureMembers(workspaceId).find(\n    (m) => m.workforceMemberId === workforceMemberId,\n  );\n  if (!member) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Workforce member ${workforceMemberId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const body = parseAvailabilityPatchBody(await readJsonBody(req));\n  if (!body.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'availabilityStatus must be one of: available, busy, offline.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const updated: WorkforceMemberRecord = {\n    ...member,\n    availabilityStatus: body.availabilityStatus,\n    updatedAtIso: new Date().toISOString(),\n  };\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: updated });\n}\n\nexport async function handleListWorkforceQueues(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const capability = url.searchParams.get('capability');\n  let items = listFixtureQueues(workspaceId);\n  if (capability)\n    items = items.filter((queue) =>\n      queue.requiredCapabilities.includes(capability as WorkforceCapability),\n    );\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: paginate(items, req.url ?? '/'),\n  });\n}\n\n// ---------------------------------------------------------------------------\n// Human task handlers\n// ---------------------------------------------------------------------------\n\nconst VALID_TASK_STATUSES = new Set([\n  'pending',\n  'assigned',\n  'in-progress',\n  'completed',\n  'escalated',\n]);\n\nexport async function handleListHumanTasks(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const assigneeId = url.searchParams.get('assigneeId');\n  const status = url.searchParams.get('status');\n  const runId = url.searchParams.get('runId');\n  let items = listRuntimeHumanTasks(workspaceId);\n  if (assigneeId) items = items.filter((task) => task.assigneeId === assigneeId);\n  if (status && VALID_TASK_STATUSES.has(status))\n    items = items.filter((task) => task.status === status);\n  if (runId) items = items.filter((task) => task.runId === runId);\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: paginate(items, req.url ?? '/'),\n  });\n}\n\nexport async function handleGetHumanTask(args: HandlerArgsWithHumanTask): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: task });\n}\n\nexport async function handleAssignHumanTask(args: HandlerArgsWithHumanTask): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin') && !hasRole(auth.ctx, 'operator')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admin/operator can assign human tasks.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const body = parseAssignHumanTaskBody(await readJsonBody(req));\n  if (!body.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'workforceMemberId or workforceQueueId is required.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const assigneeId = body.workforceMemberId ?? task.assigneeId;\n  const groupId = body.workforceQueueId ?? task.groupId;\n  const updated: HumanTaskRecord = {\n    ...task,\n    status: body.workforceMemberId ? 'assigned' : task.status,\n    ...(assigneeId ? { assigneeId } : {}),\n    ...(groupId ? { groupId } : {}),\n  };\n  updateRuntimeHumanTask(updated);\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: updated });\n}\n\nexport async function handleCompleteHumanTask(args: HandlerArgsWithHumanTask): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin') && !hasRole(auth.ctx, 'operator')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admin/operator can complete human tasks.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const parsed = parseCompleteHumanTaskBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'completionNote must be a string when provided.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const evidenceId = `evi-${randomUUID()}`;\n  const nowIso = new Date().toISOString();\n  const evidence: EvidenceRecord = {\n    schemaVersion: 1,\n    evidenceId,\n    workspaceId,\n    occurredAtIso: nowIso,\n    category: 'Action',\n    summary: parsed.completionNote\n      ? `Human task ${humanTaskId} completed: ${parsed.completionNote}`\n      : `Human task ${humanTaskId} completed.`,\n    actor: { kind: 'User', userId: auth.ctx.principalId },\n    links: { runId: task.runId, workItemId: task.workItemId },\n    hashSha256: randomBytes(32).toString('hex'),\n  };\n  appendRuntimeEvidence(evidence);\n  const updated: HumanTaskRecord = {\n    ...task,\n    status: 'completed',\n    completedAt: nowIso,\n    completedById: task.assigneeId ?? 'wm-1',\n    evidenceAnchorId: evidenceId,\n  };\n  updateRuntimeHumanTask(updated);\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: updated });\n}\n\nexport async function handleEscalateHumanTask(args: HandlerArgsWithHumanTask): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, humanTaskId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  if (!hasRole(auth.ctx, 'admin') && !hasRole(auth.ctx, 'operator')) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/forbidden',\n        title: 'Forbidden',\n        status: 403,\n        detail: 'Only admin/operator can escalate human tasks.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const task = listRuntimeHumanTasks(workspaceId).find(\n    (entry) => entry.humanTaskId === humanTaskId,\n  );\n  if (!task) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/not-found',\n        title: 'Not Found',\n        status: 404,\n        detail: `Human task ${humanTaskId} not found.`,\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const parsed = parseEscalateHumanTaskBody(await readJsonBody(req));\n  if (!parsed.ok) {\n    respondProblem(\n      res,\n      {\n        type: 'https://portarium.dev/problems/validation-failed',\n        title: 'Validation Failed',\n        status: 400,\n        detail: 'workforceQueueId is required.',\n        instance: pathname,\n      },\n      correlationId,\n      traceContext,\n    );\n    return;\n  }\n  const { assigneeId: _dropAssigneeId, ...taskWithoutAssignee } = task;\n  const updated: HumanTaskRecord = {\n    ...taskWithoutAssignee,\n    status: 'escalated',\n    groupId: parsed.workforceQueueId,\n  };\n  updateRuntimeHumanTask(updated);\n  respondJson(res, { statusCode: 200, correlationId, traceContext, body: updated });\n}\n\n// ---------------------------------------------------------------------------\n// Evidence handler\n// ---------------------------------------------------------------------------\n\nconst VALID_EVIDENCE_CATEGORIES = new Set(['Plan', 'Action', 'Approval', 'Policy', 'System']);\n\nexport async function handleListEvidence(args: HandlerArgs): Promise<void> {\n  const { deps, req, res, correlationId, pathname, workspaceId, traceContext } = args;\n  const auth = await authenticate(deps, {\n    req,\n    correlationId,\n    traceContext,\n    expectedWorkspaceId: workspaceId,\n  });\n  if (!auth.ok) {\n    respondProblem(res, problemFromError(auth.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const readAccess = await assertReadAccess(deps, auth.ctx);\n  if (!readAccess.ok) {\n    respondProblem(res, problemFromError(readAccess.error, pathname), correlationId, traceContext);\n    return;\n  }\n  const url = new URL(req.url ?? '/', 'http://localhost');\n  const runId = url.searchParams.get('runId');\n  const planId = url.searchParams.get('planId');\n  const workItemId = url.searchParams.get('workItemId');\n  const category = url.searchParams.get('category');\n  let items = listRuntimeEvidence(workspaceId);\n  if (runId) items = items.filter((entry) => entry.links?.runId === runId);\n  if (planId) items = items.filter((entry) => entry.links?.planId === planId);\n  if (workItemId) items = items.filter((entry) => entry.links?.workItemId === workItemId);\n  if (category && VALID_EVIDENCE_CATEGORIES.has(category))\n    items = items.filter((entry) => entry.category === category);\n  respondJson(res, {\n    statusCode: 200,\n    correlationId,\n    traceContext,\n    body: paginate(items, req.url ?? '/'),\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\control-plane.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\health-server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\health-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\location-telemetry-boundary.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\location-telemetry-boundary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\runtime-containment.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\runtime-containment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\worker-temporal-disabled.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\worker-temporal.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\worker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\presentation\\runtime\\worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\sdk\\portarium-client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\sdk\\portarium-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\src\\sdk\\trace-propagation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Visual Studio Projects\\VAOP\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
